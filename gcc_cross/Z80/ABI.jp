Z80 の ABI

(*1) レジスタ

	pc, sp, af, bc, de, hl, ix, iy : 16 ビット

	af レジスタの上位 8 ビット : a
	af レジスタの下位 8 ビット : f
	b, c, d, e, h, l についても同様.

	af' : af の裏レジスタ
	bc', de', hl' についても同様.
	裏レジスタを使用する特殊な命令がある.

	フラグレジスタ

	+-+-+-+-+-+-+-+-+
	| | | | | | | | |
	+-+-+-+-+-+-+-+-+
	 S Z x H x P N C
	           V
	C : キャリーフラグ
	N : 加減算フラグ
	P/V : パリティ/オーバフローフラグ
	x : 未使用
	H : ハーフキャリーフラグ
	Z : ゼロフラグ
	S : サインフラグ

(*2) 函数呼び出し

	call	func

	疑似コード

	sp := sp - 2
	[sp] := call 命令の次のアドレス
	pc := func


(*3) 函数復帰

	ret

	疑似コード

	pc := [sp]
	sp := sp + 2

(*4) インデックスレジスタ相対

	ld	a, (ix-4)
	ld	(iy+4), b

	のように ix, iy 相対で -128 から 127 のオフセットを指定することができる.
	しかし指定できるレジスタは 8 ビットのみ.
	この命令は 19 クロックを消費するらしい.

	ローカル変数にアクセスする方法

	+---------------+ <- sp_{new}, ix_{new}
	|		|
	|		|
	~		~
	|		|
	|		|
	+---------------+
	|    ix_{old}	|
	+---------------+
	|    sp_{old}	|
	+---------------+ <- sp_{old}
	| return address|
	+---------------+

	ix をフレームポインタのように使用する.
	
	sizeof(char) = sizeof(short) = sizeof(int) = 1
	sizeof(long) = 2
	sizeof(long long) = 4
	sizeof(void*) = 2

	のような少し変わったコンパイラを作成してみるという選択はあるが

	sizeof(char) = 1
	sizeof(short) = sizeof(int) = 2
	sizeof(long) = 4
	sizeof(long long) = 8
	sizeof(void*) = 2	

	がおそらく妥当なところ.

	しかしプログラマがしたいことが 8 ビットの加算で十分なのであれば上の
	選択はある. おそらくこれはオプションによって選択できるべき.
	せっかくだから sizeof(int) = 1 のほうをまずは実装してみることにする.
	
(*5) プロローグ

	以下は 64 バイトのローカル領域を使用する函数のプロローグ

	ld	hl, 0
	add	hl, sp
	push	hl
	push	ix
	ld	a, l
	sub	68
	ld	l, a
	ld	sp, hl
	ld	ix, 0
	add	ix, sp

	+---------------+ <- sp_{new}, ix_{new}
	|		|
	|		|
	~		~
	|		|
	|		|
	+---------------+
	|    ix_{old}	|
	+---------------+
	|    sp_{old}	|
	+---------------+ <- sp_{old}
	| return address|
	+---------------+

(*6) エピローグ

	以下は 64 バイトのローカル領域を使用する函数のエピローグ

	ld	hl, 0
	add	hl, sp
	ld	a, l
	add	a, 64
	ld	l, a
	ld	sp, hl
	pop	ix
	pop	hl
	ld	sp, hl
	ret

	ix, sp が復元され呼び出し元に復帰する.

(*7) 通常の引数を取る函数の呼び出し

	sizeof(int) = 1

	スタックに積む.
	戻り値 : a レジスタ

(*8) long, long long を引数に取る函数よ呼び出し, 返す函数の呼び出し.
