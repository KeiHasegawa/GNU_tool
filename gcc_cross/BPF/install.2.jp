2022.07.08 8:17 この時点の最新バージョンでもう一度トライ

(*1) binutils-2.38 のインストール

% setenv SHELL /bin/sh
% xz -d -c ../binutils-2.38.tar.xz | tar xf -
% mv binutils-2.38 binutils-2.38.bpf
% cd binutils-2.38.bpf
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/ --target=bpf
% make
% make install
% cd ..

(*2) gcc-12.1.0 のインストール
% xz -d -c ../gcc-12.1.0.tar.xz  | tar xf -
% mv gcc-12.1.0 gcc-12.1.0.bpf
% cd gcc-12.1.0.bpf
% sed -e 's/host_subdir = @host_subdir@/host_subdir = host-i686-pc-linux-gnu/' libgcc/Makefile.in > libgcc/Makefile.in.new
% mv libgcc/Makefile.in.new libgcc/Makefile.in
./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/ --target=bpf
% make all-gcc
% make all-target-libgcc
...
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-12.1.0.bpf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-12.1.0.bpf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/bpf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/bpf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/bpf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/bpf/sys-include    -g -O2 -O2  -g -O2 -DIN_GCC  -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wno-narrowing -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition  -isystem ./include   -g -DIN_LIBGCC2 -fbuilding-libgcc -fno-stack-protector -Dinhibit_libc  -I. -I. -I../../host-i686-pc-linux-gnu/gcc -I../.././libgcc -I../.././libgcc/. -I../.././libgcc/../gcc -I../.././libgcc/../include  -DHAVE_CC_TLS -DUSE_EMUTLS  -o _gcov_info_to_gcda.o -MT _gcov_info_to_gcda.o -MD -MP -MF _gcov_info_to_gcda.dep -DL_gcov_info_to_gcda -c ../.././libgcc/libgcov-driver.c
../.././libgcc/libgcov-driver.c: 関数 ‘write_topn_counters’ 内:
../.././libgcc/libgcov-driver.c:418:1: エラー: too many function arguments for eBPF
...

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-12.1.0.bpf/libgcc/libgcov-driver.c

を修正してコンパイルエラーを回避:

#if 0
static void
write_topn_counters (const struct gcov_ctr_info *ci_ptr,
...
}
#endif
...
	  if (t_ix == GCOV_COUNTER_V_TOPN || t_ix == GCOV_COUNTER_V_INDIR) {
#if 0	    
	    write_topn_counters (ci_ptr, t_ix, n_counts, dump_fn, allocate_fn,
				 arg);
#else
	    (void)allocate_fn; abort();
#endif	    
	  }
...
#if 0  
  (*filename_fn) (gi_ptr->filename, arg);
#else
  (void)filename_fn; abort();
#endif  
  write_one_data (gi_ptr, NULL, dump_fn, allocate_fn, arg);
...
% make all-target-libgcc
% make install-gcc
% make install-target-libgcc
% cd ..

(*3) gdb-12.1 のインストール
% xz -d -c ../gdb-12.1.tar.xz | tar xf -
% mv gdb-10.2 gdb-12.1.bpf
% cd gdb-10.2 gdb-12.1.bpf
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/ --target=bpf
% make all
% make install

(*4) 動作確認
前回確認したときは nop がアセンブルで通っていたが今回は更新されてアセンブルでエラーになっている.
以下のプログラムを 0x100 番地に配置した:

	.text
start:
	mov	%r1, 1
	mov	%r1, 2
	mov	%r1, 3
end:
	mov	%r1, 4
	
これをアセンブル, リンクし bpf-elf-gdb で実行したところプログラムをロードする直前に
メモリを割り当てる例のパッチを適用すれば期待通り動作する.

さらに main 函数を呼び出し, そこから加算の結果を返す f を呼び出すプログラムを作成したが
スタートアップルーチンで

start:
	mov	%r9, stack
	mov	%fp, stack
	call	main              ★
end:
	mov	%r0, %r0

に対して

	call	9

のようなオブジェクトコードが生成されている. ここで main のアドレスは 0x160.
また上の call 命令をシミュレータで実行してみたがプログラムの制御が 9 番地や
0x160 番地には移ることはなく nop の動作になっている. これは前回のリリースと
残念ながら同じ状況.


