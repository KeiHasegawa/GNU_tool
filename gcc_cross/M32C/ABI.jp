M32C の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long, long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*1) 函数呼び出し

	jsr.a	func

	疑似コード

	sp -= 3
	memory[sp] = (jsr 命令の次のアドレス(24 ビット))
	pc = func

(*2) 函数復帰

	rts

	疑似コード

	pc = memory[sp] (24 ビット)
	sp += 3
	
(*3) プロローグ


	enter	#128

	上は 128 バイトのローカルエリアを使用する函数のプロローグである.

	+----------------------+ <- sp_{new}
	|                      |
	|                      |
	|      local area      |
	|                      |
	|                      |
	+----------------------+ +128 <- fb_{new}
	|        fb_{old}      |
	+----------------------+ +130 <- sp_[old}
	|    return address    |
	+----------------------+ +133
	

(*4) エピローグ

        exitd

	上は使用するローカルエリアのバイト数に依存しない函数のエピローグである.
	fb, sp が復元され呼び出し元に復帰する.
	

(*5) 通常の函数の引数と戻り値

        sizeof(int) = 2

        第 1 引数 : r1
	第 2 引数 : r2
	第 3 引数以降 : スタックに積む.

	int f(int a0, int a1, int a2, int a3);
	
	f(10,11,12,13);

	に対して f の先頭アドレスでは

	r1 = 10, r2 = 11

	+----------------------+ <- sp
	|    return address    |
	+----------------------+ +3
	|          12          |
	+----------------------+ +5
	|          13          |
	+----------------------+ +7

        のようになっている.
	函数の戻り値は r0 にセットされる.

(*6) long, long long を引数にとる函数, 返す函数

        sizeof(long) = 4
	sizeof(long long) = 8

	long 型, long long 型の引数に対してはレジスタは使用せず, スタックで渡す.
	long 型, long long 型の戻り値はメモリの特定のアドレスに値がセットされる.

	long 型 : mem0, mem2
	long long 型 : mem0, mem2, mem4, mem6


(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

        M32C には FPU がないのでソフトウェアで浮動少数点数演算を行なう.
	通常通りのインストール方法では libgcc.a に浮動少数点演算ライブラリが
	含まれていないようである.

	float には long と同じ規則が, double, long double には long long と
	同じ規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すとき, コピーが作成され, コピーのアドレスが
	(*5) の規則に従って函数に渡される.

	構造体を返す函数を呼び出すとき, 戻り値を格納するアドレスをスタックに積む.
	r0 をこのためには使用しない.

	例えば

	struct S { int a; int b; };
	struct S f(struct S x, struct S y, struct S z);
	f((struct S){1, 2}, (struct S){3, 4}, (struct S){5, 6});

	に対して f の先頭アドレスでは以下のようになっている:

	+----------------------+ <- sp
	|    return address    |
	+----------------------+ +3
	| 戻り値を格納するアドレス  |
	+----------------------+ +5
	|          1           |
	+----------------------+ +7
	|          2           |
	+----------------------+ +9
	|          3           |
	+----------------------+ +11
	|          4           |
	+----------------------+ +13
	|          5           |
	+----------------------+ +15
	|          6           |
	+----------------------+ +17

	レジスタは使用されない.
