*** gdb-10.2.org/gdb/microblaze-tdep.c	2021-04-25 13:06:26.000000000 +0900
--- gdb-10.2.microblaze-elf/gdb/microblaze-tdep.c	2022-01-03 17:32:21.000000000 +0900
***************
*** 38,43 ****
--- 38,44 ----
  #include "opcodes/microblaze-dis.h"
  #include "microblaze-tdep.h"
  #include "remote.h"
+ #include "gdbcore.h"
  
  #include "features/microblaze-with-stack-protect.c"
  #include "features/microblaze.c"
***************
*** 588,593 ****
--- 589,605 ----
  			 struct type *type, struct regcache *regcache,
  			 gdb_byte *readbuf, const gdb_byte *writebuf)
  {
+   auto code = type->code();
+   switch (code) {
+   case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
+     if (readbuf) {
+       ULONGEST addr;
+       regcache_raw_read_unsigned(regcache, MICROBLAZE_RETVAL_REGNUM, &addr);
+       read_memory(addr, readbuf, TYPE_LENGTH(type));
+     }
+     return RETURN_VALUE_ABI_RETURNS_ADDRESS;
+   }
+   
    if (readbuf)
      microblaze_extract_return_value (type, regcache, readbuf);
    if (writebuf)
***************
*** 646,651 ****
--- 658,808 ----
                                    tdesc_microblaze_with_stack_protect);
  }
  
+ #include <cassert>
+ #include "objfiles.h"
+ 
+ static CORE_ADDR
+ microblaze_push_dummy_code(gdbarch* arch, CORE_ADDR sp, CORE_ADDR funaddr,
+ 			   value **args, int nargs, type* value_type,
+ 			   CORE_ADDR* real_pc, CORE_ADDR* bp_addr,
+ 			   regcache* rc)
+ {
+   *real_pc = funaddr;
+   *bp_addr = entry_point_address() + 8;
+   return sp;
+ }
+ 
+ static bool is_aggregate(type_code code)
+ {
+   switch (code) {
+   case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
+     return true;
+   default:
+     return false;
+   }
+ }
+ 
+ static void calc_sp(int* nth, value* arg, CORE_ADDR* sp)
+ {
+   auto arg_type = check_typedef(value_type(arg));
+   auto code = arg_type->code();
+   int len = TYPE_LENGTH(arg_type);
+ 
+   if (is_aggregate(code)) {
+     int N = (len >> 2) + ((len & 3) ? 1 : 0);
+     *nth += N;
+     *sp -= len;
+     return;
+   }
+ 
+   if (len <= 4) {
+     ++*nth;
+     *sp -= 4;
+     return;
+   }
+ 
+   assert(len == 8);
+   *nth += 2;
+   *sp -= 8;
+ }
+ 
+ static void set_arg(int* nth, value* arg, regcache* rc, CORE_ADDR sp)
+ {
+   auto arg_type = check_typedef(value_type(arg));
+   auto code = arg_type->code();
+   auto val = value_contents(arg);
+   int len = TYPE_LENGTH(arg_type);
+ 
+   if (is_aggregate(code)) {
+     int N = (len >> 2) + ((len & 3) ? 1 : 0);
+     if (*nth + N <= 6) {
+       for (int i = 0 ; i != N ; ++i) {
+ 	auto regval = extract_unsigned_integer(val+4*i, 4, BFD_ENDIAN_BIG);
+ 	regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth+i, regval);
+       }
+       *nth += N;
+       return;
+     }
+     for (int i = 0 ; i != N ; ++i) {
+       if (*nth + i < 6) {
+ 	auto regval = extract_unsigned_integer(val+4*i, 4, BFD_ENDIAN_BIG);
+ 	regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth+i, regval);
+       }
+       else {
+ 	CORE_ADDR addr = sp + 4 + 4 * (*nth + i);
+ 	write_memory(addr, val + 4*i, len - 4*i);
+ 	break;
+       }
+     }
+     *nth += N;
+     return;
+   }
+ 
+   if (len <= 4) {
+     if (*nth < 6) {
+       auto regval = extract_unsigned_integer(val, 4, BFD_ENDIAN_BIG);
+       regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth, regval);
+       ++*nth;
+       return;
+     }
+     CORE_ADDR addr = sp + 4 + 4 * (*nth);
+     write_memory(addr, val, 4);
+     ++*nth;
+     return;
+   }
+ 
+   assert(len == 8);
+   if (*nth + 1 < 6) {
+     auto regval = extract_unsigned_integer(val, 8, BFD_ENDIAN_BIG);
+     uint32_t hi = regval >> 32;
+     regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth+0, hi);
+     uint32_t lo = regval;
+     regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth+1, lo);
+     *nth += 2;
+     return;
+   }
+ 
+   if (*nth == 5) {
+     auto regval = extract_unsigned_integer(val, 8, BFD_ENDIAN_BIG);
+     uint32_t hi = regval >> 32;
+     regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM+*nth+0, hi);
+     CORE_ADDR addr = sp + 4 + 4 * (*nth);
+     write_memory(addr + 4, val + 4, 4);
+     *nth += 2;
+     return;
+   }
+ 
+   CORE_ADDR addr = sp + 4 + 4 * (*nth);
+   write_memory(addr, val, 8);
+   *nth += 2;
+ }
+ 
+ static CORE_ADDR
+ microblaze_push_dummy_call(gdbarch* arch, value* func, regcache* rc,
+ 			   CORE_ADDR bp_addr, int nargs, value** argv,
+ 			   CORE_ADDR sp, function_call_return_method rm,
+ 			   CORE_ADDR struct_addr)
+ {
+   using namespace std;
+   regcache_cooked_write_unsigned(rc, MICROBLAZE_R15_REGNUM, bp_addr - 8);
+   int nth = 0;
+   if (rm == return_method_struct)
+     ++nth;
+   for (int i = 0 ; i != nargs ; ++i)
+     calc_sp(&nth, argv[i], &sp);
+   regcache_cooked_write_unsigned(rc, MICROBLAZE_SP_REGNUM, sp);
+   nth = 0;
+   if (rm == return_method_struct) {
+     regcache_cooked_write_unsigned(rc, MICROBLAZE_R5_REGNUM, struct_addr);
+     ++nth;
+   }
+   for (int i = 0 ; i != nargs ; ++i)
+     set_arg(&nth, argv[i], rc, sp);
+   if (rm == return_method_struct)
+     regcache_cooked_write_unsigned(rc, MICROBLAZE_R3_REGNUM, struct_addr);
+   return sp;
+ }
+ 
  static struct gdbarch *
  microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
  {
***************
*** 717,722 ****
--- 874,881 ----
  
    /* Call dummy code.  */
    set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+   set_gdbarch_push_dummy_code(gdbarch, microblaze_push_dummy_code);
+   set_gdbarch_push_dummy_call(gdbarch, microblaze_push_dummy_call);
  
    set_gdbarch_return_value (gdbarch, microblaze_return_value);
    set_gdbarch_stabs_argument_has_addr
