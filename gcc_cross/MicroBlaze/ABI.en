Microblaze ABI

(*1) Function call
(*2) Return from function
(*3) Prologue
(*4) Epilogue
(*5) Normal argument and return value
(*6) `long long' argument and return value
(*7) Floating point number argument and return value
(*8) Structure argument and return value


(*1) Function call

      	brlid	r15, main

	Pseudo code

	r15 = (`brlid' instruction next address)
	pc = main

	`brlid' is a delayed branch instruction.

(*2) Return from function

	rtsd	r15,8 

	Pseudo cdoe

	pc = r15 + 8

	`rtsd' is a delayed branch instruction.

(*3) Prologue

	addik	r1,r1,-136
	swi	r15,r1,0
	swi	r19,r1,132
	addk	r19,r1,r0

	+------------------+ <- r1_{new}, r19_{new}
	|     r15_{old}    |
	+------------------+
	|                  |
	|                  |
	|    local area    |
	|                  |
	|                  |
	+------------------+
	|     r19_{old}    |
	+------------------+ <- r1_{old}

	Above is prologue for function which uses 128 bytes local area.

(*4) Epilogue

	lwi	r15,r1,0
	addk	r1,r19,r0
	lwi	r19,r1,132
	addik	r1,r1,136
	rtsd	r15,8 
	nop

	Above is epilogue for function which uses 128 bytes local area.
	`r15', `r19' and `r1' are restored and return to callee.

(*5) Normal argument and return value

        1st : r5
        2nd : r6
        3rd : r7
        4th : r8
	5th : r9
	6th : r10
	7th : use stack with offset 28

	For exmaple,

	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7);

	f(10, 11, 12, 13, 14, 15, 16, 17);

	At the start address of `f', registers and stack layout become
	like below:

	r5 = 10, r6 = 11, r7 = 12, r8 = 13, r9 = 14, r10 = 15


	+------------------+ <- r1
	|     r15_{old}    |
	+------------------+ +4
	|      ******      |
	+------------------+ +8
	|      ******      |
	+------------------+ +12
	|      ******      |
	+------------------+ +16
	|      ******      |
	+------------------+ +20
	|      ******      |
	+------------------+ +24
	|      ******      |
	+------------------+ +28
	|        16        |
	+------------------+ +32
	|        17        |
	+------------------+ +36

	where, r15_{old} is return address of the function which challs `f'.
	Function return value is set to `r3'.

(*6) `long long' argument and return value

        For `long long' type argument, 2 registers is used.
	For `long long' type return value, `r3' and `r4' is used .

	For example,

	long long f(int a0, long long a1, long long a2, long long a3)

	f(10, 11LL, 12LL, 0x123456789abcdef0LL);

	At the start address of `f', registers and stack layout become
	like below:

	r5 = 10, r6 = 0, r7 = 11, r8 = 0, r9 = 12, r10 = 0x12345678 

	+------------------+ <- r1
	|     r15_{old}    |
	+------------------+ +4
	|      ******      |
	+------------------+ +8
	|      ******      |
	+------------------+ +12
	|      ******      |
	+------------------+ +16
	|      ******      |
	+------------------+ +20
	|      ******      |
	+------------------+ +24
	|      ******      |
	+------------------+ +28
	|    0x9abcdef0    |
	+------------------+ +32

	where, r15_{old} is return address of the function which challs `f'.

(*7) Floating point number argument and return value

	sizeof(float) = 4
	sizoef(double) = sizeof(long double) = 8

	Microblaze doesn't have FPU so software calculates floating point
	number operation. For `float' same with (*5). For `double' or
	`long dobule' same with (*6).

(*8) Structure argument and return value

	When calling function which takes structure type argument, first
	24 bytes are set to `r5', ..., `r10' and the rest is set to stack.
	When calling function which returns structure type, the address
	of the return value is set to `r3'.
