(*0) Registers and its alias

     General Purpose Registers : r0, ..., r63

     r11 : fp
     r12 : ip (not program counter, specify jalr instruction especially)
     r13 : sp
     r14 : lr

(*1) Functin call

	mov	r12, %low(_func)
	movt	r12, %high(_func)
	jalr	r12

     where, programmer can chose general purpose register. It's not necessary
     to chose r12.

        Pseudo code

        lr := (Next instruction address of `jalr')
	pc := _func

(*2) Return from function

	rts

        Pseudo code

	pc := lr

(*3) Function prologue

	str fp,[sp],#-2    ; [sp] := fp, sp := sp-8
	str lr,[sp,#3]     ; [sp+12] := lr
	mov fp,sp          ; fp := sp

	Above is function prologue which uses 0 bytes local area generated
	by original `cc1'

	+---------------+ <- sp_{new}, fp_{new}
	|		|
     +4	+---------------+
	|		|
     +8	+---------------+ <- sp_{old}
	|  fp_{old}	|
    +12 +---------------+
	|  lr_{old}	|
	+---------------+

	I wonder that original `cc1' uses stack which is out of range because
	of implementator mistake. But the program generated by original `cc1'
	works well anyway.

(*4) Function epilogue

	mov sp,fp
	ldr lr,[sp,#3]     ; lr := [sp+12]
	ldr fp,[sp,#2]     ; fp := [sp+8]
	add sp,sp,#8       ; sp := sp + 8
	rts

	Above is function epilogue which uses 0 bytes local area generated
	by original `cc1'.
	