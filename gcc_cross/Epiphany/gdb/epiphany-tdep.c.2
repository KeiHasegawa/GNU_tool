#include "defs.h"
#include "value.h"
#include "arch-utils.h"
#include "regcache.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "dis-asm.h"
#include "dwarf2/frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include <cassert>

static int epiphany_register_sim_regno(gdbarch*, int regnum)
{
  return regnum;
}

static int
epiphany_dbg_reg_to_regnum(gdbarch*, int regnum)
{
  return regnum;
}

const int pc_regno = 64;
const int sp_regno = 13;

static const char* reg_names[] = {
  "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
  "r8",  "r9",  "r10", "fp",  "ip",  "sp",  "lr",  "r15",
  "r16",  "r17","r18", "r19", "r20", "r21", "r22", "r23",
  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
  "r32", "r33", "r34", "r35", "r36", "r37", "r38", "r39",
  "r40", "r41", "r42", "r43", "r44", "r45", "r46", "r47",
  "r48", "r49", "r50", "r51", "r52", "r53", "r54", "r55",
  "r56", "r57", "r58", "r59", "r60", "r61", "r62", "r63",
  "pc", "status"
};

static const char* epiphany_register_name(gdbarch*, int regno)
{
  assert(regno >= 0);
  if (regno < sizeof reg_names/sizeof reg_names[0])
    return reg_names[regno];
  return nullptr;
}

static void
epiphany_extract_return_value(type* valtype, regcache* regs, gdb_byte *valbuf)
{
  int len = TYPE_LENGTH(valtype);
  for (int regno = 0 ; len > 0 ; len -= 4, ++regno, valbuf += 4) {
    ULONGEST tmp;
    regcache_cooked_read_unsigned(regs, regno, &tmp);
    store_unsigned_integer(valbuf, 4, BFD_ENDIAN_LITTLE, tmp);
  }
}

static bool is_aggregate(type_code code)
{
  switch (code) {
  case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
    return true;
  default:
    return false;
  }
}

static return_value_convention
epiphany_return_value(gdbarch*, value* function, type* valtype, regcache* rc,
		      gdb_byte* readbuf, const gdb_byte* writebuf)
{
  auto code = valtype->code();
  if (is_aggregate(code)) {
    int len = TYPE_LENGTH(valtype);
    if (len > 8) {
      if (readbuf) {
	ULONGEST r0;
	regcache_raw_read_unsigned(rc, 0, &r0);
	read_memory(r0, readbuf, len);
      }
      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }
  }

  assert(!writebuf);

  if (readbuf)
    epiphany_extract_return_value(valtype, rc, readbuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}

static type* epiphany_register_type(gdbarch* arch, int regno)
{
  switch (regno) {
  case pc_regno: case 12: case 14:
    return builtin_type (arch)->builtin_func_ptr;
  case sp_regno: case 11:
    return builtin_type (arch)->builtin_data_ptr;
  default:
    return builtin_type(arch)->builtin_int32;
  }
}

static void
epiphany_print_registers_info(gdbarch*, ui_file* file,
			      frame_info* frame, int regno, int cpregs)
{
  asm("int3");
}

static CORE_ADDR epiphany_skip_prologue(gdbarch*, CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  if (!find_pc_partial_function (pc, nullptr, &func_addr, &func_end))
    return pc;
  
  symtab_and_line sal = find_pc_line (func_addr, 0);
  if (sal.end && sal.end < func_end)
    return sal.end;

  return pc;
}

static struct frame_base epiphany_frame_base = {
};

static void
epiphany_frame_this_id(frame_info* frame, void** ptr, frame_id* id)
{
}

static value* epiphany_frame_prev_register(frame_info* frame, void** ptr,
					   int regnum)
{
  asm("int3");
  return 0;
}

static frame_unwind epiphany_frame_unwind = {
  "epiphany proloue",
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  epiphany_frame_this_id,
  epiphany_frame_prev_register,
  nullptr,
  default_frame_sniffer
};

static int epiphany_kind_from_pc(gdbarch*, CORE_ADDR*)
{
  return 0;
}

static const unsigned char* epiphany_from_kind(gdbarch*, int, int* size)
{
  static unsigned char bkpt[] = { 0xbb, 0xba };
  *size = sizeof bkpt;
  return &bkpt[0];
}

static CORE_ADDR
epiphany_push_dummy_call(gdbarch*, value* function, regcache* rc,
			 CORE_ADDR bp_addr, int nargs, value** args,
			 CORE_ADDR sp, function_call_return_method rm,
			 CORE_ADDR struct_addr)
{
  asm("int3");
  return 0;
}

static gdbarch*
epiphany_gdbarch_init(gdbarch_info info, gdbarch_list* arches)
{
  gdbarch* arch = gdbarch_alloc(&info, 0);

  set_gdbarch_num_regs(arch, sizeof reg_names/sizeof reg_names[0]);
  set_gdbarch_register_type(arch, epiphany_register_type);
  set_gdbarch_register_sim_regno(arch, epiphany_register_sim_regno);
  set_gdbarch_dwarf2_reg_to_regnum(arch, epiphany_dbg_reg_to_regnum);
  set_gdbarch_stab_reg_to_regnum(arch, epiphany_dbg_reg_to_regnum);
  set_gdbarch_register_name(arch, epiphany_register_name);

  set_gdbarch_pc_regnum(arch, pc_regno);
  set_gdbarch_sp_regnum(arch, sp_regno);
  set_gdbarch_print_registers_info(arch, epiphany_print_registers_info);

  set_gdbarch_ptr_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_addr_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_return_value(arch, epiphany_return_value);

  set_gdbarch_skip_prologue (arch, epiphany_skip_prologue);
  frame_base_set_default (arch, &epiphany_frame_base);
  dwarf2_append_unwinders(arch);
  frame_unwind_append_unwinder(arch, &epiphany_frame_unwind);

  set_gdbarch_inner_than (arch, core_addr_lessthan);
  set_gdbarch_breakpoint_kind_from_pc(arch, epiphany_kind_from_pc);
  set_gdbarch_sw_breakpoint_from_kind(arch, epiphany_from_kind);
  set_gdbarch_push_dummy_call(arch, epiphany_push_dummy_call);

  set_gdbarch_char_signed(arch, 0);
  set_gdbarch_int_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (arch, 8 * TARGET_CHAR_BIT);

  set_gdbarch_wchar_signed(arch, 0);
  set_gdbarch_wchar_bit(arch, 2 * TARGET_CHAR_BIT);

  set_gdbarch_double_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_double_format(arch, floatformats_ieee_double);
  set_gdbarch_long_double_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_format(arch, floatformats_ieee_double);

  set_gdbarch_believe_pcc_promotion(arch, 1);
 
  return arch;
}

void _initialize_epiphany_tdep();
void
_initialize_epiphany_tdep ()
{
  register_gdbarch_init(bfd_arch_epiphany, epiphany_gdbarch_init);
}

