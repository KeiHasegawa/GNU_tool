M32R の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数


(*1) 函数呼び出し

	bl func

	疑似コード
	
	lr = (bl 命令の次のアドレス)
	pc = func

	lr は r14 の別名.

(*2) 函数復帰

	jmp lr

	疑似コード
	
	pc = lr

(*3) プロローグ

	push fp
	push lr
	addi sp,#-128
	mv fp,sp

	上は 128 バイトのローカルエリアを使用する函数のプロローグ.
	sp は r15 の別名.

	+----------------+ <- sp_{new}, fp_{new}
        |                |
        |                |
        |   local area   |
        |                |
        |                |
	+----------------+
        |    lr_{old}    |
	+----------------+
        |    fp_{old}    |
	+----------------+ <- sp_{old}

(*4) エピローグ

	addi sp,#128
	pop lr
	pop fp
	jmp lr

	上は 128 バイトのローカルエリアを使用する函数のエピローグ.

(*5) 通常の函数の引数と戻り値

        第 1 引数 : r0
        第 2 引数 : r1
        第 3 引数 : r2
        第 4 引数 : r3
        第 5 引数以降 : スタックに積む

	函数の戻り値は r0 を使用する.

(*6) long long を引数にとる函数, 返す函数

	sizeof(long long) = 8

	long long の引数に対してレジスタが 2 つ使用される.
	例えば

	long long f(int a, long long b, long long c);

	f(10, 0x123456789abcdef0LL, 0x1122334455667788LL);

	に対して f の先頭アドレスでは

	r0 = 10
	r1 = 0x12345678, r2 = 0x9abcdef0
	r3 = 0x11223344

	+----------------+ <- sp
        |   0x55667788   |
	+----------------+

	のようになっている.

(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

	M32R には FPU がないので浮動少数点数演算はソフトウェアで行なう.

	float に対しては (*5) の規則が, double, long double に対しては (*6)
	の規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

	構造体を引数とする函数を呼び出すとき, レジスタは使用せずスタックにコピーして呼び出す.
	構造体を返す函数を呼び出すとき, r0 レジスタに戻り値を格納する領域のアドレスをセット
	して呼び出す.
	