Investigation about ft32-elf-gdb could not get line information even though
I applied WA to ft32-elf-as.

(*1) Investigation : Before applying WA to ft32-elf-as, for `b end'
ft32-elf-gdb made an corresponding to test000.S:1.

b start
b end

create_breakpoint

For `b start', ft32-elf-gdb just made an corresponding to address 0x100
For `b end', ft32-elf-gdb made an corresponding to test.S:1 and it was not
correct.

The corresponding was made at below:

  if (!internal)
    mention (b);


By calling mention(b), corresponding was displayed. So I guessed that `b'
contained the result of correspondig.

b start

For above command, just displayed like below:

Breakpoint 1 at 0x100

On the other hand,

b end

For above command, displayed like below:

Breakpoint 2 at 0x10c: file test000.S, line 1.

b start

For above command,

(gdb) p b->loc->line_number
0

b end

For above command,

(gdb) p b->loc->line_number
1

where, 1 was set at below code:

  loc->line_number = sal->line;


where, `sal' expresses `Sytab And Line'

  add_location_to_breakpoint (b, &sal);

I see. Above code could be understood.

For command `b start' and `b end', `add_location_to_breakpoint' was called
from below code:

      if (&sal == &sals[0])
	{
	  init_raw_breakpoint (b, gdbarch, sal, type, ops);

And more,

For `b start', sal.line = 0 sal.pc = 0x100
For `b end',   sal.line = 1 sal.pc = 0x10c

This `sal' was calculated at below code:

static void
create_breakpoints_sal (struct gdbarch *gdbarch,
			struct linespec_result *canonical,
...
{
...
  for (const auto &lsal : canonical->lsals)
    {
...
      create_breakpoint_sal (gdbarch, lsal.sals,
                                      ^^^^^^^^^

According to above code, at the timing when `create_breakpoints_sal' was
called, it had been possible that `lsal.sals' was already calculated.

For debugging, I added the function named `debug' and when
`create_breakpoints_sal' was called, I called it from gdb command line
like below:

(gdb) p debug(canonical)
pc = 0x100 line = 0
(gdb) c
(gdb) p debug(canonical)
pc = 0x10c line = 1
(gdb)

Already calculated.


breakpoint.c:9376
      ops->create_breakpoints_sal (gdbarch, &canonical,
				   std::move (cond_string_copy),
				   std::move (extra_string_copy),
				   type_wanted,


(gdb) delete
(gdb) b 9376
(gdb) run
(gdb) p debug(&canonical)
pc = 0x100 line = 0
(gdb) c
(gdb) p debug(&canonical)
pc = 0x10c line = 1
(gdb)

At above point, it has been already calculated. I examined how `canonical'
was calculated:

(gdb) delete
(gdb) b create_breakpoint

      ops->create_sals_from_location (location, &canonical, type_wanted);

That was, above code. According the function name, it was possible that
`location' had been already calculated. Anyway I examined above.

Then I confirmed that `canonical' was calculated at below code:

  decode_line_full (location, DECODE_LINE_FUNFIRSTLINE, NULL,
		    cursal.symtab, cursal.line, canonical, NULL, NULL);

(gdb) delete
(gdb) b decode_line_full



  std::vector<symtab_and_line> result = event_location_to_sals (&parser,
								location);

At above point,
(gdb) p debug(result)
pc = 0x100 line = 0
$27 = void
(gdb)

it was calculated so that `canonical' was updated. Then I guessed that
`location' had been already calculated.

(gdb) delete
(gdb) b event_location_to_sals


	    result = parse_linespec (parser,
				     ls->spec_string, ls->match_type);


At above point, `result' was set.

(gdb) delete
(gdb) b parse_linespec

Here, I noticed that string literal "start" was passed to this function
`parse_linespec'. I guessed that address of `start' was not still calculated.

(gdb) delete
(gdb) b convert_linespec_to_sals

	      minsym_found (state, elem.objfile, elem.minsym, &sals);

I confirmed that `canonical' was calculated at above code.

(gdb) delete
(gdb) b minsym_found

(gdb) delete
(gdb) b find_function_start_sal

(gdb) delete
(gdb) b find_pc_sect_line

This function `find_pc_sect_line' was called few times for command:

b start

But for command

b end

it was just called one time.


      val.is_stmt = best->is_stmt;
      val.symtab = best_symtab;
      val.line = best->line;
      val.pc = best->pc;

At above code, `best' was found so that line information was added correctly.

For `b start' command, `best' was not found.


      if (prev && prev->line && (!best || prev->pc > best->pc))
	{
	  best = prev;
	  best_symtab = iter_s;

Above condition was satisfied so that `best' was found. For satisfying this
condition, it's ncessary that `prev' is non-zero. But


      if (item != first)
	prev = item - 1;		/* Found a matching item.  */

for `b end' command, `prev' was set at above code. More precisely:

      auto pc_compare = [](const CORE_ADDR & comp_pc,
			   const struct linetable_entry & lhs)->bool
      {
	return comp_pc < lhs.pc;
      };

      struct linetable_entry *first = item;
      struct linetable_entry *last = item + len;
      item = std::upper_bound (first, last, pc, pc_compare);
      if (item != first)
	prev = item - 1;		/* Found a matching item.  */

len was 4.


(gdb) p/x *(first+0)
$61 = {line = 0x1, is_stmt = 0x1, pc = 0x104}
(gdb) p/x *(first+1)
$62 = {line = 0x2, is_stmt = 0x1, pc = 0x20c}
(gdb) p/x *(first+2)
$63 = {line = 0x4, is_stmt = 0x1, pc = 0x318}
(gdb) p/x *(first+3)
$64 = {line = 0x0, is_stmt = 0x1, pc = 0x428}
(gdb)

Above implies that `best' is not found for 0x100 but found for 0x104.

I did the same thign for `test000.elf.correct':

len was 2 and

(gdb) p/x *(first+0)
$73 = {line = 0x3, is_stmt = 0x1, pc = 0x4}
(gdb) p/x *(first+1)
$74 = {line = 0x0, is_stmt = 0x1, pc = 0x8}
(gdb)

I modified from gdb command line like below:

(gdb) set (first+0)->pc=0x100
(gdb) set (first+1)->pc=0x104

For `b start' command, the break-point corresponds to test000.S:3.

And more, I did the same thing for h8300-elf-gdb, which of cause work well:

(gdb) p len
$2 = 5
(gdb) p/x *(first+0)
$3 = {line = 0x3, is_stmt = 0x1, pc = 0x100}
(gdb) p/x *(first+1)
$4 = {line = 0x4, is_stmt = 0x1, pc = 0x102}
(gdb) p/x *(first+2)
$5 = {line = 0x5, is_stmt = 0x1, pc = 0x104}
(gdb) p/x *(first+3)
$6 = {line = 0x7, is_stmt = 0x1, pc = 0x106}
(gdb) p/x *(first+4)
$7 = {line = 0x0, is_stmt = 0x1, pc = 0x108}
(gdb)

1		.text
2	start:
3		nop
4		nop
5		nop
6	end:
7		nop

H8 nop instruction is 2 byte, so that the difference about address
is caused but the expect value of `len' is 5.
In case of FT32, `pc' member expected values should be:

0x100, 0x104, 0x108, 0x10c and 0x110 


「gas の調査」でライン情報の生成のしかたに 2 パターンあることを調査していたが
h8300-elf-as は ppc と同じ方式.

一方 rl78 はオリジナルの ft32-elf-as と同じ方式を採用している. rl78-elf-gdb
でも同様のことを試してみたところやはり len = 5 で

(gdb) p/x *(first+0)
$2 = {line = 0x3, is_stmt = 0x1, pc = 0x100}
(gdb) p/x *(first+1)
$3 = {line = 0x4, is_stmt = 0x1, pc = 0x101}
(gdb) p/x *(first+2)
$4 = {line = 0x5, is_stmt = 0x1, pc = 0x102}
(gdb) p/x *(first+3)
$5 = {line = 0x7, is_stmt = 0x1, pc = 0x103}
(gdb) p/x *(first+4)
$6 = {line = 0x0, is_stmt = 0x1, pc = 0x104}
(gdb)

RL78 の場合 nop が 1 バイトだからアドレスの違いはあるが, 期待したものになっている.
つまり ft32-elf-*** で期待した動作にならない直接の原因は ft32-elf-gdb で

(gdb) p len
$2 = 5
(gdb) p/x *(first+0)
$3 = {line = 0x3, is_stmt = 0x1, pc = 0x100}
(gdb) p/x *(first+1)
$4 = {line = 0x4, is_stmt = 0x1, pc = 0x104}
(gdb) p/x *(first+2)
$5 = {line = 0x5, is_stmt = 0x1, pc = 0x108}
(gdb) p/x *(first+3)
$6 = {line = 0x7, is_stmt = 0x1, pc = 0x10c}
(gdb) p/x *(first+4)
$7 = {line = 0x0, is_stmt = 0x1, pc = 0x110}
(gdb)

になっていないこと. そしてその原因が ft32-elf-gdb, ft32-elf-ld , ft32-elf-as
のいずれかにある.

オリジナルの ft32-elf-as で生成した test000.elf を試すと

(gdb) p len
$96 = 4
(gdb) p/x *(first+0)
$97 = {line = 0x1, is_stmt = 0x1, pc = 0x104}
(gdb) p/x *(first+1)
$98 = {line = 0x2, is_stmt = 0x1, pc = 0x20c}
(gdb) p/x *(first+2)
$99 = {line = 0x4, is_stmt = 0x1, pc = 0x318}
(gdb) p/x *(first+3)
$100 = {line = 0x0, is_stmt = 0x1, pc = 0x428}
(gdb) 

である.

そこでもう一度

DWARF2_USE_FIXED_ADVANCE_PC
DWARF2_LINE_MIN_INSN_LENGTH

を define することなしで修正する方法を考えてみる. 勿論 define して修正する方法が分かるの
ならばそれでもよい.

いずれにしても ft32-elf-as をもう一度見直す.


