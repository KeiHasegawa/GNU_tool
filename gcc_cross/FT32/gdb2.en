I fixed ft32-elf-as but ft32-elf-gdb didn't work for:

b start
b end

Above 2 break-points were not corresponding to source file.

At already examined function `find_pc_sect_line'

(gdb) p len
$1 = 4
(gdb) p/x *(first+0)
$3 = {line = 0x1, is_stmt = 0x1, pc = 0x4}
(gdb) p/x *(first+1)
$4 = {line = 0x2, is_stmt = 0x1, pc = 0x8}
(gdb) p/x *(first+2)
$5 = {line = 0x4, is_stmt = 0x1, pc = 0xc}
(gdb) p/x *(first+3)
$6 = {line = 0x0, is_stmt = 0x1, pc = 0x10}
(gdb)

`len'  expected value is 5 and

*(first+0) = {line = 0x3, is_stmt = 0x1, pc = 0x100}

is expected. Line information was wrong as a view point of ft32-elf-gdb.

On the other hand, the output of ft32-elf-objdump and ft32-elf-addr2line were what I expected.
So I thought I should have examined the reason why ft32-elf-gdb became this situation.

(gdb) p &iter_s->linetable->nitems
$19 = (int *) 0x8dbc258
(gdb) watch *(int *) 0x8dbc258
Hardware watchpoint 2: *(int *) 0x8dbc258
(gdb)

Set watch-point like above. And it hit at below code:

          memcpy (SYMTAB_LINETABLE (symtab), subfile->line_vector,
                  linetablesize);

This means that it is copied from `subfile->line_vector'. So we have to examine the timing when `subfile->line_vector' is set.

I did the same thing with rl78-elf-gdb and confirmed that it was copied in the same way.

(gdb) p subfile->line_vector->nitems
$22 = 4
(gdb) p &subfile->line_vector->nitems
$23 = (int *) 0x8de1ea0
(gdb) watch *(int*)0x8de1ea0
Hardware watchpoint 3: *(int*)0x8de1ea0
(gdb)

Set watch-point like above and it hit at:

buildsym_compunit::record_line

I confirmed that this function set `subfile->line_vector'. When this function was called,

line, is_stmt, pc

were already calculated, so l should have confirmed how they were calculated. And that was:

lnp_state_machine::record_line

(gdb) b lnp_state_machine::lnp_state_machine

When this break-point hit, m_line = 1. Then l modified like below:

(gdb) set m_line=0

I also confirmed `m_line' was not changed and

lnp_state_machine::record_line

was called.

l did the same thing with rl78-elf-gdb. After the constructor was called, `m_line' was set at below member function:


  void handle_set_address (CORE_ADDR baseaddr, CORE_ADDR address)
  {

And this was called from:

                case DW_LNE_set_address:
                  {
                    CORE_ADDR address
                      = cu->header.read_address (abfd, line_ptr, &bytes_read);
                    line_ptr += bytes_read;

                    state_machine.check_line_address (cu, line_ptr,
                                                      lowpc - baseaddr, address);
                    state_machine.handle_set_address (baseaddr, address);


That is, DW_LINE_set_address = 2 was missed at

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_ft32.000/a.elf

On the other hand, at

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_rl78.000/a.elf

DW_LINE_set_address = 2 existed so that `m_line' was set.

That is, DW_LINE_set_address = 2  was missed at object file generated by fixed ft32-elf-as, so that `handle_set_address ' member function was not called. But for object file generated by original ft32-elf-as, even though it was wrong, `handle_set_address ' member function was called.
i.e. the fix was not correct.

The object file generated by fixed ft32-elf-as contains byte data:

0x09 0x04 0x00

are generated for advance PC by 4, and it was realized like:

void f(char* p)
{
  p[0] = 0x09;
  p[1] = 0x04;
  p[2] = 0x00;
}

This caused that the output of ft32-elf-objdump, ft32-elf-addr2line were correct but

DW_LINE_set_address = 2

was missed at the output of ft32-elf-ld and it was wrong.
