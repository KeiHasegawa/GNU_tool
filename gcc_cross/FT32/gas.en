Investigation about ft32-elf-as line information

I re-builded with `-g3 -O0' option

And executed as-new (ft32-elf-as ) under control of gdb like below:

(gdb) run -g a.S
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/as-new -g a.S
[Inferior 1 (process 12805) exited normally]
(gdb) 

% ft32-elf-objdump -g a.out > a

`a' became like below:

 Line Number Statements:
  [0x00000024]  Extended opcode 2: set Address to 0x0
  [0x0000002b]  Special opcode 7: advance Address by 0 to 0x0 and Line by 2 to 3
  [0x0000002c]  Advance Line by 1 to 4
  [0x0000002e]  Advance PC by 4 to 0x4
  [0x00000031]  Coopy (view 1)
  [0x00000032]  Advance Line by 1 to 5
  [0x00000034]  Advance PC by 8 to 0xc
  [0x00000037]  Coy (view 2)
  [0x00000038]  Advance Line by 2 to 7
  [0x0000003a]  Advance PC by 12 to 0x18
  [0x0000003d]  Copy (view 3)
  [0x0000003e]  Advance PC by 16 to 0x28
  [0x00000041]  Extended opcode 1: End of Sequence

Because ft32-elf-as generates `a.out', it may call `write' system call.

  if (BFD_SEND (abfd, _bfd_set_section_contents,
		(abfd, section, location, offset, count)))

Above code was investigated at fixing `iq2000-elf-ld', and `write' system
call was called from above code.

For just ".text" and ".debug_aranges" sections, `write' was called.
Not setting break-point to `write', by setting break-point to above code, 
I confirmed that above code was called for ".debug_line" section: 

(gdb) delete
(gdb) b section.c:1523
(gdb) run

".text"
".debug_line"

OK for ".debug_line", above code was called.

(gdb) x/50bx location
0x8171e38:	0x00	0x00	0x00	0x00	0x03	0x00	0x00	0x00
0x8171e40:	0x00	0x00	0x01	0x01	0xfb	0x0e	0x0d	0x00
0x8171e48:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x8171e50:	0x00	0x00	0x01	0x00	0x61	0x2e	0x53	0x00
0x8171e58:	0x00	0x00	0x00	0x00	0x00	0x05	0x02	0x00
0x8171e60:	0x00	0x00	0x00	0x14	0x03	0x01	0x09	0x00
0x8171e68:	0x00	0x01
(gdb) 

I tried to do the same thing for `ppc-elf-as':

(gdb) x/52bx location
0x820c360:	0x00	0x00	0x00	0x30	0x00	0x03	0x00	0x00
0x820c368:	0x00	0x1a	0x04	0x01	0xfb	0x0e	0x0d	0x00
0x820c370:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x820c378:	0x00	0x00	0x01	0x00	0x61	0x2e	0x53	0x00
0x820c380:	0x00	0x00	0x00	0x00	0x00	0x05	0x02	0x00
0x820c388:	0x00	0x00	0x00	0x14	0x21	0x21	0x22	0x02
0x820c390:	0x01	0x00	0x01	0x01
(gdb)

For the output file of ppc-elf-as, the result ppc-elf-objdump -g became like
below:

 Line Number Statements:
  [0x00000024]  Extended opcode 2: set Address to 0x0
  [0x0000002b]  Special opcode 7: advance Address by 0 to 0x0 and Line by 2 to 3
  [0x0000002c]  Special opcode 20: advance Address by 4 to 0x4 and Line by 1 to 4
  [0x0000002d]  Special opcode 20: advance Address by 4 to 0x8 and Line by 1 to 5
  [0x0000002e]  Special opcode 21: advance Address by 4 to 0xc and Line by 2 to 7
  [0x0000002f]  Advance PC by 4 to 0x10
  [0x00000031]  Extended opcode 1: End of Sequence

I tooke care of `Special opcode 20' (20 = 0x14). Then I investigated the code
which generated this data. 

For ppc-elf-as:

(gdb) p/x *(char*)(0x820c388+3)
$3 = 0x14
(gdb) watch *(char*)(0x820c388+3)
Hardware watchpoint 2: *(char*)(0x820c388+3)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ppc-elf/gas/as-new -g a.S

Hardware watchpoint 2: *(char*)(0x820c388+3)

Old value = <unreadable>
New value = 20 '\024'
emit_inc_line_addr (line_delta=2, addr_delta=0, p=0x820c38c "", len=1) at dwarf2dbg.c:1612
(gdb)

These were correct motion.

I thought `emit_inc_line_addr' was the important function.

On the other hand, I tried the same thing for `ft32-elf-as':

(gdb) p/x *(char*)(0x8171e60+3)
$5 = 0x14
(gdb) watch *(char*)(0x8171e60+3)
Hardware watchpoint 3: *(char*)(0x8171e60+3)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/as-new -g a.S

Hardware watchpoint 3: *(char*)(0x8171e60+3)

Old value = <unreadable>
New value = 20 '\024'
emit_inc_line_addr (line_delta=2, addr_delta=0, p=0x8171e64 "", len=1) at dwarf2dbg.c:1612
(gdb)

As we saw, this function set this data. I guessed that this error occured
at the previous timing but I could not find the code.


I examined the next data of `20'( = 0x14) for ppc-elf-as:

(gdb) watch *(char*)(0x820c388+4)
Hardware watchpoint 3: *(char*)(0x820c388+4)
(gdb) c
Continuing.

Hardware watchpoint 3: *(char*)(0x820c388+4)

Old value = 0 '\000'
New value = 33 '!'
emit_inc_line_addr (line_delta=1, addr_delta=1, p=0x820c38d "", len=1) at dwarf2dbg.c:1612
(gdb) 

The same function `emit_inc_line_addr' set this data.

And for ft32-elf-as:

watch *(char*)(0x8171e60+4)
Hardware watchpoint 4: *(char*)(0x8171e60+4)
(gdb) c
Continuing.

Hardware watchpoint 4: *(char*)(0x8171e60+4)

Old value = 0 '\000'
New value = 3 '\003'
emit_fixed_inc_line_addr (line_delta=1, addr_delta=4, frag=0x8171e00, p=0x8171e65 "", len=6) at dwarf2dbg.c:1702
(gdb)

emit_fixed_inc_line_addr

This function set the next data:

                    20                     33
ppc-elf-as          emit_inc_line_addr     emit_inc_line_addr
                                           3
ft32-elf-as	    emit_inc_line_addr	   emit_fixed_inc_line_addr

Here, I guessed it was not correct that `emit_fixed_inc_line_addr' was
called.

  if (DWARF2_USE_FIXED_ADVANCE_PC)
    emit_fixed_inc_line_addr (frag->fr_offset, addr_diff, frag,
			      frag->fr_literal + frag->fr_fix,
			      frag->fr_subtype);
  else
    emit_inc_line_addr (frag->fr_offset, addr_diff,
			frag->fr_literal + frag->fr_fix, frag->fr_subtype);

OK, I see.

(gdb) p DWARF2_USE_FIXED_ADVANCE_PC
$7 = 1
(gdb) 

This was define at below:

#ifndef DWARF2_USE_FIXED_ADVANCE_PC
# define DWARF2_USE_FIXED_ADVANCE_PC	linkrelax
#endif

It was also the same with ppc-elf-as. I compared the motion:

      else if (frag == last_frag && ! DWARF2_USE_FIXED_ADVANCE_PC)
+	out_inc_line_addr (line_delta, frag_ofs - last_frag_ofs);
      else
-	relax_inc_line_addr (line_delta, lab, last_lab);

ppc-elf-as exected + line.

ft32-elf-as execute - line.

For ppc-elf-as

(gdb) p DWARF2_USE_FIXED_ADVANCE_PC
0
(gdb)

This was caused by the way of compiling.

It was hard to say that it was not correct that `DWARF2_USE_FIXED_ADVANCE_PC'
became 1. But actually, ft32-elf-as did not work well. I tried WA like below:

//# define DWARF2_USE_FIXED_ADVANCE_PC	linkrelax
# define DWARF2_USE_FIXED_ADVANCE_PC	0

Then ft32-elf-as(as-new) generated like below:

 Line Number Statements:
  [0x00000024]  Extended opcode 2: set Address to 0x0
  [0x0000002b]  Special opcode 7: advance Address by 0 to 0x0 and Line by 2 to 3
  [0x0000002c]  Special opcode 62: advance Address by 4 to 0x4 and Line by 1 to 4
  [0x0000002d]  Special opcode 62: advance Address by 4 to 0x8 and Line by 1 to 5
  [0x0000002e]  Special opcode 63: advance Address by 4 to 0xc and Line by 2 to 7
  [0x0000002f]  Advance PC by 4 to 0x10
  [0x00000031]  Extended opcode 1: End of Sequence

Here, `62' was unexpected value. I expected `20'...Anyway

% ft32-elf-addr2line -e test000.elf -a 0x100
0x00000100
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/a.S:3
% ft32-elf-addr2line -e test000.elf -a 0x104
0x00000104
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/a.S:4
% ft32-elf-addr2line -e test000.elf -a 0x108
0x00000108
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/a.S:5
% ft32-elf-addr2line -e test000.elf -a 0x10c
0x0000010c
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ft32-elf/gas/a.S:7
%

These were expected result. But ft32-elf-gdb did not work well. i.e.
ft32-elf-gdb could not get correct line information.

So first, `20' was expected but `62' came there. I investigated the reason.

By applying above WA, I dumped .debug_line section:

(gdb) x/52bx  location
0x8171e38:	0x00	0x00	0x00	0x00	0x03	0x00	0x00	0x00
0x8171e40:	0x00	0x00	0x01	0x01	0xfb	0x0e	0x0d	0x00
0x8171e48:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x8171e50:	0x00	0x00	0x01	0x00	0x61	0x2e	0x53	0x00
0x8171e58:	0x00	0x00	0x00	0x00	0x00	0x05	0x02	0x00
0x8171e60:	0x00	0x00	0x00	0x14	0x4b	0x4b	0x4c	0x02
0x8171e68:	0x04	0x00	0x01	0x01
(gdb)

Then I knew that size of .debug_line section was 50 before applying WA,
and after applying WA, that of .debug_line section became 52, and
it was the same with that of ppc-elf-as.

62 = 0x3e

but I did not found 0x3e

Again, ppc-elf-as dump result was:

(gdb) x/52bx location
0x820c360:	0x00	0x00	0x00	0x30	0x00	0x03	0x00	0x00
0x820c368:	0x00	0x1a	0x04	0x01	0xfb	0x0e	0x0d	0x00
0x820c370:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x820c378:	0x00	0x00	0x01	0x00	0x61	0x2e	0x53	0x00
0x820c380:	0x00	0x00	0x00	0x00	0x00	0x05	0x02	0x00
0x820c388:	0x00	0x00	0x00	0x14	0x21	0x21	0x22	0x02
0x820c390:	0x01	0x00	0x01	0x01
(gdb)

At this time, I mistook that two results were the same (Later I noticed).
So I wondered why there exsisted the diffrence between `62' and `20'.

So I decided to investigate the way of displaying the value by
ft32-elf-objdump, where before applying WA it displayed 20, and
after applyging WA it displayed 62.

Execution of

% ft32-elf-objdump -g ../gas/a.out 

I tried to investigate the reason why ft32-elf-objdump displayed `62' not `20'.

 Line Number Statements:
  [0x00000024]  Extended opcode 2: set Address to 0x0
  [0x0000002b]  Special opcode 7: advance Address by 0 to 0x0 and Line by 2 to 3
  [0x0000002c]  Special opcode 62: advance Address by 4 to 0x4 and Line by 1 to 4
  [0x0000002d]  Special opcode 62: advance Address by 4 to 0x8 and Line by 1 to 5
  [0x0000002e]  Special opcode 63: advance Address by 4 to 0xc and Line by 2 to 7
  [0x0000002f]  Advance PC by 4 to 0x10
  [0x00000031]  Extended opcode 1: End of Sequence

This was the mentioned `62'. And it was desplayed below:

		      printf (_("  Special opcode %d: "
				"advance Address by %s to 0x%s%s"),
			      op_code, dwarf_vmatoa ("u", uladv),
			      dwarf_vmatoa ("x", state_machine_regs.address),
			      verbose_view && uladv
			      ? _(" (reset view)") : "");

I confirmed that `op_code' was 62. I took care of `20' ( = 0x14) but,

	      if (op_code >= linfo.li_opcode_base)
		{
		  op_code -= linfo.li_opcode_base;

`op_code' was calculated like above. Now because linfo.li_opcode_base = 13,

62 = 75 - 13 = 0x4b - 13

That's it. 62 was deduced from `0x4b'.

And now I noticed that:

(gdb) x/52bx  location
0x8171e38:	0x00	0x00	0x00	0x00	0x03	0x00	0x00	0x00
0x8171e40:	0x00	0x00	0x01	0x01	0xfb	0x0e	0x0d	0x00
0x8171e48:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x8171e50:	0x00	0x00	0x01	0x00	0x61	0x2e	0x53	0x00
0x8171e58:	0x00	0x00	0x00	0x00	0x00	0x05	0x02	0x00
0x8171e60:	0x00	0x00	0x00	0x14	0x4b	0x4b	0x4c	0x02
0x8171e68:	0x04	0x00	0x01	0x01     ~~~
(gdb)

I investigated the reason why this data became `0x4b'.

`addr_delta' (2nd argument of `emit_fixed_inc_line_addr') was 1 at ppc-elf-as
but it was 4 at ft32-elf-as.

  if (DWARF2_LINE_MIN_INSN_LENGTH > 1)
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~

Above value was defined as 1 at ft32-elfas. It was defined as 4 at ppc-elf-as.

Then I tried below:

//# define DWARF2_LINE_MIN_INSN_LENGTH	1
# define DWARF2_LINE_MIN_INSN_LENGTH	4

but ft32-elf-gdb could not still get correct line number information.

I looked for assembler where `DWARF2_USE_FIXED_ADVANCE_PC' was defined as 1.

At mn10300, msp430 and rl78, it was defined as 1.

At aarch64, arm, h8300, iq2000, m32r, mips, ppc, sh and v850, it was define
as 0.


arm
 Line Number Statements:
  [0x00000028]  Extended opcode 2: set Address to 0x100
  [0x0000002f]  Special opcode 7: advance Address by 0 to 0x100 and Line by 2 to 3
  [0x00000030]  Special opcode 34: advance Address by 4 to 0x104 and Line by 1 to 4
  [0x00000031]  Special opcode 34: advance Address by 4 to 0x108 and Line by 1 to 5
  [0x00000032]  Special opcode 35: advance Address by 4 to 0x10c and Line by 2 to 7

This implies that the value should not be 20 absolutely.

iq2000
  [0x0000002a]  Extended opcode 2: set Address to 0x80000100
  [0x00000031]  Special opcode 7: advance Address by 0 to 0x80000100 and Line by 2 to 3
  [0x00000032]  Special opcode 62: advance Address by 4 to 0x80000104 and Line by 1 to 4
  [0x00000033]  Special opcode 62: advance Address by 4 to 0x80000108 and Line by 1 to 5
  [0x00000034]  Special opcode 63: advance Address by 4 to 0x8000010c and Line b


The problem was that at the first place, ft32-elf-as could not generate line
information correctly.
If I imitate ppc-elf-as style, ft32-elf-gdb could not get line information
correctly.

