Investigation about ft32-elf-gdb can’t handle a.out.fake-ld-new as I expect

I did like below:

(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_ft32.000
(gdb) run -q -x x a.out.fake-ld-new

Then I confirmed that

dwarf_decode_lines_1

was called, at 1st time it came below part:

            case DW_LNS_fixed_advance_pc:
              {
                CORE_ADDR addr_adj = read_2_bytes (abfd, line_ptr);
                line_ptr += 2;

                state_machine.handle_fixed_advance_pc (addr_adj);
              }
              break;

The expected motion is that it came below part reading extended opcode:

                case DW_LNE_set_address:
                  {
                    CORE_ADDR address
                      = cu->header.read_address (abfd, line_ptr, &bytes_read);
                    line_ptr += bytes_read;

                    state_machine.check_line_address (cu, line_ptr,
                                                      lowpc - baseaddr, address);
                    state_machine.handle_set_address (baseaddr, address);
                  }
                  break;


This was caused by below code:

gdb-10.2.ft32-elf/gdb/dwarf2/line-header.c

  lh->header_length = read_offset (abfd, line_ptr, offset_size);

Here, lh->header_length became 36, but because

offset_size = 4

`line_ptr' is advanced too much as a result. Below gdb commands makes `line_ptr' expected:

(gdb) set line_ptr-=10
(gdb) x/32bx line_ptr + lh->header_length
0x8dbed84:      0x00    0x05    0x02    0x00    0x01    0x00    0x00    0x14
0x8dbed8c:      0x03    0x01    0x09    0x04    0x00    0x01    0x03    0x01
0x8dbed94:      0x09    0x04    0x00    0x01    0x03    0x02    0x09    0x04
0x8dbed9c:      0x00    0x01    0x09    0x04    0x00    0x00    0x01    0x01
(gdb)

                         rl78      ft32
  lh->header_length       32       36
  offset_size              4        4

But this’ll cause zero division.

void
lnp_state_machine::handle_special_opcode (unsigned char op_code)
{
  unsigned char adj_opcode = op_code - m_line_header->opcode_base;
  unsigned char adj_opcode_d = adj_opcode / m_line_header->line_range;  // This
  unsigned char adj_opcode_r = adj_opcode % m_line_header->line_range;

In the first place, the expected value is not set.

  Offset:                      0x0
  Length:                      64
  DWARF Version:               3
  Prologue Length:             36
  Minimum Instruction Length:  1
  Initial value of 'is_stmt':  1
  Line Base:                   -5
  Line Range:                  14
  Opcode Base:                 13

where, `Prologue length' is 36 but should not be, and
`Minimum Instruction Length' should be 4.

I did the same thing with `rl78-elf-gdb', m_line_header->line_range = 14

Old value = 0 '\000'
New value = 14 '\016'
dwarf_decode_line_header (sect_off=0, is_dwz=false, per_objfile=0x91ab470, section=0x91c14f0, cu_header=0x91c1ae8) at dwarf2/line-header.c:378

It was set at above code. That is `Line Range'.

Above shows that it is possible to mistake `Prologue Length'.

The result of ft32-elf-objdump for ft32-elf-as output is:

  Offset:                      0x0
  Length:                      70
  DWARF Version:               3
  Prologue Length:             42
  Minimum Instruction Length:  1
  Initial value of 'is_stmt':  1
  Line Base:                   -5
  Line Range:                  14
  Opcode Base:                 13

where, 70 = 0x46 and 42 = 0x2a are relocatable.

RELOCATION RECORDS FOR [.debug_line]:
OFFSET   TYPE              VALUE 
00000000 R_FT32_32         .debug_line+0x00000046       // This
00000006 R_FT32_32         .debug_line+0x0000002a       // This
0000002d R_FT32_32         .text
00000035 R_FT32_16         .text+0x00000004
0000003b R_FT32_16         .text+0x00000008
00000041 R_FT32_16         .text+0x0000000c
00000045 R_FT32_16         .text+0x00000010

(gdb) set line_ptr-=10

Above operation was not correct. If I execute in below situtation:

(gdb) info b
Num     Type           Disp Enb Address    What
5       breakpoint     keep y   0x081c9a64 in dwarf_decode_line_header(sect_offset, bool, dwarf2_per_objfile*, dwarf2_section_info*, comp_unit_head const*) at dwarf2/line-header.c:356
	breakpoint already hit 2 times
        set lh->statement_program_start-=10    # This
        c
(gdb)

Breakpoint 1 at 0x100: file a.S, line 3.
Breakpoint 2 at 0x10c: file a.S, line 7.
[Thread 0xb6f03b70 (LWP 27762) exited]
[Thread 0xb7704b70 (LWP 27761) exited]

This is what I expected. And more,

M-x gdb
run -q -x x a.out.fake-ld-new.conv

executing like above


(gdb) p len
$38 = 5
(gdb) p/x first[0]
$39 = {line = 0x3, is_stmt = 0x1, pc = 0x100}
(gdb) p/x first[1]
$40 = {line = 0x4, is_stmt = 0x1, pc = 0x104}
(gdb) p/x first[2]
$41 = {line = 0x5, is_stmt = 0x1, pc = 0x108}
(gdb) p/x first[3]
$42 = {line = 0x7, is_stmt = 0x1, pc = 0x10c}
(gdb) p/x first[4]
$43 = {line = 0x0, is_stmt = 0x1, pc = 0x110}
(gdb)

where, `a.out.fake-ld-new.conv' is converted

Prologue Length:             42

of `a.out.fake-ld-new' to 26.

42 = 0x2a
26 = 0x1a

