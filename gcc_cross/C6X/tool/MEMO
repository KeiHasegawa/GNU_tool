開発メモ

(*1)
2022.07.05 8:42

現状 f を実行すると

6 + 6 = 11

のようになっている. f から printf を呼び出す直前を調べてみる.

Breakpoint 1, f () at sample.s:37
(tic6x-elf-gdb) p *(char**)($B15+4)
$1 = 0x1ce0 "%d + %d = %d\n"
(tic6x-elf-gdb) p *(int*)($B15+8)
$2 = 6
(tic6x-elf-gdb) p *(int*)($B15+12)
$3 = 6
(tic6x-elf-gdb) p *(int*)($B15+16)
$4 = 11
(tic6x-elf-gdb)

であるから, シミュレータの printf の扱いに問題があるわけではなくて単純にコンパイラのコード
に問題があるように思える.


(tic6x-elf-gdb) p (int*)($B15+8)
$5 = (int *) 0x1fd54
(tic6x-elf-gdb)
...

Watchpoint 3: *(int*)0x1fd54

Old value = -858993460
New value = 6
f () at sample.s:22
(tic6x-elf-gdb) p/x -858993460
$1 = 0xcccccccc
(tic6x-elf-gdb)

f:
...
		stw	.d1t2	B4, *-A15(16)   ★
		ldw	.d1t1	*-A15(12), A1

これは引数をスタックに保存している部分. 改めてコードを調べてみると

  printf("%d + %d = %d\n", a, b, a+b);

書式文字列はスタックポインタ相対 4 に
a は a4 レジスタに
b は b4 レジスタに
a+b は スタックポインタ相対 16 にセットされている. これは ABI をよく理解していなかったとい
うこと.

  => 実は printf の引数はスタック渡しにするということで問題なかった. おそらく stw 命令
     か ldw 命令のシミュレーションに問題があった.

(*2)
2022.07.05 9:01
現状実行すると

5 + 6 = 11
hello world


1.000000
9
wa kei3.000000
...
のようになっている. gg の呼び出し結果が期待したものになっていない. gg と main のみ
コンパイルし, 実行すると以下のようになる:

hasegawa  5 6.000000

まずはこれが期待した結果になることを目指す.

Breakpoint 1, gg () at sample.s:16
(tic6x-elf-gdb) p (char*)$A4
$2 = 0x1ffeb "hasegawa kei"
(tic6x-elf-gdb) p $B4
$3 = 5
(tic6x-elf-gdb) p/x $A6
$8 = 0x0
(tic6x-elf-gdb) p/x $A7
$9 = 0x40180000
(tic6x-elf-gdb) 

であるから gg の呼び出しまでは正しい. printf を呼び出す直前では

Breakpoint 2, gg () at sample.s:36
(tic6x-elf-gdb) p *(char**)($B15+4)
$10 = 0x240 "%s %d %f\n"
(tic6x-elf-gdb) p (char*)($A4)
$11 = 0x1ffeb "hasegawa \020\002"
(tic6x-elf-gdb) p $B4
$12 = 5
(tic6x-elf-gdb) p *(double*)($B15+16)
$14 = 6
(tic6x-elf-gdb)

であるからこの結果になっている. つまり $A4+9 = 0x1ffeb+9 がどこかで破壊されている.

Watchpoint 2: *(char*)(0x1ffeb+9)

Old value = 107 'k'
New value = 16 '\020'
gg () at sample.s:20
(tic6x-elf-gdb)

gg:
		stw	.d2t1	A15, *B15--(8)
		add	.l1x	8, B15, A15
		subah	.d2	B15, 24, B15
		stw	.d2t2	B3, *+B15(52)  ★
		stw	.d1t1	A4, *-A15(12)

B3 をスタックに保存しているコードで破壊しているらしい. と思ったが subah のシミュレーション
が sub と同じにしている. おそらくこれが間違い.

(*3)
現状実行すると以下のようになる:
5 + 6 = 11
hello world


1.000000
9
wa kei3.000000
1.000000 2.000000 3.000000
core: 4 byte read to unmapped address 0xd at 0x44c
program stopped with signal 11 (Segmentation fault).


g2:
...
		mvk	.s1	560, A3
		add	.d1	A15, A3, A0
		addab	.d1x	B15, 640, A2
		lddw	.d1t1	*A0, A1:A0  ★


(tic6x-elf-gdb) p/x $A0
$2 = 0xd
(tic6x-elf-gdb)

なので A0 の値を間違えている.


(tic6x-elf-gdb) p/x $A15
$4 = 0x1fd64
(tic6x-elf-gdb) p $A3
$5 = 130417
(tic6x-elf-gdb) p/x $A3
$6 = 0x1fd71
(tic6x-elf-gdb)

A15 はフレームポインタなので値はそれっぽいがだとすれば A3 の値が予測しない値のように思える.
そしてそもそも

(tic6x-elf-gdb) p/x 0x1fd64 + 0x1fd71
$10 = 0x3fad5
(tic6x-elf-gdb)

なのでいろいろと違っている. まずは A3 が 560 にならない理由を確認する.

		mvk	.s1	560, A3
		add	.d1	A15, A3, A0

に対して正しくシミュレーションしていることを確認した.
lddw のシミュレーションに問題があった.

(*4)
2022.07.05 11:08 現状実行すると以下のようになる:

5 + 6 = 11
hello world


1.000000
9
hasegawa kei 5 6.000000
3.000000
1.000000 2.000000 3.000000
3 4 5 6 7 8 9 10 11 12 3392 14 15 1044034669219365888 36028797220512256 -4747988043639531513 27021598777238545 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 42949672960 2814749767106560 6160 403701760 26456998543360 1733885856537640960 0 0 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82

また g2 と main のみコンパイルして実行すると以下のようになる.

3 4 5 6 7 8 9 10 11 12 3532 14 15 27021597764445201 -9156899961751518208 144321897275342849 27021597764445201 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 46385646796 3039929748422656 -3689348818177880672 -3689573994494636852 14984281902284 982009898748084224 -3689348818177884160 -3689573994723278848 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x1 at 0x860
program stopped with signal 11 (Segmentation fault).

まずこのプログラムの正常動作を目指す. 不正メモリアクセスが発生する前に 13 があるはずのメモリ
が壊れている. printf を呼び出す直前

(tic6x-elf-gdb) p *(int*)($sp+8 * (12+1))
$2 = 15
(tic6x-elf-gdb) p *(int*)($sp+8 * (11+1))
$3 = 14
(tic6x-elf-gdb) p *(int*)($sp+8 * (10+1))
$6 = 3532                                     ★
(tic6x-elf-gdb) p *(int*)($sp+8 * (9+1))
$7 = 12
(tic6x-elf-gdb) 

アドレスを確認してウォッチポイントをセットしてみた:

(tic6x-elf-gdb) p (int*)($sp+8 * (10+1))
$8 = (int *) 0x1faa0
...
Watchpoint 2: *(int *) 0x1faa0

Old value = -858993460
New value = 3532
g2 () at sample.s:430
(tic6x-elf-gdb)

確かに 3532 をセットしているらしい. そしてこの値が変更されることなく printf の呼び出し
がある. よって 3532 が printf によって出力されている. 問題の箇所は以下:

		lddw	.d1t1	*A0, A1:A0
		nop	4
		stdw	.d1t1	A1:A0, *A2   ★

これは, 心当たりがある. おそらく lddw 命令が正しくシミュレーションできていない.
と思ったがこれは修正したところだった:

      uint32_t l = sim_core_read_aligned_4(cpu, cia, read_map, *r+(ucst5 << 3));
      uint32_t h =
	sim_core_read_aligned_4(cpu, cia, read_map, *r+(ucst5 << 3)+4);
      *lo = l;
      *hi = h;

(gdb) p l
$1215 = 3532
(gdb) p h
$1216 = 0
(gdb)

確かに 3532 がきている. だとすれば lddw で指定している A0 のアドレスに問題があるかもしれない.

(gdb) p/x cpu->a[baseR]
$1219 = 0x1fd7b
(gdb) p ucst5
$1220 = 0
(gdb)

ターゲットメモリ 0x1fd7b に 3532 が書き込まれているはず.


Watchpoint 2: *(int*)0x1fd7b

Old value = -858993460
New value = 3532
main () at sample.s:795
(tic6x-elf-gdb) 

		mvk	.d1	13, A0
		mvk	.d1	0, A1
		stdw	.d1t1	A1:A0, *A2  ★

これは 13 が書き込まれないとおかしい. つまりシミュレータに問題がある.
とここで cpu->a[baseR] が 0x1fd7b であることに気付く. アドレスがおかしい

(gdb) p/x 3532
$1239 = 0xdcc
(gdb)

なので 13 (= 0xd) を書き込もうとはしているがアドレスに問題があったらしい.
add 命令のフェッチに問題がある.

  if (insn & (1 << 17)) {    ★
    int imm = (insn >> 13) & 0x1f;
    cpu->a[dst] = cpu->a[src1] + imm;
  }
  else {
    int src2 = (insn >> 13) & 0xf;
    cpu->a[dst] = cpu->a[src1] + cpu->a[src2];
  }

上の条件が正しくないので cpu->a[0] が正しい値になっていないということ. 上はビット 17
ではなくてビット 8 を見るのが正しい. 

(*5)

2022.07.05 13:22 (*4) の修正を入れたが現状実行結果は以下:

3 4 5 6 7 8 9 10 11 12 13 14 15 27021597764445201 -9156899961751518208 144321897275342849 27021597764445201 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 46385646796 3039929748422656 -3689348818177880672 -3689573994494636852 14984281902284 982009898748084224 -3689348818177884160 -3689573994723278848 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x1 at 0x860
program stopped with signal 11 (Segmentation fault).

printf を呼び出す直前は以下のようになっている.

(tic6x-elf-gdb) p *(long long*)($sp + 8 * (12+1))
$4 = 15
(tic6x-elf-gdb) p *(long long*)($sp + 8 * (13+1))
$5 = 27021597764445201

(tic6x-elf-gdb) p (long long*)($sp + 8 * (13+1))
$6 = (long long *) 0x1fab8
(tic6x-elf-gdb)


		add	.d1	A15, 24, A0
		addab	.d1x	B15, 104, A2
		lddw	.d1t1	*A0, A1:A0
		nop	4
		stdw	.d1t1	A1:A0, *A2  ★


値をセットしているところは stdw 命令だがその数命令前で A0, A1 に値をロードしている.


(*6)
2022.07.05 15:18 現時点で実行結果は以下のようになっている:

5 + 6 = 11
hello world


1.000000
9
hasegawa kei 5 6.000000
3.000000
1.000000 2.000000 3.000000
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x20064 at 0x1198
program stopped with signal 11 (Segmentation fault)

f2 と main だけをコンパイルして実行すると以下のようになる:

test_f3 = -858993460

これは変数 test_f3 に正しくアクセスできていないらしい. 15 ビットのオフセット指定の
ロード/ストアの命令フォーマットに対応していなかった.

(*7)
2022.07.05 18:28
現状 printf, puts, putchar のツールが期待通り動作している. しかし以下がまだできていない.

  1. 遅延スロット
  2. 条件実行 (creg を参照していない. b_cst21 のみやっている) 
  3. 並列実行

まずは遅延スロットに対応する. 例えば

	ldw	.d1t1	*-A15(12), A1
	nop	4

のようにロード命令は遅延スロット 4 でレジスタに値が反映されるから

struct delay {
  virtual void exec() = 0;
  virtual ~delay(){}
};

vector<delay*> delay_slot;

struct delay_ld : delay {
  uint32_t* dst;
  uint32_t src;
  delay_ldw(uint32_t* d, uint32_t s) : dst{d}, src{s} {}
  void exec(){ *dst = src; }
};


while (delay_slot.size() < 3)
  delay_slot.push_back(nullptr);
 
uint32_t data = sim_core_read_aligned_4(...);
delay_slot.push_back(new dealy_ld(&cpu->a[1], data));

のようにする. ldw のシュミレーションでは直接 cpu->a[1] を変更しない.
まずは ldw, lddw, ldnw, ldb 命令での正常動作を目指す.

2022.07.06 7:35 delay_slot を消化するのは現状 nop でしか行なっていないものの
printf, puts, putchar や test001, test002 が期待通りに動作している.

2022.07.06 7:55 nop 以外でも delay_slot を消化できるようにしてやはり正常動作を確認している.

2022.07.06 9:01 Branch 命令も同様に対応してみる. オリジナルの cc1 では callp 命令の
後に nop 1 を生成している場合もあれば生成していない場合もあり, おそらくはバグかとは思うが
callp 命令の遅延スロットに関する仕様が不明なので遅延スロット 0 の扱いにしておく.

2022.07.06 9:44 Branch 命令に対応した. これまでのテストも期待通り動作している.
しかし以下の 14 行目でステップ実行すると 15 行目ではなく 9 行目で停止する.

% cat -n start.S 
     1		.text
     2	start:
     3		mvkl	.s1	_bss_start, a1
     4		mvkh	.s1	_bss_start, a1
     5		mvkl	.s1	_bss_end, a2
     6		mvkh	.s1	_bss_end, a2
     7		mvkl	.s1	0, a3
     8	.L1:
     9		cmpeq	.l1	a1, a2, a0
    10		[a0] b	.s2	.L2
    11		nop	5
    12		stb	.d1t1	a3, *a1
    13		add	.d1	a1, 1, a1
    14		b	.s2	.L1
    15		nop	5
    16	.L2:	
    17		mvkl	.s2	__c6xabi_DSBT_BASE, b14
  
同様に 10 行目で条件が成立する場合もステップ実行により 11 行目ではなくて 17 行目で停止する.
勿論 15 行目や 11 行目の nop 5 を実行していることには間違いはない.
ロード命令でステップ実行した場合は勿論次の  nop 4 を実行する前に停止している.

ステップ実行の後に続く sim_resume(step=0) の呼び出しがある. 調査前の予想では
sim_resum(step=1) の呼び出しがあるのかと思っていたが違っていた. この状況は
ロード命令でも分岐命令でも同じで, 内部ブレークポイントが次の命令にセットされているのがロード命令
で次の次の命令にセットされているか分岐命令という違いがある.

分岐命令で次の次の命令に内部ブレークポイントをセットしたときのスタックは以下:


(gdb) where
#0  sim_write (sd=0x8bc2d18, mem=276, buf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", length=4) at ../common/sim-hrw.c:38
#1  0x082a7006 in gdbsim_xfer_memory (xfered_len=0xbfffea68, len=4, memaddr=276, writebuf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", readbuf=0x0, target=0x8a381d0 <gdbsim_ops>) at remote-sim.c:1061
#2  gdbsim_target::xfer_partial (this=0x8a381d0 <gdbsim_ops>, object=TARGET_OBJECT_MEMORY, annex=0x0, readbuf=0x0, writebuf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", offset=276, len=4, xfered_len=0xbfffea68) at remote-sim.c:1091
#3  0x0832f6ef in raw_memory_xfer_partial (ops=0x8a381d0 <gdbsim_ops>, readbuf=0x0, writebuf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", memaddr=276, len=4, xfered_len=0xbfffea68) at target.c:918
#4  0x08333182 in target_xfer_partial (ops=0x8a381d0 <gdbsim_ops>, object=TARGET_OBJECT_RAW_MEMORY, annex=0x0, readbuf=0x0, writebuf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", offset=276, len=<optimized out>, xfered_len=0xbfffea68) at target.c:1156
#5  0x083337da in target_write_partial (xfered_len=0xbfffea68, len=4, offset=276, buf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", annex=0x0, object=TARGET_OBJECT_RAW_MEMORY, ops=0x8a381d0 <gdbsim_ops>) at target.c:1397
#6  target_write_with_progress (ops=0x8a381d0 <gdbsim_ops>, object=TARGET_OBJECT_RAW_MEMORY, annex=0x0, buf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", offset=276, len=4, progress=0x0, baton=0x0) at target.c:1665
#7  0x0833390f in target_write (len=<optimized out>, offset=276, buf=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", annex=0x0, object=TARGET_OBJECT_RAW_MEMORY, ops=<optimized out>) at target.c:1690
--Type <RET> for more, q to quit, c to continue without paging--
#8  target_write_raw_memory (memaddr=276, myaddr=0x86fde88 <tic6x_bkpt_illegal_opcode_le> "\024CEVVEC\024negative value: %s", len=4) at target.c:1318
#9  0x0822a998 in default_memory_insert_breakpoint (gdbarch=0x8bab528, bp_tgt=0x8bc5efc) at mem-break.c:68
#10 0x0832faef in target_insert_breakpoint (gdbarch=0x8bab528, bp_tgt=0x8bc5efc) at target.c:1821
#11 0x080be6db in bkpt_insert_location (bl=0x8bc5e98) at breakpoint.c:12411
#12 0x080cecd6 in insert_bp_location (bl=0x8bc5e98, tmp_error_stream=<optimized out>, disabled_breaks=<optimized out>, hw_breakpoint_error=<optimized out>, hw_bp_error_explained_already=<optimized out>) at breakpoint.c:2515
#13 0x080d0ffe in insert_breakpoint_locations () at breakpoint.c:2940
#14 update_global_location_list (insert_mode=UGLL_INSERT) at breakpoint.c:12069
#15 0x080d6d12 in insert_single_step_breakpoint (gdbarch=0x8ba54e0, aspace=0x8b50e28, next_pc=276) at breakpoint.c:14500
--Type <RET> for more, q to quit, c to continue without paging--c
#16 0x080d6e9e in insert_single_step_breakpoints (gdbarch=0x8ba54e0) at breakpoint.c:14519
#17 0x081f622f in maybe_software_singlestep (pc=<optimized out>, gdbarch=0x8ba54e0) at infrun.c:2127
#18 maybe_software_singlestep (pc=296, gdbarch=0x8ba54e0) at infrun.c:2121
#19 resume_1 (sig=<optimized out>) at infrun.c:2477
#20 resume (sig=GDB_SIGNAL_0) at infrun.c:2630
#21 0x081f6e46 in keep_going_pass_signal (ecs=0xbfffef7c) at infrun.c:7876
#22 0x081f714b in start_step_over () at infrun.c:2028
#23 0x081fdaf1 in proceed (addr=18446744073709551615, siggnal=GDB_SIGNAL_DEFAULT) at infrun.c:3079
#24 0x081e5cd1 in step_1 (skip_subroutines=0, single_inst=<optimized out>, count_string=<optimized out>) at infcmd.c:900
#25 0x080fd50c in cmd_func (cmd=0x8b0f7c0, args=0x0, from_tty=0) at cli/cli-decode.c:2181
#26 0x0834187e in execute_command (p=<optimized out>, from_tty=0) at top.c:668
#27 0x081a9b1c in command_handler (command=0x8bcc8b8 "step") at event-top.c:588
#28 0x0833fe8c in read_command_file (stream=0x8b9e708) at top.c:447
#29 0x08103b21 in script_from_file (stream=0x8b9e708, file=0xbffff851 "gdbcom.2") at cli/cli-script.c:1622
#30 0x080fa3b4 in source_script_from_stream (file_to_open=0xbffff851 "gdbcom.2", file=0xbffff851 "gdbcom.2", stream=0x8b9e708) at cli/cli-cmds.c:700
#31 source_script_with_search (file=0xbffff851 "gdbcom.2", file@entry=<error reading variable: value has been optimized out>, from_tty=<error reading variable: value has been optimized out>, search_path=<error reading variable: value has been optimized out>) at cli/cli-cmds.c:736
#32 0x0821e10a in catch_command_errors (command=<optimized out>, arg=<optimized out>, from_tty=<optimized out>) at main.c:457
#33 0x0821fdf0 in captured_main_1 (context=<optimized out>) at main.c:1214
#34 0x082201ed in captured_main (data=0xbffff554) at main.c:1243
#35 gdb_main (args=0xbffff554) at main.c:1268
#36 0x080719bc in main (argc=5, argv=0xbffff624) at gdb.c:32
(gdb)


なるほど以下の函数で決めていたらしい. 自分のやりたかった gdb の動作ではないがここは
そういう実装だったということでスルーしておく.

/* Determine where to set a single step breakpoint.  */

static CORE_ADDR
tic6x_get_next_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = regcache->arch ();
  unsigned long inst;
  int register_number;
  int last = 0;

  do
    {
...

残る課題は以下だが面倒なので気が向いたら対応することにする.

  2. 条件実行 (creg を参照していない. b_cst21 のみやっている) 
  3. 並列実行

(*8)
自前の cc1 を開発している段階で対応していない命令があったのと, subaw のフェッチが正しくない
問題があったのを修正した. この時点での

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.tic6x-elf/sim/tic6x

を tic6x.2.tar としてアップロードしておく.
