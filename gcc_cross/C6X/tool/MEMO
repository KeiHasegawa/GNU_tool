開発メモ

(*1)
2022.07.05 8:42

現状 f を実行すると

6 + 6 = 11

のようになっている. f から printf を呼び出す直前を調べてみる.

Breakpoint 1, f () at sample.s:37
(tic6x-elf-gdb) p *(char**)($B15+4)
$1 = 0x1ce0 "%d + %d = %d\n"
(tic6x-elf-gdb) p *(int*)($B15+8)
$2 = 6
(tic6x-elf-gdb) p *(int*)($B15+12)
$3 = 6
(tic6x-elf-gdb) p *(int*)($B15+16)
$4 = 11
(tic6x-elf-gdb)

であるから, シミュレータの printnf の扱いに問題があるわけではなくて単純にコンパイラのコード
に問題があるように思える.


(tic6x-elf-gdb) p (int*)($B15+8)
$5 = (int *) 0x1fd54
(tic6x-elf-gdb)
...

Watchpoint 3: *(int*)0x1fd54

Old value = -858993460
New value = 6
f () at sample.s:22
(tic6x-elf-gdb) p/x -858993460
$1 = 0xcccccccc
(tic6x-elf-gdb)

f:
...
		stw	.d1t2	B4, *-A15(16)   ★
		ldw	.d1t1	*-A15(12), A1

これは引数をスタックに保存している部分. 改めてコードを調べてみると

  printf("%d + %d = %d\n", a, b, a+b);

書式文字列はスタックポインタ相対 4 に
a は a4 レジスタに
b は b4 レジスタに
a+b は スタックポインタ相対 16 にセットされている. これは ABI をよく理解していなかったとい
うこと.

  => 実は printf の引数はスタック渡しにするということで問題なかった. おそらく stw 命令
     か ldw 命令のシミュレーションに問題があった.

(*2)
2022.07.05 9:01
現状実行すると

5 + 6 = 11
hello world


1.000000
9
wa kei3.000000
...
のようになっている. gg の呼び出し結果が期待したものになっていない. gg と main のみ
コンパイルし, 実行すると以下のようになる:

hasegawa  5 6.000000

まずはこれが期待した結果になることを目指す.

Breakpoint 1, gg () at sample.s:16
(tic6x-elf-gdb) p (char*)$A4
$2 = 0x1ffeb "hasegawa kei"
(tic6x-elf-gdb) p $B4
$3 = 5
(tic6x-elf-gdb) p/x $A6
$8 = 0x0
(tic6x-elf-gdb) p/x $A7
$9 = 0x40180000
(tic6x-elf-gdb) 

であるから gg の呼び出しまでは正しい. printf を呼び出す直前では

Breakpoint 2, gg () at sample.s:36
(tic6x-elf-gdb) p *(char**)($B15+4)
$10 = 0x240 "%s %d %f\n"
(tic6x-elf-gdb) p (char*)($A4)
$11 = 0x1ffeb "hasegawa \020\002"
(tic6x-elf-gdb) p $B4
$12 = 5
(tic6x-elf-gdb) p *(double*)($B15+16)
$14 = 6
(tic6x-elf-gdb)

であるからこの結果になっている. つまり $A4+9 = 0x1ffeb+9 がどこかで破壊されている.

Watchpoint 2: *(char*)(0x1ffeb+9)

Old value = 107 'k'
New value = 16 '\020'
gg () at sample.s:20
(tic6x-elf-gdb)

gg:
		stw	.d2t1	A15, *B15--(8)
		add	.l1x	8, B15, A15
		subah	.d2	B15, 24, B15
		stw	.d2t2	B3, *+B15(52)  ★
		stw	.d1t1	A4, *-A15(12)

B3 をスタックに保存しているコードで破壊しているらしい. と思ったが subah のシミュレーション
が sub と同じにしている. おそらくこれが間違い.

(*3)
現状実行すると以下のようになる:
5 + 6 = 11
hello world


1.000000
9
wa kei3.000000
1.000000 2.000000 3.000000
core: 4 byte read to unmapped address 0xd at 0x44c
program stopped with signal 11 (Segmentation fault).


g2:
...
		mvk	.s1	560, A3
		add	.d1	A15, A3, A0
		addab	.d1x	B15, 640, A2
		lddw	.d1t1	*A0, A1:A0  ★


(tic6x-elf-gdb) p/x $A0
$2 = 0xd
(tic6x-elf-gdb)

なので A0 の値を間違えている.


(tic6x-elf-gdb) p/x $A15
$4 = 0x1fd64
(tic6x-elf-gdb) p $A3
$5 = 130417
(tic6x-elf-gdb) p/x $A3
$6 = 0x1fd71
(tic6x-elf-gdb)

A15 はフレームポインタなので値はそれっぽいがだとすれば A3 の値が予測しない値のように思える.
そしてそもそも

(tic6x-elf-gdb) p/x 0x1fd64 + 0x1fd71
$10 = 0x3fad5
(tic6x-elf-gdb)

なのでいろいろと違っている. まずは A3 が 560 にならない理由を確認する.

		mvk	.s1	560, A3
		add	.d1	A15, A3, A0

に対して正しくシミュレーションしていることを確認した.
lddw のシミュレーションに問題があった.

(*4)
2022.07.05 11:08 現状実行すると以下のようになる:

5 + 6 = 11
hello world


1.000000
9
hasegawa kei 5 6.000000
3.000000
1.000000 2.000000 3.000000
3 4 5 6 7 8 9 10 11 12 3392 14 15 1044034669219365888 36028797220512256 -4747988043639531513 27021598777238545 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 42949672960 2814749767106560 6160 403701760 26456998543360 1733885856537640960 0 0 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82

また g2 と main のみコンパイルして実行すると以下のようになる.

3 4 5 6 7 8 9 10 11 12 3532 14 15 27021597764445201 -9156899961751518208 144321897275342849 27021597764445201 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 46385646796 3039929748422656 -3689348818177880672 -3689573994494636852 14984281902284 982009898748084224 -3689348818177884160 -3689573994723278848 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x1 at 0x860
program stopped with signal 11 (Segmentation fault).

まずこのプログラムの正常動作を目指す. 不正メモリアクセスが発生する前に 13 があるはずのメモリ
が壊れている. printf を呼び出す直前

(tic6x-elf-gdb) p *(int*)($sp+8 * (12+1))
$2 = 15
(tic6x-elf-gdb) p *(int*)($sp+8 * (11+1))
$3 = 14
(tic6x-elf-gdb) p *(int*)($sp+8 * (10+1))
$6 = 3532                                     ★
(tic6x-elf-gdb) p *(int*)($sp+8 * (9+1))
$7 = 12
(tic6x-elf-gdb) 

アドレスを確認してウォッチポイントをセットしてみた:

(tic6x-elf-gdb) p (int*)($sp+8 * (10+1))
$8 = (int *) 0x1faa0
...
Watchpoint 2: *(int *) 0x1faa0

Old value = -858993460
New value = 3532
g2 () at sample.s:430
(tic6x-elf-gdb)

確かに 3532 をセットしているらしい. そしてこの値が変更されることなく printf の呼び出し
がある. よって 3532 が printf によって出力されている. 問題の箇所は以下:

		lddw	.d1t1	*A0, A1:A0
		nop	4
		stdw	.d1t1	A1:A0, *A2   ★

これは, 心当たりがある. おそらく lddw 命令が正しくシミュレーションできていない.
と思ったがこれは修正したところだった:

      uint32_t l = sim_core_read_aligned_4(cpu, cia, read_map, *r+(ucst5 << 3));
      uint32_t h =
	sim_core_read_aligned_4(cpu, cia, read_map, *r+(ucst5 << 3)+4);
      *lo = l;
      *hi = h;

(gdb) p l
$1215 = 3532
(gdb) p h
$1216 = 0
(gdb)

確かに 3532 がきている. だとすれば lddw で指定している A0 のアドレスに問題があるかもしれない.

(gdb) p/x cpu->a[baseR]
$1219 = 0x1fd7b
(gdb) p ucst5
$1220 = 0
(gdb)

ターゲットメモリ 0x1fd7b に 3532 が書き込まれているはず.


Watchpoint 2: *(int*)0x1fd7b

Old value = -858993460
New value = 3532
main () at sample.s:795
(tic6x-elf-gdb) 

		mvk	.d1	13, A0
		mvk	.d1	0, A1
		stdw	.d1t1	A1:A0, *A2  ★

これは 13 が書き込まれないとおかしい. つまりシミュレータに問題がある.
とここで cpu->a[baseR] が 0x1fd7b であることに気付く. アドレスがおかしい

(gdb) p/x 3532
$1239 = 0xdcc
(gdb)

なので 13 (= 0xd) を書き込もうとはしているがアドレスに問題があったらしい.
add 命令のフェッチに問題がある.

  if (insn & (1 << 17)) {    ★
    int imm = (insn >> 13) & 0x1f;
    cpu->a[dst] = cpu->a[src1] + imm;
  }
  else {
    int src2 = (insn >> 13) & 0xf;
    cpu->a[dst] = cpu->a[src1] + cpu->a[src2];
  }

上の条件が正しくないので cpu->a[0] が正しい値になっていないということ. 上はビット 17
ではなくてビット 8 を見るのが正しい. 

(*5)

2022.07.05 13:22 (*4) の修正を入れたが現状実行結果は以下:

3 4 5 6 7 8 9 10 11 12 13 14 15 27021597764445201 -9156899961751518208 144321897275342849 27021597764445201 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 -3689348814741910324 46385646796 3039929748422656 -3689348818177880672 -3689573994494636852 14984281902284 982009898748084224 -3689348818177884160 -3689573994723278848 3 196608 12884901888 844424930131968 4 262144 17179869184 1125899906842624 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x1 at 0x860
program stopped with signal 11 (Segmentation fault).

printf を呼び出す直前は以下のようになっている.

(tic6x-elf-gdb) p *(long long*)($sp + 8 * (12+1))
$4 = 15
(tic6x-elf-gdb) p *(long long*)($sp + 8 * (13+1))
$5 = 27021597764445201

(tic6x-elf-gdb) p (long long*)($sp + 8 * (13+1))
$6 = (long long *) 0x1fab8
(tic6x-elf-gdb)


		add	.d1	A15, 24, A0
		addab	.d1x	B15, 104, A2
		lddw	.d1t1	*A0, A1:A0
		nop	4
		stdw	.d1t1	A1:A0, *A2  ★


値をセットしているところは stdw 命令だがその数命令前で A0, A1 に値をロードしている.


(*6)
2022.07.05 15:18 現時点で実行結果は以下のようになっている:

5 + 6 = 11
hello world


1.000000
9
hasegawa kei 5 6.000000
3.000000
1.000000 2.000000 3.000000
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82
core: 4 byte read to unmapped address 0x20064 at 0x1198
program stopped with signal 11 (Segmentation fault)

f2 と main だけをコンパイルして実行すると以下のようになる:

test_f3 = -858993460

これは変数 test_f3 に正しくアクセスできていないらしい. 15 ビットのオフセット指定の
ロード/ストアの命令フォーマットに対応していなかった.

(*7)
2022.07.05 18:28
現状 printf, puts, putchar のツールが期待通り動作している. しかし以下がまだできていない.

  1. 遅延スロット
  2. コンディショナル実行 (creg を参照していない. b_cst21 のみやっている) 
  3. 並列実行

まずは遅延スロットに対応する. 例えば

	ldw	.d1t1	*-A15(12), A1
	nop	4

のようにロード命令は遅延スロット 4 でレジスタに値が反映されるから

struct delay {
  virtual void exec() = 0;
  virtual ~delay(){}
};

vector<delay*> delay_slot;

struct delay_ld : delay {
  uint32_t* dst;
  uint32_t src;
  delay_ldw(uint32_t* d, uint32_t s) : dst{d}, src{s} {}
  void exec(){ *dst = src; }
};


while (delay_slot.size() < 3)
  delay_slot.push_back(nullptr);
 
uint32_t data = sim_core_read_aligned_4(...);
delay_slot.push_back(new dealy_ld(&cpu->a[1], data));

のようにする. ldw のシュミレーションでは直接 cpu->a[1] を変更しない.
まずは ldw, lddw, ldnw, ldb 命令での正常動作を目指す.

2022.07.06 7:35 delay_slot を消化するのは現状 nop でしか行なっていないものの
printf, puts, putchar や test001, test002 が期待通りに動作している.

2022.07.06 7:55 nop 以外でも delay_slot を消化できるようにしてやはり正常動作を確認している.
