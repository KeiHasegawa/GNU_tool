(*0) VLIW

     32 ビットの命令長でビット 0 が次の命令と並列になるかを示している. 0 ならば
     単独で実行され, 1 ならば並列に実行される.

(*1) 命令フェッチ

     一度に 8 命令, すなわち 4 * 8 = 32 バイトがフェッチされる.

	+-------+-------+-------+-------+-------+-------+-------+-------+
	|   A	|   B	|   C	|   D	|   E	|   F	|   G	|   H	|
	+-------+-------+-------+-------+-------+-------+-------+-------+
               0       0       1       1       0       1       1       0

        A
	B
	C D E
	F G H

	A B の命令はそれぞれ単独で実行されるが, C, D, E は並列に実行される.
	F, G, H も並列に実行される.

(*1) レジスタ

     a0, ..., a15, b0, ..., b15

     b3  : リンクレジスタ
     b14 : グローバルポインタとしてコンパイラが使用する
     a15 : フレームポインタ
     b15 : スタックポインタ

     アドレッシングモードによってレジスタの長さと a?, b? を指定する.

     例 1

	mvk	.s2	stack, b15

     .s2 は 32 ビット b? レジスタを指定する. 32 ビット命令のビット 2.

     例 2

	mv	.d1	a0, a4

     .d1 は 32 ビット a? レジスタを指定している. 32 ビット命令のビット 2.


     例 3

	add	.l1x	8, b15, a15

     1x はクロスパス指定. b? -> a? を指定している. 2x ならば a? -> b?


     例 4

	stw	.d2t1	a15, *b15--(8)

     .d2t1 は a? -> [b?] を指定している.

(*3) 遅延スロット

     NOP 0
     Single cycle (例えば ADD) : 0
     Store : 0
     Multiply : 1
     Load : 4
     Branch : 5
     
(*4) 函数呼び出し

	callp	.s2	(func), b3

        疑似コード

	pc := func
	b3 := callp 命令の次の命令のアドレス.

(*5) 函数復帰

	ret	.s2	b3
	nop	5
