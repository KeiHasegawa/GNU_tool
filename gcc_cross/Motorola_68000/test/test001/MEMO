	bsr	main

ではスタックポインタの指す領域に現在のプログラムカウンタ(それは次の命令を指している)
を保存して main にジャンプする.
test.elf では sp = 0xffef なので

0xffee +-----------+ <- sp_{new}
       |           |
0xffee +-----------+
       | 0x00      |
0xffef +-----------+ <- sp_{old}       
       | 0x18      |
       +-----------+

のようになる.

main 函数の先頭で

	ldx	*_.frame

のようなコードがあるが. test.elf の場合 _.frame = 0x10 なので

        x = *(uint16_t*)0x10

のような動きになる. x は Motorola 68000 の x レジスタのこと.

	pshx

は現在の sp の領域に x を保存する命令で x が 0 だったので

0xffeb +-----------+ <- sp_{new}
       |           |
0xffec +-----------+
       | 0x00      |
0xffee +-----------+ <- sp_{old}
       | 0x00      |
0xffee +-----------+
       | 0x00      |
0xffef +-----------+
       | 0x18      |
       +-----------+

のような状態になる.


続く
	sts	*_.frame

だが _.frame = 0x10 なので

        *(uint16_t*)0x10 = sp

のような動きになる. sp をこの領域に保存している.

続く
        clra

命令だが a レジスタに 0 をセットしている.

	clrb

も同様に b レジスタに 0 をセットしている.

これは
	ldx	#0

 x レジスタに 0 をセットしている.

続く
	puly

は y レジスタに sp レジスタの先頭から 1 つ要素を読み出している.


0xffeb +-----------+ <- sp_{old}
       |           |
0xffec +-----------+
       |           |
0xffee +-----------+ <- sp_{new}
       |           |
0xffee +-----------+
       | 0x00      |
0xffef +-----------+
       | 0x18      |
       +-----------+

結果的だが y レジスタには pshx でプッシュしたものが復元される.


	sty	*_.frame

これは test.elf の場合 _.frame = 0x10 なので

        *(uint16_t*)0x10 = y;

のような動きになる.

最後に rts 命令だが

0xffeb +-----------+
       |           |
0xffec +-----------+
       |           |
0xffee +-----------+ <- sp_{old}
       |           |
0xffee +-----------+
       | 0x00      |
0xffef +-----------+ <- sp_{old}
       | 0x18      |
       +-----------+

sp の指す領域から先頭要素をポップして
0x0018 にジャンプする.

