gcc-8.1.0 m68hc11-elf-gcc のインストール

% xz -d -c ../gcc-8.1.0.tar.xz | tar xf -
% mv gcc-8.1.0 gcc-8.1.0.m68hc11-elf
% cp -r gcc-{4.6.0,8.1.0}.m68hc11-elf/gcc/config/m68hc11
% cp constraints.md gcc-8.1.0.m68hc11-elf/gcc/config/m68hc11/constraints.md
% mkdir gcc-8.1.0.m68hc11-elf/gcc/common/config/m68hc11
% cp m68hc11-common.c gcc-8.1.0.m68hc11-elf/gcc/common/config/m68hc11/m68hc11-common.c
% cd gcc-8.1.0.m68hc11-elf
% patch -p1 < ../gcc-8.1.0.m68hc11-elf.diff
% find . -name 'Makefile.*' -exec ../erase_O2 {} \;
% find . -name 'configure' -exec ../erase_O2 {} \;
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=m68hc11-elf --with-newlib
% make all-gcc
% make maybe-configure-target-libgcc # error will occur but just ignore
% cp ../Makefile.empty m68hc11-elf/fshort-double/libgcc/Makefile
% make maybe-all-target-libgcc
...
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-8.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-8.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/sys-include    -g -O0 -m68hc11 -O0  -g -O0 -DIN_GCC  -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wno-narrowing -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition  -isystem ./include   -g -DIN_LIBGCC2 -fbuilding-libgcc -fno-stack-protector -Dinhibit_libc  -I. -I. -I../../../host-i686-pc-linux-gnu/gcc -I../../.././libgcc -I../../.././libgcc/. -I../../.././libgcc/../gcc -I../../.././libgcc/../include  -DHAVE_CC_TLS -DUSE_EMUTLS -o _divdi3.o -MT _divdi3.o -MD -MP -MF _divdi3.dep -DL_divdi3 -c ../../.././libgcc/libgcc2.c \
  -fexceptions -fnon-call-exceptions -fvisibility=hidden -DHIDE_EXPORTS
In file included from ../../../host-i686-pc-linux-gnu/gcc/tm.h:22,
                 from ../../.././libgcc/libgcc2.c:29:
../../.././libgcc/../gcc/config/m68hc11/m68hc11.h:894:36: 警告: ‘enum machine_mode’ declared inside parameter list will not be visible outside of this definition or declaration
 m68hc11_function_arg_padding (enum machine_mode mode, const_tree type);
                                    ^~~~~~~~~~~~
../../.././libgcc/libgcc2.c: 関数 ‘__divdi3’ 内:
../../.././libgcc/libgcc2.c:1250:1: エラー: unable to find a register to spill in class ‘D_REGS’
 }
 ^
../../.././libgcc/libgcc2.c:1250:1: エラー: this is the insn:
(insn 209 208 210 31 (parallel [
            (set (reg:SI 0 x)
                (reg:SI 1 d [223]))
            (clobber (scratch:HI))
        ]) "../../.././libgcc/libgcc2.c":1082 21 {movsi_internal}
     (expr_list:REG_DEAD (reg:SI 1 d [223])
        (nil)))
../../.././libgcc/libgcc2.c:1250: 前のエラーにより混乱していますので、脱出します
make[3]: *** [Makefile:535: _divdi3.o] エラー 1


エラーを再現する簡単なソースは以下:

typedef unsigned int UDItype __attribute__ ((mode (DI)));

typedef int SItype __attribute__ ((mode (SI)));

typedef unsigned int USItype __attribute__ ((mode (SI)));

struct DWstruct {SItype high, low;};

typedef unsigned int UQItype __attribute__ ((mode (QI)));

extern const UQItype __clz_tab[256];

typedef int DItype __attribute__ ((mode (DI)));

typedef union
{
  struct DWstruct s;
  DItype ll;
} DWunion;

UDItype
__udivmoddi4 (UDItype n, UDItype d, UDItype *rp)
{
  const DWunion nn = {.ll = n};
  const DWunion dd = {.ll = d};
  DWunion rr;
  USItype d0, d1, n0, n1, n2;
  USItype q0, q1;
  USItype b, bm;

  d0 = dd.s.low;
  d1 = dd.s.high;
  n0 = nn.s.low;
  n1 = nn.s.high;

  if (d1 == 0)
    {
      if (d0 > n1)
 {


   do { USItype __xr = (d0); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);

   if (bm != 0)
     {



       d0 = d0 << bm;
       n1 = (n1 << bm) | (n0 >> ((4 * 8) - bm));
       n0 = n0 << bm;
     }

   do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n1) % __d1; __q1 = (n1) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n0) = __r0; } while (0);
   q1 = 0;


 }
      else
 {


   if (d0 == 0)
     d0 = 1 / d0;

   do { USItype __xr = (d0); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);

   if (bm == 0)
     {







       n1 -= d0;
       q1 = 1;
     }
   else
     {


       b = (4 * 8) - bm;

       d0 = d0 << bm;
       n2 = n1 >> b;
       n1 = (n1 << bm) | (n0 >> b);
       n0 = n0 << bm;

       do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n2) % __d1; __q1 = (n2) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q1) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n1) = __r0; } while (0);
     }



   do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n1) % __d1; __q1 = (n1) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n0) = __r0; } while (0);


 }

      if (rp != 0)
 {
   rr.s.low = n0 >> bm;
   rr.s.high = 0;
   *rp = rr.ll;
 }
    }


  else
    {
      if (d1 > n1)
 {


   q0 = 0;
   q1 = 0;


   if (rp != 0)
     {
       rr.s.low = n0;
       rr.s.high = n1;
       *rp = rr.ll;
     }
 }
      else
 {


   do { USItype __xr = (d1); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);
   if (bm == 0)
     {
       if (n1 > d1 || n0 >= d0)
  {
    q0 = 1;
    do { USItype __x; __x = (n0) - (d0); (n1) = (n1) - (d1) - (__x > (n0)); (n0) = __x; } while (0);
  }
       else
  q0 = 0;

       q1 = 0;

       if (rp != 0)
  {
    rr.s.low = n0;
    rr.s.high = n1;
    *rp = rr.ll;
  }
     }
   else
     {
       USItype m1, m0;


       b = (4 * 8) - bm;

       d1 = (d1 << bm) | (d0 >> b);
       d0 = d0 << bm;
       n2 = n1 >> b;
       n1 = (n1 << bm) | (n0 >> b);
       n0 = n0 << bm;

       do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d1) >> ((4 * 8) / 2)); __d0 = ((USItype) (d1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n2) % __d1; __q1 = (n2) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d1); if (__r1 >= (d1)) if (__r1 < __m) __q1--, __r1 += (d1); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d1); if (__r0 >= (d1)) if (__r0 < __m) __q0--, __r0 += (d1); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n1) = __r0; } while (0);
       do { USItype __x0, __x1, __x2, __x3; USItype __ul, __vl, __uh, __vh; __ul = ((USItype) (q0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __uh = ((USItype) (q0) >> ((4 * 8) / 2)); __vl = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __vh = ((USItype) (d0) >> ((4 * 8) / 2)); __x0 = (USItype) __ul * __vl; __x1 = (USItype) __ul * __vh; __x2 = (USItype) __uh * __vl; __x3 = (USItype) __uh * __vh; __x1 += ((USItype) (__x0) >> ((4 * 8) / 2)); __x1 += __x2; if (__x1 < __x2) __x3 += ((USItype) 1 << ((4 * 8) / 2)); (m1) = __x3 + ((USItype) (__x1) >> ((4 * 8) / 2)); (m0) = ((USItype) (__x1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)) * ((USItype) 1 << ((4 * 8) / 2)) + ((USItype) (__x0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); } while (0);

       if (m1 > n1 || (m1 == n1 && m0 > n0))
  {
    q0--;
    do { USItype __x; __x = (m0) - (d0); (m1) = (m1) - (d1) - (__x > (m0)); (m0) = __x; } while (0);
  }

       q1 = 0;


       if (rp != 0)
  {
    do { USItype __x; __x = (n0) - (m0); (n1) = (n1) - (m1) - (__x > (n0)); (n0) = __x; } while (0);
    rr.s.low = (n1 << b) | (n0 >> bm);
    rr.s.high = n1 >> bm;
    *rp = rr.ll;
  }
     }
 }
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  return ww.ll;
}

DItype
__divdi3 (DItype u, DItype v)
{
  SItype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DItype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDItype *) 0);
  if (c)
    w = -w;

  return w;
}

gdb から実行してエラーを再現できている.

M-x gdb
gdb --annotate ./cc1
(gdb) run a.c

同じことを gcc-7.1.0 でやれば勿論正常終了している.
このエラーは以下の if の条件が成立して発生している:

gcc-8.1.0.m68hc11-elf/gcc/reload1.c
	if (! find_reg (chain, i))
	  {
	    if (dump_file)
	      fprintf (dump_file, "reload failure for reload %d\n", r);
	    spill_failure (chain->insn, rld[r].rclass);
	    failure = 1;
	    return;
	  }

上の部分は 129 回目の呼び出しでエラーしているらしい.

      if ((rld[r].out != 0 || rld[r].in != 0 || rld[r].secondary_p)
	  && ! rld[r].optional
	  && rld[r].regno == -1) {
	static int cnt;
	if (++cnt == 129)
	  asm("int3");                  ここで停止したら
	if (! find_reg (chain, i))      ここでエラーしている
	  {


エラーしているときは以下のようになっている.

(gdb) p debug_insn_slim(chain->insn)
  124: {x:SI=d:SI;clobber scratch;}
      REG_DEAD d:SI
$4 = void

同じことを gcc-7.1.0 で試してみたが, 129 回目の呼び出しで

(gdb) p debug_insn_slim(chain->insn)
  134: {[*sframe:HI+0x18]=*_.d1:SI;clobber scratch;}
      REG_DEAD *_.d1:SI
$1 = void
(gdb)

のようになっているので単純に比較することができない.

(gdb) b find_reload_regs
(gdb) command
> p debug_insn_slim(chain->insn)
> end
(gdb) run

のように find_reload_regs を観測ポイントにしてみた

% diff a.log /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-7.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/a.log

最初の意味のある差分は以下:

> $22 = void
> 
> Breakpoint 1, find_reload_regs (chain=0x93fb4e8) at ../.././gcc/reload1.c:1958
>    32: {[*sframe:HI+0xcc]=[*sframe:HI+0x4];clobber scratch;}
> $23 = void
> 
> Breakpoint 1, find_reload_regs (chain=0x93fb498) at ../.././gcc/reload1.c:1958
>    34: cc0=cmp([*sframe:HI+0xcc],0)
84,85c92,93
< Breakpoint 1, find_reload_regs (chain=0x965c218) at ../.././gcc/reload1.c:1958
<    32: {[*sframe:HI+0x68]=[*sframe:HI+0x4];clobber scratch;}

できている gcc-7.1.0 は

>    32: {[*sframe:HI+0xcc]=[*sframe:HI+0x4];clobber scratch;}
>    34: cc0=cmp([*sframe:HI+0xcc],0)

gcc-8.1.0 は

<    32: {[*sframe:HI+0x68]=[*sframe:HI+0x4];clobber scratch;}
<    34: cc0=cmp([*sframe:HI+0x68],0)

のように違いがでているが, 意味的に違いはなさそう.
しかし, オフセット 0xcc と 0x68 のように違いが出る理由が不明ではある.

この違いが出る理由を調べる価値はありそう.

gcc-8.1.0 では

(gdb) p debug_insn_slim((rtx_insn *) 0xb7999fc0)
   32: {[r49:HI+0x68]=[r49:HI+0x4];clobber scratch;}
$84 = void
(gdb)

のように生成される.
