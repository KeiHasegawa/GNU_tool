gcc-8.1.0 m68hc11-elf-gcc のインストール

% xz -d -c ../gcc-8.1.0.tar.xz | tar xf -
% mv gcc-8.1.0 gcc-8.1.0.m68hc11-elf
% cp -r gcc-{4.6.0,8.1.0}.m68hc11-elf/gcc/config/m68hc11
% cp constraints.md gcc-8.1.0.m68hc11-elf/gcc/config/m68hc11/constraints.md
% mkdir gcc-8.1.0.m68hc11-elf/gcc/common/config/m68hc11
% cp m68hc11-common.c gcc-8.1.0.m68hc11-elf/gcc/common/config/m68hc11/m68hc11-common.c
% cd gcc-8.1.0.m68hc11-elf
% patch -p1 < ../gcc-8.1.0.m68hc11-elf.diff
% find . -name 'Makefile.*' -exec ../erase_O2 {} \;
% find . -name 'configure' -exec ../erase_O2 {} \;
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=m68hc11-elf --with-newlib
% make all-gcc
% make maybe-configure-target-libgcc # error will occur but just ignore
% cp ../Makefile.empty m68hc11-elf/fshort-double/libgcc/Makefile
% make maybe-all-target-libgcc
...
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-8.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-8.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/m68hc11-elf/sys-include    -g -O0 -m68hc11 -O0  -g -O0 -DIN_GCC  -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wno-narrowing -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition  -isystem ./include   -g -DIN_LIBGCC2 -fbuilding-libgcc -fno-stack-protector -Dinhibit_libc  -I. -I. -I../../../host-i686-pc-linux-gnu/gcc -I../../.././libgcc -I../../.././libgcc/. -I../../.././libgcc/../gcc -I../../.././libgcc/../include  -DHAVE_CC_TLS -DUSE_EMUTLS -o _divdi3.o -MT _divdi3.o -MD -MP -MF _divdi3.dep -DL_divdi3 -c ../../.././libgcc/libgcc2.c \
  -fexceptions -fnon-call-exceptions -fvisibility=hidden -DHIDE_EXPORTS
In file included from ../../../host-i686-pc-linux-gnu/gcc/tm.h:22,
                 from ../../.././libgcc/libgcc2.c:29:
../../.././libgcc/../gcc/config/m68hc11/m68hc11.h:894:36: 警告: ‘enum machine_mode’ declared inside parameter list will not be visible outside of this definition or declaration
 m68hc11_function_arg_padding (enum machine_mode mode, const_tree type);
                                    ^~~~~~~~~~~~
../../.././libgcc/libgcc2.c: 関数 ‘__divdi3’ 内:
../../.././libgcc/libgcc2.c:1250:1: エラー: unable to find a register to spill in class ‘D_REGS’
 }
 ^
../../.././libgcc/libgcc2.c:1250:1: エラー: this is the insn:
(insn 209 208 210 31 (parallel [
            (set (reg:SI 0 x)
                (reg:SI 1 d [223]))
            (clobber (scratch:HI))
        ]) "../../.././libgcc/libgcc2.c":1082 21 {movsi_internal}
     (expr_list:REG_DEAD (reg:SI 1 d [223])
        (nil)))
../../.././libgcc/libgcc2.c:1250: 前のエラーにより混乱していますので、脱出します
make[3]: *** [Makefile:535: _divdi3.o] エラー 1


エラーを再現する簡単なソースは以下:

typedef unsigned int UDItype __attribute__ ((mode (DI)));

typedef int SItype __attribute__ ((mode (SI)));

typedef unsigned int USItype __attribute__ ((mode (SI)));

struct DWstruct {SItype high, low;};

typedef unsigned int UQItype __attribute__ ((mode (QI)));

extern const UQItype __clz_tab[256];

typedef int DItype __attribute__ ((mode (DI)));

typedef union
{
  struct DWstruct s;
  DItype ll;
} DWunion;

UDItype
__udivmoddi4 (UDItype n, UDItype d, UDItype *rp)
{
  const DWunion nn = {.ll = n};
  const DWunion dd = {.ll = d};
  DWunion rr;
  USItype d0, d1, n0, n1, n2;
  USItype q0, q1;
  USItype b, bm;

  d0 = dd.s.low;
  d1 = dd.s.high;
  n0 = nn.s.low;
  n1 = nn.s.high;

  if (d1 == 0)
    {
      if (d0 > n1)
 {


   do { USItype __xr = (d0); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);

   if (bm != 0)
     {



       d0 = d0 << bm;
       n1 = (n1 << bm) | (n0 >> ((4 * 8) - bm));
       n0 = n0 << bm;
     }

   do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n1) % __d1; __q1 = (n1) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n0) = __r0; } while (0);
   q1 = 0;


 }
      else
 {


   if (d0 == 0)
     d0 = 1 / d0;

   do { USItype __xr = (d0); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);

   if (bm == 0)
     {







       n1 -= d0;
       q1 = 1;
     }
   else
     {


       b = (4 * 8) - bm;

       d0 = d0 << bm;
       n2 = n1 >> b;
       n1 = (n1 << bm) | (n0 >> b);
       n0 = n0 << bm;

       do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n2) % __d1; __q1 = (n2) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q1) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n1) = __r0; } while (0);
     }



   do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d0) >> ((4 * 8) / 2)); __d0 = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n1) % __d1; __q1 = (n1) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d0); if (__r1 >= (d0)) if (__r1 < __m) __q1--, __r1 += (d0); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d0); if (__r0 >= (d0)) if (__r0 < __m) __q0--, __r0 += (d0); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n0) = __r0; } while (0);


 }

      if (rp != 0)
 {
   rr.s.low = n0 >> bm;
   rr.s.high = 0;
   *rp = rr.ll;
 }
    }


  else
    {
      if (d1 > n1)
 {


   q0 = 0;
   q1 = 0;


   if (rp != 0)
     {
       rr.s.low = n0;
       rr.s.high = n1;
       *rp = rr.ll;
     }
 }
      else
 {


   do { USItype __xr = (d1); USItype __a; if ((4 * 8) <= 32) { __a = __xr < ((USItype)1<<2*((4 * 8) / 4)) ? (__xr < ((USItype)1<<((4 * 8) / 4)) ? 0 : ((4 * 8) / 4)) : (__xr < ((USItype)1<<3*((4 * 8) / 4)) ? 2*((4 * 8) / 4) : 3*((4 * 8) / 4)); } else { for (__a = (4 * 8) - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) break; } (bm) = (4 * 8) - (__clz_tab[__xr >> __a] + __a); } while (0);
   if (bm == 0)
     {
       if (n1 > d1 || n0 >= d0)
  {
    q0 = 1;
    do { USItype __x; __x = (n0) - (d0); (n1) = (n1) - (d1) - (__x > (n0)); (n0) = __x; } while (0);
  }
       else
  q0 = 0;

       q1 = 0;

       if (rp != 0)
  {
    rr.s.low = n0;
    rr.s.high = n1;
    *rp = rr.ll;
  }
     }
   else
     {
       USItype m1, m0;


       b = (4 * 8) - bm;

       d1 = (d1 << bm) | (d0 >> b);
       d0 = d0 << bm;
       n2 = n1 >> b;
       n1 = (n1 << bm) | (n0 >> b);
       n0 = n0 << bm;

       do { USItype __d1, __d0, __q1, __q0; USItype __r1, __r0, __m; __d1 = ((USItype) (d1) >> ((4 * 8) / 2)); __d0 = ((USItype) (d1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __r1 = (n2) % __d1; __q1 = (n2) / __d1; __m = (USItype) __q1 * __d0; __r1 = __r1 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) >> ((4 * 8) / 2)); if (__r1 < __m) { __q1--, __r1 += (d1); if (__r1 >= (d1)) if (__r1 < __m) __q1--, __r1 += (d1); } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (USItype) __q0 * __d0; __r0 = __r0 * ((USItype) 1 << ((4 * 8) / 2)) | ((USItype) (n1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); if (__r0 < __m) { __q0--, __r0 += (d1); if (__r0 >= (d1)) if (__r0 < __m) __q0--, __r0 += (d1); } __r0 -= __m; (q0) = (USItype) __q1 * ((USItype) 1 << ((4 * 8) / 2)) | __q0; (n1) = __r0; } while (0);
       do { USItype __x0, __x1, __x2, __x3; USItype __ul, __vl, __uh, __vh; __ul = ((USItype) (q0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __uh = ((USItype) (q0) >> ((4 * 8) / 2)); __vl = ((USItype) (d0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); __vh = ((USItype) (d0) >> ((4 * 8) / 2)); __x0 = (USItype) __ul * __vl; __x1 = (USItype) __ul * __vh; __x2 = (USItype) __uh * __vl; __x3 = (USItype) __uh * __vh; __x1 += ((USItype) (__x0) >> ((4 * 8) / 2)); __x1 += __x2; if (__x1 < __x2) __x3 += ((USItype) 1 << ((4 * 8) / 2)); (m1) = __x3 + ((USItype) (__x1) >> ((4 * 8) / 2)); (m0) = ((USItype) (__x1) & (((USItype) 1 << ((4 * 8) / 2)) - 1)) * ((USItype) 1 << ((4 * 8) / 2)) + ((USItype) (__x0) & (((USItype) 1 << ((4 * 8) / 2)) - 1)); } while (0);

       if (m1 > n1 || (m1 == n1 && m0 > n0))
  {
    q0--;
    do { USItype __x; __x = (m0) - (d0); (m1) = (m1) - (d1) - (__x > (m0)); (m0) = __x; } while (0);
  }

       q1 = 0;


       if (rp != 0)
  {
    do { USItype __x; __x = (n0) - (m0); (n1) = (n1) - (m1) - (__x > (n0)); (n0) = __x; } while (0);
    rr.s.low = (n1 << b) | (n0 >> bm);
    rr.s.high = n1 >> bm;
    *rp = rr.ll;
  }
     }
 }
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  return ww.ll;
}

gdb から実行してエラーを再現できている.

M-x gdb
gdb --annotate ./cc1
(gdb) run a.c

同じことを gcc-7.1.0 でやれば勿論正常終了している.
このエラーは以下の if の条件が成立して発生している:

gcc-8.1.0.m68hc11-elf/gcc/reload1.c
	if (! find_reg (chain, i))
	  {
	    if (dump_file)
	      fprintf (dump_file, "reload failure for reload %d\n", r);
	    spill_failure (chain->insn, rld[r].rclass);
	    failure = 1;
	    return;
	  }

上の部分は 129 回目の呼び出しでエラーしているらしい.

      if ((rld[r].out != 0 || rld[r].in != 0 || rld[r].secondary_p)
	  && ! rld[r].optional
	  && rld[r].regno == -1) {
	static int cnt;
	if (++cnt == 129)
	  asm("int3");                  ここで停止したら
	if (! find_reg (chain, i))      ここでエラーしている
	  {


エラーしているときは以下のようになっている.

(gdb) p debug_insn_slim(chain->insn)
  124: {x:SI=d:SI;clobber scratch;}
      REG_DEAD d:SI
$4 = void

同じことを gcc-7.1.0 で試してみたが, 129 回目の呼び出しで

(gdb) p debug_insn_slim(chain->insn)
  134: {[*sframe:HI+0x18]=*_.d1:SI;clobber scratch;}
      REG_DEAD *_.d1:SI
$1 = void
(gdb)

のようになっているので単純に比較することができない.

% cat xx
b find_reload_regs
command
silent
p debug_insn_slim(chain->insn)
c
end
%

(gdb) source xx
(gdb) run -quiet a.c

のように find_reload_regs を観測ポイントにしてみた

% diff /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-{8,7}.1.0.m68hc11-elf/host-i686-pc-linux-gnu/gcc/b.log

最初の意味のある差分は以下:

<    32: {[*sframe:HI+0x68]=[*sframe:HI+0x4];clobber scratch;}
---
>    32: {[*sframe:HI+0xcc]=[*sframe:HI+0x4];clobber scratch;}
49c49
<    34: cc0=cmp([*sframe:HI+0x68],0)
---
>    34: cc0=cmp([*sframe:HI+0xcc],0)

gcc-8.1.0 ではオフセット 0x68 だが
gcc-7.1.0 ではオフセット 0xcc になっている.
これ自体はオフセットが異なっているだけだから問題なさそうだが, なぜ差分が出ているかは不明.

また以下のように差分が出ている.

<    82: {d:SI=[*sframe:HI+0x68];clobber scratch;}
---
>    82: {*_.d1:SI=[*sframe:HI+0xcc];clobber scratch;}

gcc-8.1.0 では d:SI だが
gcc-7.1.0 では *_.d1:SI なので
おそらくこれは何かが異なっている.

まずは最初のオフセットでなぜ違いが出るのかを確認したい. もしそれが問題ないならば
2 つ目の d:SI と *_.d1:SI との違いがなぜ出るかを確認したい.

gcc-8.1.0 で
32: {[*sframe:HI+0x68]=[*sframe:HI+0x4];clobber scratch;}
が生成される瞬間を捉える. この命令は

(rtx_insn *) 0xb7997dec

に配置されている. このアドレスにウォッチポイントをセットしてみた.

insn-emit.c
rtx
gen_movsi (rtx operand0,
	rtx operand1)
{
...
  emit (gen_rtx_PARALLEL (VOIDmode,
	gen_rtvec (2,
		gen_rtx_SET (operand0,
	operand1),
		gen_rtx_CLOBBER (VOIDmode,
	gen_rtx_SCRATCH (HImode)))), false);  ここで生成していた

おそらく operand0 が [*sframe:HI+0x68] で
operand1 が [*sframe:HI+0x4] らしい.

gen_movsi は以下の部分から結果的に呼び出されている.

expr.c
  last_insn = emit_move_insn_1 (x, y);

そしてこれは gcc-7.1.0 でも同じであった.

% cat yy
b emit_move_insn
command
if (x!=0xb79a9b50 || y!=0xb79a9b70)     # gcc-8.1.0 の場合
c
end
end

(gdb) source yy
(gdb) run
...
emit_mov_insn で停止

emit_move_insn_1 (x, y)

の呼び出しまでどの条件も成立していない. これは gcc-7.1.0 でも同じ状況.

% cat zz
b expand_assignment
command
if (to!=0xb799d9d8 || from!=0xb799d938)     # gcc-8.1.0 の場合
c
end
end

(gdb) source zz
(gdb) run

expand_assignment で停止.

  result = store_expr_with_bounds (from, to_rtx, 0, nontemporal, false, to);

の呼び出しで問題の rtx_insn* を生成している.
問題の (rtx)0xb79a9b50 は

  to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);

で生成されている.

expand_assignment に渡された to に対して

gcc-8.1.0 では
(gdb) p debug_tree(to)
 <ssa_name 0xb799d9d8
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e498 __xr>
    def_stmt __xr_145 = d0_141;
    version:145>
$17 = void
(gdb)

gcc-7.1.0 では
(gdb) p debug_tree(to)
 <ssa_name 0xb799d708
    type <integer_type 0xb7966540 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e558c constant 32>
        unit size <integer_cst 0xb78e55a0 constant 4>
        align 8 symtab 0 alias set -1 canonical type 0xb7ae1420 precision 32 min <integer_cst 0xb78e5744 0> max <integer_cst 0xb78e5730 4294967295> context <translation_unit_decl 0xb797b1c8 a.c>>
    var <var_decl 0xb7978498 __xr>
    def_stmt __xr_282 = d0_141;
    version 282>
$3 = void
(gdb)

ここでは明確な違いが出ていないと判断した. ということは

  to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);

に対して
gcc-8.1.0 では [*sframe:HI+0x68] が生成されていて
gcc-7.1.0 では [*sframe:HI+0xcc] が生成されているということになる.

再現させるソースに

    USItype __xr = ...

という宣言がいくつかあるがおそらくこれのいずれか.

expand_expr が
gcc-8.1.0 だと 0xb799d9d8 で呼び出されたとき
gcc-7.1.0 だと 0xb799d708 で呼び出されたときで比較してみる.



      exp = SSA_NAME_VAR (ssa_name);

これを実行したとき

gcc-8.1.0
(gdb) p debug_tree(exp)
 <var_decl 0xb797e498 __xr
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    unsigned read SI a.c:42:17 size <integer_cst 0xb78e65a0 32> unit-size <integer_cst 0xb78e65b4 4>
    align:8 warn_if_not_align:0 context <function_decl 0xb796d380 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 104 [0x68])) [1 __xr+0 S4 A8]) chain <var_decl 0xb797e4ec __a>>

gcc-7.1.0
(gdb) p debug_tree(exp)
 <var_decl 0xb7978498 __xr
    type <integer_type 0xb7966540 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e558c constant 32>
        unit size <integer_cst 0xb78e55a0 constant 4>
        align 8 symtab 0 alias set -1 canonical type 0xb7ae1420 precision 32 min <integer_cst 0xb78e5744 0> max <integer_cst 0xb78e5730 4294967295> context <translation_unit_decl 0xb797b1c8 a.c>>
    unsigned SI file a.c line 42 col 17 size <integer_cst 0xb78e558c 32> unit size <integer_cst 0xb78e55a0 4>
    align 8 context <function_decl 0xb7965580 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 204 [0xcc])) [1 __xr+0 S4 A8]) chain <var_decl 0xb79784ec __a>>

0x68 と 0xcc とで違いが出ている.

SSA_NAME_VAR はマクロ展開されて結局

ssa_name->ssa_name.var

である. ということは expand_assignment にきた時点で

(gdb) p debug_tree(to->ssa_name.var)

とすれば gcc-8.1.0 と gcc-7.1.0 とで違いがすでに出ていたわけだ.

% cat zz2
b expand_gimple_stmt_1
command
if (stmt!=0xb7984750)           # gcc-8.1.0 の場合
c
end
end

このブレークポイントで停止したとき

	tree lhs = gimple_assign_lhs (assign_stmt);

で問題の 0x68 のオフセットになっている.

(gdb) p debug_tree(lhs->ssa_name.var)
 <var_decl 0xb797e498 __xr
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    unsigned read SI a.c:42:17 size <integer_cst 0xb78e65a0 32> unit-size <integer_cst 0xb78e65b4 4>
    align:8 warn_if_not_align:0 context <function_decl 0xb796d380 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 104 [0x68])) [1 __xr+0 S4 A8]) chain <var_decl 0xb797e4ec __a>>
$4 = void
(gdb)

同じことを gcc-7.1.0 で行なった:

% cat zz2
b expand_gimple_stmt_1
command
if (stmt!=0xb7980630)      # gcc-7.1.0 の場合
c
end
end

(gdb) p debug_tree(lhs->ssa_name.var)
 <var_decl 0xb7978498 __xr
    type <integer_type 0xb7966540 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e558c constant 32>
        unit size <integer_cst 0xb78e55a0 constant 4>
        align 8 symtab 0 alias set -1 canonical type 0xb7ae1420 precision 32 min <integer_cst 0xb78e5744 0> max <integer_cst 0xb78e5730 4294967295> context <translation_unit_decl 0xb797b1c8 a.c>>
    unsigned SI file a.c line 42 col 17 size <integer_cst 0xb78e558c 32> unit size <integer_cst 0xb78e55a0 4>
    align 8 context <function_decl 0xb7965580 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 204 [0xcc])) [1 __xr+0 S4 A8]) chain <var_decl 0xb79784ec __a>>
$1 = void
(gdb)

ということは gimple* stmt が作成された時点で既に違いがあったわけだ.

gcc-8.1.0 の場合
(gdb) p debug_gimple_stmt(stmt)
__xr_145 = d0_141;

(gdb) p debug_tree(((gassign*)stmt)->op[0]->ssa_name.var)
 <var_decl 0xb797e498 __xr
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    unsigned read SI a.c:42:17 size <integer_cst 0xb78e65a0 32> unit-size <integer_cst 0xb78e65b4 4>
    align:8 warn_if_not_align:0 context <function_decl 0xb796d380 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 104 [0x68])) [1 __xr+0 S4 A8]) chain <var_decl 0xb797e4ec __a>>
$11 = void

$5 = void

gcc-7.1.0 の場合
(gdb) p debug_gimple_stmt(stmt)
__xr_282 = d0_141;
$2 = void
(gdb) p debug_tree(((gassign*)stmt)->op[0]->ssa_name.var)
 <var_decl 0xb7978498 __xr
    type <integer_type 0xb7966540 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e558c constant 32>
        unit size <integer_cst 0xb78e55a0 constant 4>
        align 8 symtab 0 alias set -1 canonical type 0xb7ae1420 precision 32 min <integer_cst 0xb78e5744 0> max <integer_cst 0xb78e5730 4294967295> context <translation_unit_decl 0xb797b1c8 a.c>>
    unsigned SI file a.c line 42 col 17 size <integer_cst 0xb78e558c 32> unit size <integer_cst 0xb78e55a0 4>
    align 8 context <function_decl 0xb7965580 __udivmoddi4>
    (mem/c:SI (plus:HI (reg/f:HI 49 virtual-stack-vars)
        (const_int 204 [0xcc])) [1 __xr+0 S4 A8]) chain <var_decl 0xb79784ec __a>>
$3 = void

そもそもこの tree が作成されるタイミングを捉える.


gcc-8.1.0 では

Hardware watchpoint 15: *(int*)0xb79a6e68

に 108 をセットしていた:

static inline rtx
gen_rtx_fmt_w_stat (RTX_CODE code, machine_mode mode,
	HOST_WIDE_INT arg0 MEM_STAT_DECL)
{
  rtx rt;
  rt = rtx_alloc (code PASS_MEM_STAT);

  PUT_MODE_RAW (rt, mode);
  XWINT (rt, 0) = arg0;          ここで 108 をセットしていた

  return rt;
}

そしてそれは以下から呼び出されていた:

static void
expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,
			 poly_int64 offset)
{
  unsigned align;
  rtx x;

  /* If this fails, we've overflowed the stack frame.  Error nicely?  */
  gcc_assert (known_eq (offset, trunc_int_for_mode (offset, Pmode)));

  x = plus_constant (Pmode, base, offset);

函数の名前もそれっぽい. offset.coeffs[0] = 104 になっている.

以下のようにすれば offset = 104 の計算の瞬間を捉えられる:

static void
expand_one_stack_var_1 (tree var)
{
...
  if (var == (tree) 0xb799d9d8)         # gcc-8.1.0 の場合
    asm("int3");
  offset = alloc_stack_frame_space (size, byte_align);

  expand_one_stack_var_at (var, virtual_stack_vars_rtx,
			   crtl->max_used_stack_slot_alignment, offset);


gcc-7.1.0 の場合は

  if (var == (tree) 0xb799d708)
    asm("int3");

とすれば offset = 204 の計算の瞬間を捉えられる.

#define frame_offset (crtl->x_frame_offset)

だが

gcc-8.1.0 の場合 104
gcc-7.1.0 の場合 204

なので結果的に違いが出ている. crtl->x_frame_offset にウォッチポイントをセットしたところ

gcc-8.1.0 の場合:
(gdb) watch *(int*)0x93e0838
0 -> 4 -> 8 -> ... -> 104 のように増加している.

gcc-7.1.0 の場合
(gdb) watch *(int*)0x9196ae4
0 -> 4 -> 8 -> ... -> 204 のように増加している.

原因はこれだけだと不明だが, 本来ローカル変数としてスケジューリングされるべきものがされていないの
ならば問題がある.

  debug_tree(var);
  offset = alloc_stack_frame_space (size, byte_align);

  expand_one_stack_var_at (var, virtual_stack_vars_rtx,
			   crtl->max_used_stack_slot_alignment, offset);

のようにして var をダンプしてみた. そして gcc-8.1.0 と gcc-7.1.0 との結果を比較してみた.

gcc-7.1.0 では

 <ssa_name 0xb799c2f8
    type <integer_type 0xb7966540 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e558c constant 32>
        unit size <integer_cst 0xb78e55a0 constant 4>
        align 8 symtab 0 alias set -1 canonical type 0xb7ae1420 precision 32 min <integer_cst 0xb78e5744 0> max <integer_cst 0xb78e5730 4294967295> context <translation_unit_decl 0xb797b1c8 a.c>>
    var <var_decl 0xb79783f0 b>
    def_stmt b_154 = 32 - bm_153;
    version 154>

のように version 154 のものがあるのに対して gcc-8.1.0 では 154 に対してこれが
ない. これが最初の違う点.

だからまずは 154 に対してなぜ gcc-8.1.0 でスタックが割り当てられていないかを調べてみる.

gcc-8.1.0 の場合
  if (var == (tree) 0xb799daf0)
    asm("int3");

とすれば version 152 に対して止めることができている. この次の b_154 に対して
ローカル変数が割り当てられない原因を調べたい.

expand_one_stak_var_1 は以下から呼び出されている:

expand_one_ssa_partition(tree var)
{
...
  if (!use_register_for_decl (var))
    {
      if (defer_stack_allocation (var, true))
	add_stack_var (var);
      else
	expand_one_stack_var_1 (var);
      return;
    }

version 152 に対して止めた後 if の行にブレークポイントをセットして, そこで
停止したときに var を表示してみた:

(gdb) p debug_tree(var)
 <ssa_name 0xb799dbb8
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e63c __d1>
    def_stmt __d1_157 = d0_47 >> 16;
    version:157>
$1 = void

この時点ですでに 154 はおそらくローカル変数が割り当てられていない.
expand_one_ssa_partition は以下から呼び出されている.

  for (i = 0; i < SA.map->num_partitions; i++)
    {
      if (bitmap_bit_p (SA.partitions_for_parm_default_defs, i))
	continue;

      tree var = partition_to_var (SA.map, i);

      gcc_assert (!virtual_operand_p (var));

      expand_one_ssa_partition (var);
    }

version 152 が処理された後, 次のループで var は version 157 のものになっている.
ということはすでにこの時点で 154 はローカル変数の対象になっていない.

version 152 の (tree)0xb799daf0 が生成されるのはどのタイミングか調べてみた.

tree-ssanames.c

tree
make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,
		  unsigned int version)
{
...
      t = make_node (SSA_NAME);
      SSA_NAME_VERSION (t) = SSANAMES (fn)->length ();
      vec_safe_push (SSANAMES (fn), t);
      ssa_name_nodes_created++;

version 152 はここでセットされている. そして 153, 154 もここ.
ということは 152 の tree が SA.map に入っているのに対して
154 の tree が SA.map に入っていない原因を調べることになる.

static void
remove_ssa_form (bool perform_ter, struct ssaexpand *sa)
{
...
  sa->map = map;

SA.map に値がセットされるのはこのタイミング. そしてこの時点で

(gdb) p debug_tree(partition_to_var (SA.map, 117))
 <ssa_name 0xb799daf0
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e4ec __a>
    def_stmt __a_152 = iftmp.2_123;
    version:152>
$42 = void
(gdb) p debug_tree(partition_to_var (SA.map, 118))
 <ssa_name 0xb799dbb8
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e63c __d1>
    def_stmt __d1_157 = d0_47 >> 16;
    version:157>
$43 = void

のようになっている.

static void
remove_ssa_form (bool perform_ter, struct ssaexpand *sa)
{
  bitmap values = NULL;
  var_map map;

  map = coalesce_ssa_name ();

  /* Return to viewing the variable list as just all reference variables after
     coalescing has been performed.  */
  partition_view_normal (map);

この呼び出しの後に

(gdb) p debug_tree(partition_to_var (map, 117)) 
 <ssa_name 0xb799daf0
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e4ec __a>
    def_stmt __a_152 = iftmp.2_123;
    version:152>
$51 = void
(gdb) p debug_tree(partition_to_var (map, 118)) 
 <ssa_name 0xb799dbb8
    type <integer_type 0xb795a960 USItype sizes-gimplified public unsigned SI
        size <integer_cst 0xb78e65a0 constant 32>
        unit-size <integer_cst 0xb78e65b4 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7ae1420 precision:32 min <integer_cst 0xb78e6758 0> max <integer_cst 0xb78e6744 4294967295> context <translation_unit_decl 0xb79821c8 a.c>>
    var <var_decl 0xb797e63c __d1>
    def_stmt __d1_157 = d0_47 >> 16;
    version:157>
$52 = void

のようになっている.

とここまで解析してみたが

gcc-8.1.0

__a_152 = iftmp.2_123;
__d1_157 = d0_47 >> 16;
__d0_158 = d0_47 & 65535;

gcc-7.1.0

__a_152 = iftmp.2_123;
b_154 = 32 - bm_153;
n2_157 = n1_144 >> b_154;
__d1_160 = d1_155 >> 16;
__d0_161 = d1_155 & 65535;


のような違いある. そしてこれは gcc-8.1.0.arm-elf と gcc-7.1.0.arm-elf とでも
似たような差分が出ている.

というわけで以下の差分

<    32: {[*sframe:HI+0x68]=[*sframe:HI+0x4];clobber scratch;}
---
>    32: {[*sframe:HI+0xcc]=[*sframe:HI+0x4];clobber scratch;}
49c49
<    34: cc0=cmp([*sframe:HI+0x68],0)
---
>    34: cc0=cmp([*sframe:HI+0xcc],0)

はとりあえず無視して良さそう.
gcc-8.1.0.jp の続き

% cat xx
b find_reload_regs
command
silent
p debug_insn_slim(chain->insn)
c
end
%

(gdb) source xx
(gdb) run -quiet a.c

ここで a.c は再現させる簡単なソース(gcc-8.1.0.jp 参照)

gcc-7.1.0 との差分

<    82: {d:SI=[*sframe:HI+0x68];clobber scratch;}         gcc-8.1.0
---
>    82: {*_.d1:SI=[*sframe:HI+0xcc];clobber scratch;}     gcc-7.1.0

がなぜ出るのか調査する. ここで 0x68 と 0xcc との差分は無視して

d:SI           gcc-8.1.0
*_.d1:SI       gcc-7.1.0

の差分に着目する.
まず gcc-8.1.0 で (rtx_insn *) 0xb79ac1d4 がどのタイミングで生成されているかを調べ
てみる.

insn-emit.c から #line の行を削除することでデバッグしやすくなる.


/* ../.././gcc/config/m68hc11/m68hc11.md:5280 */
rtx
gen_lshrsi3 (rtx operand0,
	rtx operand1,
	rtx operand2)
{
  rtx_insn *_val = 0;
  start_sequence ();
  emit (gen_rtx_PARALLEL (VOIDmode,              ここで生成されていた
	gen_rtvec (2,
		gen_rtx_SET (operand0,
	operand1),
		gen_rtx_CLOBBER (VOIDmode,
	gen_rtx_SCRATCH (HImode)))), true);

生成された直後は

(gdb) p debug_insn_slim((rtx_insn *) 0xb79ac1d4)
   82: {r60:SI=[r49:HI+0x68];clobber scratch;}

のようになっていた.

同様のことを gcc-7.1.0 で調べてみた. (rtx_insn *) 0xb79a61b0 がどこで
生成されるか調べたところ gcc-8.1.0 と同じで, 生成された直後は

(gdb) p debug_insn_slim((rtx_insn *) 0xb79a61b0)
   82: {r60:SI=[r49:HI+0xcc];clobber scratch;}

のようになっている. r60 の 60 は以下のようにしてアクセスできる

(gdb) p REGNO(SET_DEST(XVECEXP(PATTERN((rtx_insn*)0xb79ac1d4),0,0)))
$324 = 60

(gdb) p &REG_CHECK(SET_DEST(XVECEXP(PATTERN((rtx_insn*)0xb79ac1d4),0,0)))->regno
$20 = (unsigned int *) 0xb79a72d8

なのでここにウォッチポイントを置いてみる. 60 -> 1 に書き替えられていた:

static void
alter_reg (int i, int from_reg, bool dont_share_p)
{
...
  /* Modify the reg-rtx to contain the new hard reg
     number or else to contain its pseudo reg number.  */
  SET_REGNO (regno_reg_rtx[i],
	     reg_renumber[i] >= 0 ? reg_renumber[i] : i);

同じことを gcc-7.1.0 でも確かめてみた

(gdb) p REGNO(SET_DEST(XVECEXP(PATTERN((rtx_insn*)0xb79a61b0),0,0)))
$5796 = 60
(gdb) p &REG_CHECK(SET_DEST(XVECEXP(PATTERN((rtx_insn*)0xb79a61b0),0,0)))->regno
$5797 = (unsigned int *) 0xb799f274

そしてここをウォッチしてみたところ 60 -> 14 に書き替えられていた.

D_REGS = 1
A_REGS = 14 /* 16-bit address register (X, Y, Z) */

というわけだ. なので明らかにまずそう.

reg_renumber[60] の期待値が 14 にならない原因を調査する.

(gdb) p &reg_renumber[60]
$23 = (short *) 0x95cccc0

なのでここをウォッチしてみる.


static void
setup_reg_renumber (void)
{
...
      hard_regno = ALLOCNO_HARD_REGNO (a);
      regno = ALLOCNO_REGNO (a);
      reg_renumber[regno] = (hard_regno < 0 ? -1 : hard_regno);

ここで reg_renumber[60] を 1 にセットしている.
同じことを gcc-7.1.0 でも試してみる. 動作は同じだが reg_renumber[60]
を 14 にセットしている.

ということは... ALLOCNO_HARD_REGNO が問題. これはマクロで単純に
ALLOCNO_HARD_REGNO (a) は a->hard_regno に展開される.

&a->hard_regno のアドレスをウォッチしてみたところ

ira-color.c:

static void
fast_allocation (void)
{
...
	  ALLOCNO_HARD_REGNO (a) = hard_regno;  ここでセットしている.


この函数の最初の呼び出しで gcc-8.1.0 では hard_regno = 1 として
gcc-7.1.0 では hard_regno = 14 として書き込んでいる.


gcc-8.1.0 ではこうすることでその書き替えの瞬間を捉えられている:
	  if (a == (ira_allocno_t) 0x95d6c78)
	    asm("int3");
	  ALLOCNO_HARD_REGNO (a) = hard_regno;  ここでセットしている.


gcc-7.1.0 では以下:
	  if (a == (ira_allocno_t) 0x93861d8)
	    asm("int3");
	  ALLOCNO_HARD_REGNO (a) = hard_regno;


hard_regno はこのすぐ上の行で計算されていて short [36][48] の型をもつ

default_target_ira.x_ira_class_hard_regs[][]

から計算されている.

gcc-8.1.0 で aclass = G_REGS j = 0 で hard_regno = 1  と算出されている.
gcc-7.1.0 で aclass = S_REGS j = 0 で hard_regno = 14 と算出されている.

ggcc-8.1.0 で 
default_target_ira.x_ira_class_hard_regs[S_REGS][0] = 14
になっているから aclass の計算を間違えているらしい. 期待値は S_REGS.


aclass = ALLOCNO_CLASS (a);  // aclass = a->aclass

のように計算されるようである. だから

gcc-8.1.0 ならば
((ira_allocno_t) 0x95d6c78)->aclass
がどこで計算されているかを調査する. 現状は G_REGS だが S_REGS が期待値.
gcc-7.1.0 ならば
((ira_allocno_t) 0x93861d8)->aclass



void
ira_set_allocno_class (ira_allocno_t a, enum reg_class aclass)
{
  ira_allocno_object_iterator oi;
  ira_object_t obj;

  ALLOCNO_CLASS (a) = aclass;  ここで gcc-8.1.0 では G_REGS をセットしていた.

そして上は以下から呼び出されていた:

  FOR_EACH_ALLOCNO (a, ai)
    {
      i = ALLOCNO_NUM (a);
      regno = ALLOCNO_REGNO (a);
      aclass = regno_aclass[regno];                         ここで aclass を計算
      cost_classes_ptr = regno_cost_classes[regno];
      ira_assert (pref[i] == NO_REGS || aclass != NO_REGS);
      ALLOCNO_MEMORY_COST (a) = COSTS (costs, i)->mem_cost;
      ira_set_allocno_class (a, aclass);

上の regno は 60 だった. これは期待通り.

regno_aclass[60] に値をセットしているのは以下:

	  if ((new_class
	       = (reg_class) (targetm.ira_change_pseudo_allocno_class
			      (i, regno_aclass[i], best))) != regno_aclass[i])


(gdb) p targetm.ira_change_pseudo_allocno_class
$31 = (reg_class_t (*)(int, reg_class_t, reg_class_t)) 0x891df1b
     <default_ira_change_pseudo_allocno_class(int, int, int)>

これは gcc-8.1.0 でも gcc-7.1.0 でも同じ. しかし戻り値が異なっているということか.
同様のことを gcc-7.1.0 で行なってみたところ

regno_aclass[60] に値をセットしているのは以下:

	    regno_aclass[i] = ira_allocno_class_translate[best];

gcc-8.1.0 と動作が明らかに異なっている.

gcc-7.1.0 では

	  else if (!optimize && !targetm.class_likely_spilled_p (best))

の条件が成立していた. best = S_REGS で呼び出されている. 一方 gcc-8.1.0 では
best = D_OR_X_REGS で呼び出されている. これが動作の違いが出ている原因.

ira-costs.c:

static void
find_costs_and_classes (FILE *dump_file)
{
...
	  for (k = 0; k < cost_classes_ptr->num; k++)

gcc-8.1.0 では cost_classes_ptr->num = 12 であるのに対して
gcc-7.1.0 では cost_classes_ptr->num = 3


	  cost_classes_t cost_classes_ptr = regno_cost_classes[i];
	  if (i == 60)
	    asm("int3");

ここで停止して

gcc-8.1.0 
(gdb) p *cost_classes_ptr
$41 = {num = 12, classes = {D_REGS, X_REGS, D_OR_X_REGS, A_REGS, A_OR_D_REGS, 
    S_REGS, D_OR_S_REGS, X_OR_S_REGS, Z_OR_S_REGS, D_OR_X_OR_S_REGS, 
    A_OR_S_REGS, G_REGS, NO_REGS <repeats 24 times>}, index = {-1, -1, -1, 
    -1, -1, -1, -1, -1, -1, -1, 2, 0, 0, 1, 3, 1, -1, 2, 4, 3, 4, 5, 6, 7, 5, 
    8, 5, 9, 6, 6, 10, 11, -1, 4, 11, 11}, hard_regno_index = {1, 0, 3, -1, 
    -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, 5, 5, 5, 5, -1 <repeats 30 times>}}

gcc-7.1.0
(gdb) p *cost_classes_ptr
$21 = {num = 3, classes = {X_REGS, S_REGS, X_OR_S_REGS, 153851272, 153851336, 
    153851408, 153918936, 153919016, 153919064, 153919136, 153919208, 
    153127200, 153127144, 153851480, 153918440, 153126976, 153918520, 
    153126864, 153918568, 153918616, 153918664, 153850264, 153933840, 
    153933800, 153126528, 1032, 1032, NO_REGS, NO_REGS, NO_REGS, NO_REGS, 
    NO_REGS, NO_REGS, NO_REGS, NO_REGS, NO_REGS}, index = {-1, -1, -1, -1, 
    -1, -1, -1, -1, -1, -1, 0, -1, -1, 0, 0, 0, -1, 0, 0, 0, 0, 1, 1, 2, 1, 
    1, 1, 2, 1, 1, 2, 2, -1, 0, 2, 2}, hard_regno_index = {0, 
    -1 <repeats 13 times>, 1, 1, 1, 1, -1 <repeats 30 times>}}

このように違いが出ている.

(gdb) p &regno_cost_classes[60]->num
$43 = (int *) 0x9612660

このアドレスをウォッチしてみた:

static cost_classes_t
setup_cost_classes (cost_classes_t from)
{
  cost_classes_t classes_ptr;

  classes_ptr = (cost_classes_t) ira_allocate (sizeof (struct cost_classes));
  classes_ptr->num = from->num;
  for (int i = 0; i < from->num; i++)
    classes_ptr->classes[i] = from->classes[i];  ここでセットしている.
  complete_cost_classes (classes_ptr);
  return classes_ptr;
}

セットしているのは gcc-7.1.0 でも同じ場所.

(gdb) b ira-costs.c:307
(gdb) run -quiet a.c
...
(gdb) p narrow
(gdb) c
...
(gdb) p narrow


この結果を gcc-8.1.0 と gcc-7.1.0 と比較してみたところ 1 回目の narrow は同じだが
2 回目は

gcc-8.1.0
$53 = {num = 12, classes = {D_REGS, X_REGS, D_OR_X_REGS, A_REGS, A_OR_D_REGS, 
    S_REGS, D_OR_S_REGS, X_OR_S_REGS, Z_OR_S_REGS, D_OR_X_OR_S_REGS, 
    A_OR_S_REGS, G_REGS, X_OR_S_REGS, Y_OR_S_REGS, Z_OR_S_REGS, 
    D_OR_X_OR_S_REGS, D_OR_Y_OR_S_REGS, A_OR_S_REGS, G_REGS, 
    NO_REGS <repeats 17 times>}, index = {0 <repeats 36 times>}, 
  hard_regno_index = {0 <repeats 48 times>}}

gcc-7.1.0
$36 = {num = 3, classes = {X_REGS, S_REGS, X_OR_S_REGS, Z_REGS, D_OR_X_REGS, 
    D_OR_Y_REGS, X_OR_Y_REGS, A_REGS, X_OR_Y_OR_D_REGS, A_OR_D_REGS, S_REGS, 
    D_OR_S_REGS, X_OR_S_REGS, Y_OR_S_REGS, Z_OR_S_REGS, D_OR_X_OR_S_REGS, 
    D_OR_Y_OR_S_REGS, A_OR_S_REGS, G_REGS, NO_REGS <repeats 17 times>}, 
  index = {0 <repeats 36 times>}, hard_regno_index = {0 <repeats 48 times>}}

のように違いが出ている.


cl = D_OR_SP_REGS = 12, mode == E_SImode = 6

で

gcc-8.1.0 で contains_reg_of_mode[cl][mode] = 1
gcc-7.1.0 で contains_reg_of_mode[cl][mode] = 0

      if (!contains_reg_of_mode[cl][mode])
	continue;

ここで動作に違いが出ている.

      for (i = 0; i < N_REG_CLASSES; i++)
	if ((targetm.class_max_nregs ((reg_class_t) i, (machine_mode) m)
	     <= reg_class_size[i])
	    && hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]))
	  {
	     contains_reg_of_mode[i][m] = 1;  ここでセットされている.

gcc-7.1.0 では hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]) が
false なので 1 がセットされていない.

gcc-8.1.0 では
(gdb) p/x ok_regs
$18 = {0x3c107, 0}
(gdb) p reg_class_contents[i]
$19 = {10, 0}
(gdb) 

gcc-7.1.0 では
(gdb) p/x ok_regs
$16 = {0x3c001, 0}
(gdb) p reg_class_contents[i]
$17 = {10, 0}
(gdb)


gcc-8.1.0 の ok_regs[0] の値が異なっているのが原因.
(gdb) set ok_regs[0]=245761
(gdb) p hard_reg_set_intersect_p (ok_regs, reg_class_contents[i])
$21 = false
(gdb)
を確認した.

だから ok_regs[0] = 246023 になっている原因を調査する.


gcc-8.1.0
	if (!TEST_HARD_REG_BIT (fixed_nonglobal_reg_set, j)
	    && targetm.hard_regno_mode_ok (j, (machine_mode) m))

gcc-7.1.0
	if (!TEST_HARD_REG_BIT (fixed_nonglobal_reg_set, j)
	    && HARD_REGNO_MODE_OK (j, (machine_mode) m))

ここで違いが出ていた.

m68hc11.c に以下を追加することで回避することができる.

+#undef TARGET_HARD_REGNO_MODE_OK
+#define TARGET_HARD_REGNO_MODE_OK hard_regno_mode_ok

struct gcc_target targetm = TARGET_INITIALIZER;
