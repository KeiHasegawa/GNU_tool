mcore-elf-as で .debug_frame 情報をどのように生成しているか調査

% cat a.c
int f(int a, int b)
{
  return a + b;
}
% mcore-elf-gcc -g -S a.c
% mcore-elf-as -o a.o a.s
% mcore-elf-objdump --dwarf=frames a.o > a.objdump
% arm-elf-gcc -g -S a.c -o b.s
% arm-elf-as -o b.o b.s
% arm-elf-objdump  --dwarf=frames b.o > b.objdump

a.s と b.s は勿論違うコンパイラが生成したコードだから違いはあるが, 函数の
コードの最後に出ているものはものすごく似ている.

しかし a.objdump と b.objdump とに違いがある. mcore-elf-as は何か
重要な仕事をスキップしたかのようになっている.

% mcore-elf-objdump -s -g a.o > a.objdump2
% arm-elf-objdump -s -g b.o > b.objdump2

a.o の .debug_frame は 0x24 バイトでであるのに対して
b.o の .debug_frame は 0x30 バイト

この違いが a.objdump と b.objdump の違いとなって現われている.

arm-elf-as で b.s をアセンブルさせてみたところ:

Breakpoint 3, bfd_set_section_contents (abfd=0x82062d8, section=0x82079e0, location=0x8223bd4, offset=0, count=16) at section.c:1523
(gdb) p section->name
$5 = 0x8223af8 ".debug_frame"
(gdb) c
Continuing.

Breakpoint 3, bfd_set_section_contents (abfd=0x82062d8, section=0x82079e0, location=0x8223c2c, offset=16, count=30) at section.c:1523
(gdb) p section->name
$6 = 0x8223af8 ".debug_frame"
(gdb) p/x count
$7 = 0x1e
(gdb) c
Continuing.

Breakpoint 3, bfd_set_section_contents (abfd=0x82062d8, section=0x82079e0, location=0xbffff260, offset=46, count=2) at section.c:1523
(gdb) p section->name
$8 = 0x8223af8 ".debug_frame"
(gdb) c
Continuing.

のように 16 + 30 + 2 = 0x30 バイトになっている.

一方 a.s を mcore-elf-as にアセンブルさせてみたところ:

Breakpoint 1, bfd_set_section_contents (abfd=0x8158448, section=0x816c568, location=0x8176160, offset=0, count=19) at section.c:1523
(gdb) p section->name
$3 = 0x81760d0 ".debug_frame"
(gdb) c
Continuing.

Breakpoint 1, bfd_set_section_contents (abfd=0x8158448, section=0x816c568, location=0xbffff250, offset=19, count=1) at section.c:1523
(gdb) p section->name
$4 = 0x81760d0 ".debug_frame"
(gdb) c
Continuing.

Breakpoint 1, bfd_set_section_contents (abfd=0x8158448, section=0x816c568, location=0x81761ac, offset=20, count=16) at section.c:1523
(gdb) p section->name
$5 = 0x81760d0 ".debug_frame"
(gdb)

19 + 1 + 16 = 0x24

のようになっている. arm-elf-as とはかなり違っている.

以下は a.s の抜粋(27 行):
	.section .debug_frame
.Lframe0:
	.long	.LECIE0-.LSCIE0
.LSCIE0:
	.long	0xffffffff
	.byte	0x3
	.string	""
	.uleb128 0x1
	.sleb128 -4
	.uleb128 0x14
	.byte	0xc
	.uleb128 0
	.uleb128 0
	.byte	0x9
	.uleb128 0x14
	.uleb128 0xf
	.align	2
.LECIE0:
.LSFDE0:
	.long	.LEFDE0-.LASFDE0
.LASFDE0:
	.long	.Lframe0
	.long	.LFB0
	.long	.LFE0-.LFB0
	.align	2
.LEFDE0:

以下は b.s の抜粋(41 行):
	.section	.debug_frame,"",%progbits
.Lframe0:
	.4byte	.LECIE0-.LSCIE0
.LSCIE0:
	.4byte	0xffffffff
	.byte	0x1
	.ascii	"\000"
	.uleb128 0x1
	.sleb128 -4
	.byte	0xe
	.byte	0xc
	.uleb128 0xd
	.uleb128 0x0
	.align	2
.LECIE0:
.LSFDE0:
	.4byte	.LEFDE0-.LASFDE0
.LASFDE0:
	.4byte	.Lframe0
	.4byte	.LFB2
	.4byte	.LFE2-.LFB2
	.byte	0x4
	.4byte	.LCFI0-.LFB2
	.byte	0xd
	.uleb128 0xc
	.byte	0x4
	.4byte	.LCFI1-.LCFI0
	.byte	0x8e
	.uleb128 0x2
	.byte	0x8d
	.uleb128 0x3
	.byte	0x8b
	.uleb128 0x4
	.byte	0x4
	.4byte	.LCFI2-.LCFI1
	.byte	0xc
	.uleb128 0xb
	.uleb128 0x4
	.align	2
.LEFDE0:

そもそも出ているものが違っているから arm-elf-as の生成したオブジェクトファイル
の .debug_frame の内容がそれなりであるのに対して
mcore-elf-as の生成したオブジェクトファイルの .debug_frame の内容が足りていないの
はそういうこと.

なのでこれはアセンブラの問題とは言えない. むしろコンパイラの問題.
