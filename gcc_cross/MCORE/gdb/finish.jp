MCORE の gdb で finish コマンドしても期待したアドレスで停止しない件の調査

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_mcore.007

finish コマンドを実行すると期待したアドレスで停止していない.

函数 f で finish コマンドを実行したとき, どこかのタイミングで

mcore_frame_prev_register(..., int regno=64)

が呼び出され

00000138 <main>:
...
 146:	7f04      	jsri	0x118	// 118 <f>
 148:	1227      	mov	r7, r2

0x148 が返るのが期待値. と思ったがそもそもここがきていない.

mcore_frame_this_id

は少なくとも呼び出されている.

f で停止しているとき

(gdb) p/x fi->this_id.value
$1 = {stack_addr = 0x1000, code_addr = 0x100, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) 

stack_addr : 0x1000 ではなく 0x0ff8 か 0x0fe0 が期待値
code_addr : 0x100 ではなく 0x118 が期待値

stack_addr ができていないくても code_addr ができていれば期待通り動作するはずだが, ここ
もできていないからこういう動作になる.

mcore_frame_create では

(gdb) p/x ret->pc
$2 = 0x10a
(gdb) 

このアドレスは

00000100 <start>:
 100:	7804      	lrw	r8, 0x1000
 102:	1280      	mov	r0, r8
 104:	7f04      	jsri	0x138	// 138 <main>
 106:	1200      	mov	r0, r0
 108:	1200      	mov	r0, r0

0000010a <end>:
 10a:	1200      	mov	r0, r0   ここだった.

なので最初のフレーム ID は実は正解だった.
プログラムが f にいるときに f のフレームを問い合わせていると勘違いしたのが今の間違い.
あくまで

mcore_frame* mcore_frame_create(frame_info *frame)

引数の frame に対して mcore_frame を作ると考えるのが正しい.

そしてフレーム ID が問い合わせられたのは, それだけ.

finish コマンドでシミュレーション再開前になぜ 0x148 に内部ブレークポイントが
セットされないのかが問題.

期待通り動いている pru-elf-gdb と動作を比較してみるのがよい.

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_pru.015

に finish コマンドのテスト環境がある.

(gdb) b finish_command

勿論だが pru-elf-gdb も mcore-elf-gdb もこのブレークポイントにヒットする.

finish_command          ヒット
mcore_frame_this_id     ヒット
mcore_frame_prev_register  ヒットしない


pru-elf-gdb は以下

finish_command          ヒット 
pru_frame_create        ヒットしない
pru_frame_prev_register ヒットしない

ということは xxx_frame_prev_register が呼ばれると決め付けていたのが間違った考え.
思い込みだった.

mcore-elf-gdb で以下を試してみた

(gdb) b sim_write
(gdb) info b
...
(gdb) disa 4  # sim_write のブレークポイント番号
(gdb) run
...
Thread 1 "gdb" hit Breakpoint 3, finish_command (arg=0x0, from_tty=0) at infcmd.c:1766
(gdb) enable 4
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 4, sim_write (sd=0x8dcef60, mem=266, buf=0x8c89488 <mcore_from_kind(gdbarch*, int, int*)::bkpt> "", length=2) at ./../common/sim-hrw.c:37
(gdb) p/x mem
$6 = 0x10a
(gdb) 

0x10a にはブレークポイントをセットしている. これは end のアドレス.
0x140, 0x148 にもブレークポイントをセットしている. ということは
ここまでは正しいということ.

00000138 <main>:
...
 140:	60c4      	movi	r4, 12
 142:	60b3      	movi	r3, 11
 144:	60a2      	movi	r2, 10
 146:	7f04      	jsri	0x118	// 118 <f>
 148:	1227      	mov	r7, r2


同じことを pru-elf-gdb で行なってみた. 0x194, 0x19c にブレークポイントがセット
されている.

00000188 <main>:
...
 194:	0516e4ee 	sub	r14, fp, 22
 198:	230043c3 	call	10c <f>
 19c:	0516e4e0 	sub	r0, fp, 22

自分が想像していたよりも mcore-elf-gdb はそれなりに動作していたということ.

以下 pru-elf-gdb でやってみた:

(gdb) b sim_engine_halt
(gdb) disa 5 # sim_engine_halt のブレークポイント番号
(gdb) run
...
finish_command のブレークポイントにヒット
(gdb) enable 5
(gdb) c
...
sim_engine_halt(..., cia=412=0x19c, ...) のブレークポイントにヒット
(gdb) b sim_stop_reason
(gdb) c
...
sim_stop_reason のブレークポイントにヒット
(gdb)

ここで *reason = sim_stopped, *sigrc = 5 であることを確認した.

同じことを mcore-elf-gdb でやってみた

sim_engine_halt が cia = 0x148 で呼び出され

*reason = sim_stopped, *srgc = 5

になっている. つまりここまではできている. ここから実行が再開されるのが期待していない動作.
この後おそらく mcore-elf-gdb では sim_resume が呼ばれるが pru-elf-gdb では
sim_resume が呼ばれない.

以下 mcore-elf-gdb の sim_resume の呼び出し.

sim_resume (sd=0x8dcef60, step=1, siggnal=0) at ./../common/sim-resume.c:41

いずれにしても内部ブレークポイントにヒットして sim_engine_halt, sim_stop_reason
が呼び出されるところまでは mcore-elf-gdb でできている.

だから何故 sim_resume がこの後呼び出されてしまうのかを調査する.

pru-elf-gdb が finish_command の後 sim_stop_reason から連続で finish コマンド
で戻った場合 8 回目で

static void
infrun_async_inferior_event_handler (gdb_client_data data)
{
  inferior_event_handler (INF_REG_EVENT);
}

に戻ったが, mcore-elf-gdb では

void
inferior_event_handler (enum inferior_event_type event_type)
{
  switch (event_type)
    {
    case INF_REG_EVENT:
      fetch_inferior_event ();
      break;

ここに戻っている. つまり呼び出し元が異なるということ. しかしこれは -O2 オプションが
影響していると考えられる. と思たが違った. pru-elf-gdb の infrun.o は -g3 -O0.
mcore-elf-gdb の infrun.o は -g -O0. 違いは少しあるが -O2 オプションではない.

そしてもっと重要なことはここまで finish コマンドを連続で実行した結果
pru-elf-gdb の pru_return_value は呼び出されていたのに対して
mcore-elf-gdb の mcore_return_value は呼び出されていなかったということ.

finish_command -> sim_stop_reason から連続で finish コマンドを実行したとき

pru-elf-gdb ではここで finish コマンドを発行したとき

    if (!do_target_wait (minus_one_ptid, ecs, TARGET_WNOHANG))
      return;

pru_return_value が呼び出されている. そしてそのときのスタックは

(gdb) where
#0  pru_return_value (function=0x8c44990, valtype=0x8c221cc, regcache=0x0, readbuf=0x0, writebuf=0x0) at pru-tdep.c:83
#1  0x08242608 in get_return_value (function=0x8c44990, value_type=0x8c221cc) at infcmd.c:1454
#2  0x08242756 in finish_command_fsm::should_stop (tp=0x8c37af8, this=0x8c378b8) at infcmd.c:1605
#3  finish_command_fsm::should_stop (this=0x8c378b8, tp=0x8c37af8) at infcmd.c:1584
#4  0x0824f594 in fetch_inferior_event () at infrun.c:3946
#5  0x0823c9f9 in inferior_event_handler (event_type=INF_REG_EVENT) at inf-loop.c:42
#6  0x0825a785 in infrun_async_inferior_event_handler (data=0x0) at infrun.c:9207
#7  0x080a43ac in check_async_event_handlers () at async-event.c:295
--Type <RET> for more, q to quit, c to continue without paging--c
#8  0x084b64cb in gdb_do_one_event () at event-loop.cc:194
#9  0x083a341c in wait_sync_command_done () at top.c:526
#10 maybe_wait_sync_command_done (was_sync=<optimized out>) at top.c:543
#11 0x083a5151 in execute_command (p=<optimized out>, from_tty=<optimized out>) at top.c:670
#12 0x0820314c in command_handler (command=0x8c24ff0 "finish") at event-top.c:588
#13 0x083a3cdc in read_command_file (stream=0x8c24170) at top.c:447
#14 0x0811b8f1 in script_from_file (stream=0x8c24170, file=0xbffff84f "x") at cli/cli-script.c:1622
#15 0x0810b4e1 in source_script_from_stream (stream=0x8c24170, file=0xbffff84f "x", file_to_open=0xbffff84f "x") at cli/cli-cmds.c:700
#16 0x0810b5ba in source_script_with_search (file=0xbffff84f "x", from_tty=1, search_path=0) at cli/cli-cmds.c:736
#17 0x0810b60d in source_script (file=0xbffff84f "x", file@entry=<error reading variable: value has been optimized out>, from_tty=1, from_tty@entry=<error reading variable: value has been optimized out>) at cli/cli-cmds.c:746
#18 0x08281efa in catch_command_errors (command=<optimized out>, arg=<optimized out>, from_tty=<optimized out>) at main.c:457
#19 0x08283be0 in captured_main_1 (context=<optimized out>) at main.c:1214
#20 0x08283fdd in captured_main (data=0xbffff554) at main.c:1243
#21 gdb_main (args=0xbffff554) at main.c:1268
#22 0x0806ca7c in main (argc=5, argv=0xbffff624) at gdb.c:32
(gdb)


pru-elf-gdb は以下の部分から should_stop メンバ函数の呼び出しがある.

	if (thr != NULL)
	  {
	    struct thread_fsm *thread_fsm = thr->thread_fsm;

	    if (thread_fsm != NULL)
	      should_stop = thread_fsm->should_stop (thr);
	  }

mcore-elf-gdb でなぜこの呼び出しがないのか確認する.

infrun.c:3933
    if (!ecs->wait_some_more)
      {

mcore-elf-gdb では 1. 一方 pru-elf-gdb では 0. これが直接の原因.

これを mcore-elf-gdb で書き変えているのは以下と判明:

infrun.c:7913:
  ecs->wait_some_more = 1;

Old value = 0
New value = 1
prepare_to_wait (ecs=0xbfffef30) at infrun.c:7913
(gdb)


    /* Now figure out what to do with the result of the result.  */
    handle_inferior_event (ecs);  ここの動作が pru-elf-gdb と mcore-elf-gdb とで
                                  異なっている.

    if (!ecs->wait_some_more)     その結果この条件の成立するかに影響している.


    case TARGET_WAITKIND_STOPPED:
      handle_signal_stop (ecs);   ここまでの動作は合致しているがこの中で動作が違っている
      return;


process_event_stop_test の

  switch (what.main_action)

ここで動作に違いが出ている


mcore-elf-gdb
    case BPSTAT_WHAT_SINGLE:


pru-elf-gdb
    case BPSTAT_WHAT_STOP_NOISY:

ということは

  what = bpstat_what (ecs->event_thread->control.stop_bpstat);

なぜこの違いが出るのかを確認する.

	  if (bs->stop)
	    {
	      if (bs->print)


pru-elf-gdb ではこの 1 つ目の if の条件が成立しているが
mcore-elf-gdb では成立していない.

試しに gdb で bs->stop に 1 をセットしてみたところ

mcore_return_value

が期待通り呼び出されている. ということは何故 bs->stop が 0 のままなのか.
あるいはどこかで 0 に書き変えられているのかを確認する.

確認したところ, あるクラスのコンストラクタで 0 に初期化されその後 1 がセット
されている. しかし

breakpoint.c:5162
  if (frame_id_p (b->frame_id)
      && !frame_id_eq (b->frame_id, get_stack_frame_id (get_current_frame ())))
    {
      bs->stop = 0;
      return;
    }

ここで 0 にされている.
なんだかこれは...

mcore-elf-gdb では pru-elf-gdb で必要だった函数へのステップインの動作の対応が必要
なかったのだ. しかしここでそれが影響しているように想像できるコード.

試しに

static value*
mcore_dwarf2_prev_register(frame_info* frame, void**, int regno)
{
  assert(regno == pc_regno);
  auto r15 = frame_unwind_register_unsigned(frame, 15);
  return frame_unwind_got_constant(frame, regno, r15);
}

static void
mcore_dwarf2_frame_init_reg(gdbarch*, int regno,
			    dwarf2_frame_state_reg *reg, frame_info*)
{
...
  dwarf2_frame_set_init_reg(gdbarch, mcore_dwarf2_frame_init_reg);

のように pru-elf-gdb と同じ対応を行なってみた.
mcore_dwarf2_prev_register が必要な箇所で呼び出されているらしいが,

breakpoint.c:5162
  if (frame_id_p (b->frame_id)
      && !frame_id_eq (b->frame_id, get_stack_frame_id (get_current_frame ())))
    {
      bs->stop = 0;
      return;
    }

ここで 0 にされている状況は同じ.


(gdb) p/x b->frame_id
$68 = {stack_addr = 0xfe0, code_addr = 0x138, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x get_stack_frame_id (get_current_frame ())
$69 = {stack_addr = 0xff8, code_addr = 0x138, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

なるほど stack_addr が違っているから違うと判定されて bs->stop = 0 とされているわけだ.

同じことを pru-elf-gdb でやってみた.


(gdb) p/x b->frame_id
$41 = {stack_addr = 0x1000, code_addr = 0x188, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x get_stack_frame_id (get_current_frame ())
$42 = {stack_addr = 0x1000, code_addr = 0x188, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p frame_id_p (b->frame_id)
$43 = true
(gdb)

両方とも stack_addr = 0x1000 になっている. 0x188 は main  
のアドレス.

ということは mcore-elf-gdb で

b->frame_id.stack_addr = 0xfe0

になっていることや

get_stack_frame_id (get_current_frame ()).stack_addr = 0xff8

になっていることがそもそも間違い.
まずはこの原因を調査する.


breakpoint.c:8463:
  b->frame_id = frame_id;

ここで frame_id がセットされている.

static void
dwarf2_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);

...
    (*this_id) = frame_id_build (cache->cfa, get_frame_func (this_frame));

ここで計算しているらしい.

1 回目 : cache->cfa = 0xff8
2 回目 : cache->cfa = 0xfe0

そしてこれらは finish_command に先立って計算されている.
同様のことを pru-elf-gdb でも確認したところ

1 回目 : cache->cfa = 0x1000
2 回目 : cache->cfa = 0x1000

のようになっていた.

ということはこの函数の先頭で dwarf2_frame_cache の呼び出しを確認する.

dwarf2/frame.c:1070
	case CFA_REG_OFFSET:
	  cache->cfa = read_addr_from_reg (this_frame, fs.regs.cfa_reg); (*A)
	  if (fs.armcc_cfa_offsets_reversed)

mcore-elf-gdb も pru-elf-gdb も (*A) で計算している.

pru-elf-gdb では

16 番のレジスタ -> 4 番のレジスタ(フレームポインタ) -> sim_read

のように 0x1000 を計算している. 函数の名前から想像するとそのレジスタのアドレス
から値を読み出すと思ったが違っていた.

そこで

static int mcore_dbg_reg_to_regno(gdbarch*, int regno)
{
  if (regno == sp_regno)
    return 8;
  return regno;
}

のように MCORE でも変更してみた. スタックポインタ(r0)に対してフレームポインタ(r8)
の値を代りに返すというもの.

breakpoint.c:5162
  if (frame_id_p (b->frame_id)
      && !frame_id_eq (b->frame_id, get_stack_frame_id (get_current_frame ())))
    {
      bs->stop = 0;
      return;
    }

ここで bs->stop = 0 になるのが期待しない動作なのだが 1 回目は
stack_addr = 0xff8 code_addr = 0x138 で frame_id_eq() が true になる.

しかし 2 回目は

(gdb) p/x b->frame_id
$182 = {stack_addr = 0xfe0, code_addr = 0x138, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x get_stack_frame_id (get_current_frame ())
$183 = {stack_addr = 0xff8, code_addr = 0x138, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}

のようになり bs->stop = 0 となってしまう.

pru-elf-gdb を参考にするのも間違いではないと思うのだが

16 番のレジスタ -> 4 番のレジスタ(フレームポインタ)

としているのが気になる.

この函数は

  set_gdbarch_dwarf2_reg_to_regnum(gdbarch, mcore_dbg_reg_to_regno);
  set_gdbarch_stab_reg_to_regnum(gdbarch, mcore_dbg_reg_to_regno);

のように指定されているので他の状況も少し見てみる.

aarch64-elf-gdb : r31 がスタックポインタで番号の変更なしにそのまま

b dwarf2/frame.c:1071
command
silent
p/x cache->cfa
p/x cache->cfa + fs.regs.cfa_offset
c
end

のようにして得た結果が以下

 $1 = 0xff0  $2 = 0x1000
 $3 = 0xff0  $4 = 0xff0
 $5 = 0xff0  $6 = 0x1000
 $7 = 0xfe0  $8 = 0xff0
 $9 = 0xff0 $10 = 0x1000
$11 = 0xfe0 $12 = 0xff0
$13 = 0xff0 $14 = 0x1000
$15 = 0xff0 $16 = 0x1000
$17 = 0xff0 $18 = 0x1000

arm-elf-gdb  11 番のレジスタ(fp)を問い合わせている. 変更なし.

 $1 = 0xffc  $2 = 0x1000
 $3 = 0xff0  $4 = 0xff0
 $5 = 0xffc  $6 = 0x1000
 $7 = 0xfec  $8 = 0xff0
 $9 = 0xffc $10 = 0x1000
$11 = 0xfec $12 = 0xff0
$13 = 0xffc $14 = 0x1000
$15 = 0xffc $16 = 0x1000
$17 = 0xffc $18 = 0x1000

ここまで調べると結果的に 1, 3, 5, 7, 8, 9 回目に cache->cfa = 0x1000
になるのが期待値で 2, 4, 6 回目に 0x1000 よりも少し小さい値 0xff0 になる.

avr-elf-gdb は avr_frame_this_id で自分で作っていた.
dwarf2/frame.c:1071 は呼ばれていない. avr-elf-gcc の出力は

    .stabs

のように他とはちょっと違っている.

b avr-tdep.c:1111
command
silent
p/x base
p/x func
c
end

 $1 = 0x80fefe  $2 = 0x156
 $3 = 0x80fefa  $4 = 0x128
 $5 = 0x80fefe  $6 = 0x156
 $7 = 0x80fefa  $8 = 0x128
 $9 = 0x80fefe $10 = 0x156
$11 = 0x80fefa $12 = 0x128
$13 = 0x80fefe $14 = 0x156
$15 = 0x80fefe $16 = 0x156
$17 = 0x80fefe $18 = 0x156

base の値は 0x1000 ではないもののそれっぽい.

以下は bfin-elf-gdb の結果. bfin_reg_to_regnum では変換していないらし
い.

 $1 = 0xff8  $2 = 0x1000
 $3 = 0xfec  $4 = 0xfec
 $5 = 0xff8  $6 = 0x1000
 $7 = 0xfe4  $8 = 0xfec
 $9 = 0xff8 $10 = 0x1000
$11 = 0xfe4 $12 = 0xfec
$13 = 0xff8 $14 = 0x1000
$15 = 0xff8 $16 = 0x1000
$17 = 0xff8 $18 = 0x1000

以下は cris-elf-gdb の結果. cris_dwarf2_reg_to_regnum ではそれなりに変
換しているがやはりコンパイラの実装に深く依存しているのは間違いないらしい.

 $1 = 0xff8  $2 = 0x1000
 $3 = 0xff8  $4 = 0xff8
 $5 = 0xff8  $6 = 0x1000
 $7 = 0xff4  $8 = 0xff8
 $9 = 0xff8 $10 = 0x1000
$11 = 0xff4 $12 = 0xff8
$13 = 0xff8 $14 = 0x1000
$15 = 0xff8 $16 = 0x1000
$17 = 0xff8 $18 = 0x1000

frv-elf-gdb は .debug_frame セクションはあるが他のとは違いむしろ
avr-elf-gdb に近い. avr と同じようなログを出してみた.

 $1 = 0x1000 $2 = 0x160
 $3 = 0x1000 $4 = 0x160
 $5 = 0xff0  $6 = 0x120
 $7 = 0x1000 $8 = 0x160
 $9 = 0xff0  $10 = 0x120
$11 = 0x1000 $12 = 0x160
$13 = 0xff0  $14 = 0x120
$15 = 0x1000 $16 = 0x160
$17 = 0x1000 $18 = 0x160
$19 = 0x1000 $20 = 0x160

ft32-elf-gdb も .debug_frame セクションはあるが avr, frv 系

 $1 = 0xff4  $2 = 0x14c
 $3 = 0xff0  $4 = 0x12c
 $5 = 0xff4  $6 = 0x14c
 $7 = 0xfec  $8 = 0x12c
 $9 = 0xff4 $10 = 0x14c
$11 = 0xfec $12 = 0x12c
$13 = 0xff4 $14 = 0x14c
$15 = 0xff4 $16 = 0x14c
$17 = 0xff4 $18 = 0x14c

h8300-elf-gdb は aarch64, arm 系

 $1 = 0xffc  $2 = 0x1000
 $3 = 0xff0  $4 = 0xff2
 $5 = 0xffc  $6 = 0x1000
 $7 = 0xfee  $8 = 0xff2
 $9 = 0xffc $10 = 0x1000
$11 = 0xfee $12 = 0xff2
$13 = 0xffc $14 = 0x1000
$15 = 0xffc $16 = 0x1000
$17 = 0xffc $18 = 0x1000

iq2000-efl-gdb は aarch64, arm 系

 $1 = 0xff8  $2 = 0x1000
 $3 = 0xff8  $4 = 0xff8
 $5 = 0xff8  $6 = 0x1000
 $7 = 0xfe8  $8 = 0xff8
 $9 = 0xff8 $10 = 0x1000
$11 = 0xfe8 $12 = 0xff8
$13 = 0xff8 $14 = 0x1000
$15 = 0xff8 $16 = 0x1000
$17 = 0xff8 $18 = 0x1000

lm32-elf-gdb は avr, ft32, frv 系

 $1 = 0xff8  $2 = 0x154
 $3 = 0xff8  $4 = 0x11c
 $5 = 0xff8  $6 = 0x154
 $7 = 0xfe8  $8 = 0x11c
 $9 = 0xff8 $10 = 0x154
$11 = 0xfe8 $12 = 0x11c
$13 = 0xff8 $14 = 0x154
$15 = 0xff8 $16 = 0x154
$17 = 0xff8 $18 = 0x154

m32c-elf-gdb は avr, ft32, frv, lm32 系

 $1 = 0x1000  $2 = 0x51b
 $3 = 0xffd   $4 = 0x50a
 $5 = 0x1000  $6 = 0x51b
 $7 = 0xffd   $8 = 0x50a
 $9 = 0x1000 $10 = 0x51b
$11 = 0xffd  $12 = 0x50a
$13 = 0x1000 $14 = 0x51b
$15 = 0x1000 $16 = 0x51b
$17 = 0x1000 $18 = 0x51b

m32r-elf-gdb は mcore のように debug_frame 情報がほとんど出ていない.

  DW_CFA_def_cfa: r15 ofs 0
  DW_CFA_register: r20 in r14
  DW_CFA_nop

00000014 0000000c 00000000 FDE cie=00000000 pc=00000110..00000130

00000024 0000000c 00000000 FDE cie=00000000 pc=00000130..0000014c

しかしそれでもきている. avr, ft32, frv のように自力でなんとかしているっ
ぽい.

 $1 = 0x1000  $2 = 0x130
 $3 = 0xff8   $4 = 0x110
 $5 = 0x1000  $6 = 0x130
 $7 = 0xff8   $8 = 0x110
 $9 = 0x1000 $10 = 0x130
$11 = 0xff8  $12 = 0x110
$13 = 0x1000 $14 = 0x130
$15 = 0x1000 $16 = 0x130
$17 = 0x1000 $18 = 0x130

m68hc11-elf-gdb は debug_frame がないのにそれっぽく動作している.

 $1 = 0xfff  $2 = 0x1079
 $3 = 0xff7  $4 = 0x1049
 $5 = 0xfff  $6 = 0x1079
 $7 = 0xff7  $8 = 0x1049
 $9 = 0xfff $10 = 0x1079
$11 = 0xff7 $12 = 0x1049
$13 = 0xfff $14 = 0x1079
$15 = 0xfff $16 = 0x1079
$17 = 0xfff $18 = 0x1079

microblaze-elf-gdb はスタートアップルーチンで stack-16 をスタックポイ
ンタ(r1) にセットしているので 0x1000 ではないが, aarch64, arm 系

 $1 = 0xfd0  $2 = 0xff0
 $3 = 0xfd0  $4 = 0xfd0
 $5 = 0xfd0  $6 = 0xff0
 $7 = 0xfc8  $8 = 0xfd0
 $9 = 0xfd0 $10 = 0xff0
$11 = 0xfc8 $12 = 0xfd0
$13 = 0xfd0 $14 = 0xff0
$15 = 0xfd0 $16 = 0xff0
$17 = 0xfd0 $18 = 0xff0

mips-elf-gdb はプログラムの配置アドレスに制限があるから他と少し違って
いるが aarch64, arm 系

 $1 = 0xffffffffa0020fe8  $2 = 0xffffffffa0021000
 $3 = 0xffffffffa0020fe8  $4 = 0xffffffffa0020fe8
 $5 = 0xffffffffa0020fe8  $6 = 0xffffffffa0021000
 $7 = 0xffffffffa0020fe0  $8 = 0xffffffffa0020fe8
 $9 = 0xffffffffa0020fe8 $10 = 0xffffffffa0021000
$11 = 0xffffffffa0020fe0 $12 = 0xffffffffa0020fe8
$13 = 0xffffffffa0020fe8 $14 = 0xffffffffa0021000
$15 = 0xffffffffa0020fe8 $16 = 0xffffffffa0021000
$17 = 0xffffffffa0020fe8 $18 = 0xffffffffa0021000

mn10300-elf-gdb は aarch64, arm 系

 $1 = 0xffc  $2 = 0x1000
 $3 = 0xff0  $4 = 0xff0
 $5 = 0xffc  $6 = 0x1000
 $7 = 0xfec  $8 = 0xff0
 $9 = 0xffc $10 = 0x1000
$11 = 0xfec $12 = 0xff0
$13 = 0xffc $14 = 0x1000
$15 = 0xffc $16 = 0x1000
$17 = 0xffc $18 = 0x1000

moxie-elf-gdb は avr, frv, ft32 系

 $1 = 0xfdc  $2 = 0x128
 $3 = 0xfd0  $4 = 0x114
 $5 = 0xfdc  $6 = 0x128
 $7 = 0xfd0  $8 = 0x114
 $9 = 0xfdc $10 = 0x128
$11 = 0xfd0 $12 = 0x114
$13 = 0xfdc $14 = 0x128
$15 = 0xfdc $16 = 0x128
$17 = 0xfdc $18 = 0x128

msp430-elf-gdb は aarch64, arm 系

 $1 = 0xffe  $2 = 0x1000
 $3 = 0xffc  $4 = 0xffe
 $5 = 0xffe  $6 = 0x1000
 $7 = 0xff8  $8 = 0xffe
 $9 = 0xffe $10 = 0x1000
$11 = 0xff8 $12 = 0xffe
$13 = 0xffe $14 = 0x1000
$15 = 0xffe $16 = 0x1000
$17 = 0xffe $18 = 0x1000

or1k-elf-gdb は aarch64, arm 系だが $1, $2 とで差分がないのが特徴ある.

 $1 = 0x1000  $2 = 0x1000
 $3 = 0xff8   $4 = 0xff8
 $5 = 0x1000  $6 = 0x1000
 $7 = 0xff8   $8 = 0xff8
 $9 = 0x1000 $10 = 0x1000
$11 = 0xff8  $12 = 0xff8
$13 = 0x1000 $14 = 0x1000
$15 = 0x1000 $16 = 0x1000
$17 = 0x1000 $18 = 0x1000

ppc-elf-gdb は .debug_frame ではなくて .eh_frame になっているが
aarch64, arm 系

 $1 = 0xff0  $2 = 0x1000
 $3 = 0xff0  $4 = 0xff0
 $5 = 0xff0  $6 = 0x1000
 $7 = 0xfd0  $8 = 0xff0
 $9 = 0xff0 $10 = 0x1000
$11 = 0xfd0 $12 = 0xff0
$13 = 0xff0 $14 = 0x1000
$15 = 0xff0 $16 = 0x1000
$17 = 0xff0 $18 = 0x1000

pru-elf-gdb は aarch64, arm 系だが or1k-elf-gdb と同様に差分がない

 $1 = 0x1000  $2 = 0x1000
 $3 = 0x1000  $4 = 0x1000
 $5 = 0x1000  $6 = 0x1000
 $7 = 0xffa   $8 = 0xffa
 $9 = 0x1000 $10 = 0x1000
$11 = 0xffa  $12 = 0xffa
$13 = 0x1000 $14 = 0x1000
$15 = 0x1000 $16 = 0x1000
$17 = 0x1000 $18 = 0x1000

rl78-elf-gdb は aarch64, arm 系だが f での debug_frame 情報が空になっ
ている. そのためか 18 個ではなく 16 個になっている.

 $1 = 0xf1ff8  $2 = 0xf2000
 $3 = 0xf1ff4  $4 = 0xf1ff8
 $5 = 0xf1ff8  $6 = 0xf2000
 $7 = 0xf1ff4  $8 = 0xf1ff8
 $9 = 0xf1ff8 $10 = 0xf2000
$11 = 0xf1ff8 $12 = 0xf2000
$13 = 0xf1ff8 $14 = 0xf2000

rx-elf-gdb は aarch64, arm 系だが, そもそも rx-elf-gcc には -O2 -g を
指定しないと内部エラーが発生するというバグがあるせいか他のテストと同じ
にはできず, また 18 個期待されるところが 14 個になっている. これはこれ
で正しい動き.

 $1 = 0x1ffc  $2 = 0x2000
 $3 = 0x1ff8  $4 = 0x1ffc
 $5 = 0x1ffc  $6 = 0x2000
 $7 = 0x1ff8  $8 = 0x1ffc
 $9 = 0x1ffc $10 = 0x2000
$11 = 0x1ffc $12 = 0x2000
$13 = 0x1ffc $14 = 0x2000

sh-elf-gdb はシミュレータの例のバグで次回 linux 起動時に確認する.

v850-elf-gdb は aarch64, arm 系

 $1 = 0xff8  $2 = 0x1000
 $3 = 0xff8  $4 = 0xff8
 $5 = 0xff8  $6 = 0x1000
 $7 = 0xfec  $8 = 0xff8
 $9 = 0xff8 $10 = 0x1000
$11 = 0xfec $12 = 0xff8
$13 = 0xff8 $14 = 0x1000
$15 = 0xff8 $16 = 0x1000
$17 = 0xff8 $18 = 0x1000

それとここまで調べて気付いたが dwarf2_frame_set_init_reg で指定する函
数で pc と sp について何かやっているのが一般的だということ.

さて一旦

mcore_dbg_reg_to_regno

の修正と

dwarf2_frame_set_init_reg(gdbarch, mcore_dwarf2_frame_init_reg);

としていたのは元に戻しておく.

この後 mcore-elf-gcc で .debug_frame セクションが期待した形で生成され
ていないことが判明し, そして期待値を作成した状態で finish コマンドを
実行したところ

mcore_return_value

が呼び出されるようになり, 正常に動作するようになった. この時点での
mcore-tdep.c を mcore-tdep.c.003 としてアップロードしておく.


