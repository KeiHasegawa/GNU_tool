Fix for simple target program

As described at "MCORE", mcore-elf-gdb does not configure for target
processor, so it does not work.

At first, I aimed that a simple assembler target program worke well.

gdb-10.2.mcore-elf/gdb/init.c

void
initialize_all_files (void)
{

// Do here for mcore processor

  _initialize_mcore_tdep ();

Note that `init.c' is automaticaly generated by command executed from
`Makefile'. I created

gdb-10.2.mcore-elf/gdb/mcore-tdep.c

and defined empty function like below:

void
_initialize_mcore_tdep()
{
}

'_initialize' has to start at first colum for generating `init.c'.

gdb-10.2.mcore-elf/gdb/Makefile

Add above like below:

TARGET_OBS =  mcore-tdep.o

And more, add below:

SIM_OBS = remote-sim.o

SIM = ../sim/mcore/libsim.a

Now I just confirmed that I could built new gdb.

(*1) MCORE register

struct mcore_regset
{
  word gregs[16];	/* primary registers */
  word alt_gregs[16];	/* alt register file */
  word cregs[32];	/* control registers */
  word pc;
};

#define sr	cr[0]
#define vbr	cr[1]
#define esr	cr[2]
#define fsr	cr[3]
#define epc	cr[4]
#define fpc	cr[5]
#define ss0	cr[6]
#define ss1	cr[7]
#define ss2	cr[8]
#define ss3	cr[9]
#define ss4	cr[10]
#define gcr	cr[11]
#define gsr	cr[12]

are defined so I guessed that there were:

GR0, ..., GR15, ALT0, ..., ALT31
control registers
SR, VBR, ESR, FSR, EPC, FPC, SS0, SS1, SS2, SS3, SS4, GCR, GSR
PC

For a while, I coded mcore-tdep.c by refering to other processors,
for example h8300-tdep.c.
Then I confirmed that `sim_open' and `sim_load' are called as I expected.

Here, I inserted break-point into the MCORE configuration fuction
like below:

// Convert function regno to name
static const char*
mcore_register_name (struct gdbarch *gdbarch, int regno)
{
  asm("int3");
  return 0;
}

...
  set_gdbarch_register_name(gdbarch, mcore_register_name);  // Register this


But these functions were not called for `load' command. They might be
called if it necessary.

(*2) Implementation break-point

I tried to set break-point in addresss 0x100, the below functon was called:

static
int mcore_kind_from_pc(struct gdbarch* gdbarch, CORE_ADDR* addr)
{
  asm("int3");
  return 0;
}

where, *addr = 0x100. I guessed that this function could just suitable value.
If we have to distingish break-point mechanizm for some reason,
return special value according to `gdbarch' or `addr'.

This function was called from:

gdb-10.2.mcore-elf/gdb/gdbarch.c:2875

int
gdbarch_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr)
{
  gdb_assert (gdbarch != NULL);
  gdb_assert (gdbarch->breakpoint_kind_from_pc != NULL);
  if (gdbarch_debug >= 2)
    fprintf_unfiltered (gdb_stdlog, "gdbarch_breakpoint_kind_from_pc called\n");
  return gdbarch->breakpoint_kind_from_pc (gdbarch, pcptr);
}

I see. Everything about configuration for MCORE will be checked.
If there are somethign to be not done, `gdb_assert' will check it
suitably.

And consequently, the below function was called:

static
const unsigned char* mcore_from_kind(gdbarch* handle, int kind, int* size)
{
  asm("int3");
  return 0;
}

where, `kind' was the value which `mcore_kind_from_pc' returned. I guessed
that this function sould return the break-point instruction. So I
investigated that MCORE special break-point instruction.
That is,

      sim_engine_halt (CPU_STATE (cpu), cpu, NULL, PC,
		       sim_stopped, SIM_SIGTRAP);

like above. If such a code exists, that is the instruction I looked for.
If not, just return illegal opcode.

Anyway, I found:

gdb-10.2.mcore-elf/sim/mcore/interp.c:414

		case 0x0:				/* bkpt */
		  pc -= 2;
		  sim_engine_halt (sd, cpu, NULL, pc - 2,
				   sim_stopped, SIM_SIGTRAP);


I wondered that above code subtracted 2 from `pc' and
specfied `pc - 2' were not correct. But still remained it.

I assembled like below code.

	.text
	nop
	bkpt
	nop
	nop

and disassemble the result and got below:


c.o:     file format elf32-mcore-little


section .text disassemble:

00000000 <.text>:
   0:	1200      	mov	r0, r0
   2:	0000      	bkpt
   4:	1200      	mov	r0, r0
   6:	1200      	mov	r0, r0

I confirmed that `bkpt' instruction opcode was 0x0000.
So that `mcore_from_kind' became like below:

static
const unsigned char* mcore_from_kind(gdbarch* handle, int kind, int* size)
{
  static unsigned char bkpt[] = { 0, 0 };
  *size = sizeof bkpt;
  return &bkpt[0];
}

`run' command after `break' command will call `sim_write' which
specifies address 0x100 and value 0x0000.

I tried to execute `run' command and the result was:

gdbarch.c:2331: internal-error: type* gdbarch_register_type(gdbarch*, int): Assertion `gdbarch->register_type != NULL' failed.
A problem internal to GDB has been detected,
further debugging may prove unreliable.
Quit this debugging session? (y or n)

This was the `gdb_assert' checking, and I noticed that configuration fuction
was not enough.

static struct type*
mcore_register_type(gdbarch* handle, int regno)
{
...

  set_gdbarch_register_type(gdbarch, mcore_register_type);  // Missed
  

Now the break-point is hit, simulator should stop at address 0x100.

#if 0		  
		  pc -= 2;
#endif		  
		  sim_engine_halt (sd, cpu, NULL, pc - 2,
				   sim_stopped, SIM_SIGTRAP);

As I described above, `pc -= 2ï¼›' was not correct.
After this, address 0x100 instruction was changed to `nop' instruction
suitably. And then the below function was called:

static void
mcore_frame_this_id (struct frame_info *this_frame, void **this_cache,
		     struct frame_id *this_id)
{
...

static struct frame_unwind mcore_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mcore_frame_this_id,                      // This member
  mcore_frame_prev_register,
  nullptr,
  default_frame_sniffer
};
...

  frame_unwind_append_unwinder(gdbarch, &mcore_frame_unwind);  // Register

It's not clear that how this function should work. So I reamined it
as empty function.

By above fix, break-point facility becomes to work well. I know that
this is not complete. But once instaledl new gdb.

And tried installed new gdb like below:

M-x gdb
Run gdb (like this): mcore-elf-gdb --annotate=3 test000.elf -x gdbcom.000
...
(mcore-elf-gdb) run
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_mcore/test000.elf 

Breakpoint 1, start () at start.S:3
(mcore-elf-gdb) 
Debugger trace/breakpoint trap

Unexpected trap occured. But if I executed ./gdb from gdb,
no `int3' instrcution stop ./gdb.

I just exectued installed gdb from command line:

% mcore-elf-gdb -q -x gdbcom start.elf
Reading symbols from start.elf...
Connected to the simulator.
Loading section .text, size 0x8 lma 0x100
Start address 0x100
Transfer rate: 64 bits in <1 sec.
Breakpoint 1 at 0x100: file start.S, line 3.
Breakpoint 2 at 0x106: file start.S, line 7.
(mcore-elf-gdb) run
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_mcore/start.elf 

Breakpoint 1, start () at start.S:3
3		nop
(mcore-elf-gdb) c
Continuing.

Breakpoint 2, end () at start.S:7
7		nop
(mcore-elf-gdb) quit
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) y
%

OK, it worked well. I wondered why mcore-elf-gdb stoped by `int3' instruction
if I executed from `emacs' M-x gdb. I also tried with 

--annotate=3

option and confirmed that it worked well.

Then I tried like below:

M-x gdb
gdb --annotate=3 mcore-elf-gdb

(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_mcore/
(gdb) run -q -x gdbcom start.elf

Now the below function was called:

static const char*
mcore_register_name (struct gdbarch *gdbarch, int regno)
{
  asm("int3");
  return 0;
}

This reason was not clear, but acutally it was called. Anyway
I just implemented this function.

`mcore-tdep.c' at this point is uploaded at this web page. Of cause,
this is not complete ersion but it works for `test000.elf'.



