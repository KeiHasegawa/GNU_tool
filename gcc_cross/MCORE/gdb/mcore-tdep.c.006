#include "defs.h"
#include "value.h"
#include "arch-utils.h"
#include "regcache.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "dis-asm.h"
#include "dwarf2/frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "trad-frame.h"
#include "opcodes/mcore-opc.h"
#include <numeric>
#include <cassert>

static int mcore_register_sim_regno(gdbarch*, int regno)
{
  return regno;
}

const int pc_regno = 64;
const int sp_regno = 0;

static int mcore_dbg_reg_to_regno(gdbarch*, int regno)
{
  if (regno == 16)
    return 2;
  if (regno == 18)
    return 8;
  return regno;
}

static const char* mcore_register_name(gdbarch*, int regno)
{
  if (regno == pc_regno)
    return "pc";
  if (regno == sp_regno)
    return "sp";

  if (regno < 16) {
    static const char* name[] = {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"};
    return name[regno];
  }

  if (regno < 32) {
    static const char* name[] = {
      "alt0", "alt1", "alt2", "alt3", "alt4", "alt5", "alt6", "alt7",
      "alt8", "alt9", "alt10", "alt11", "alt12", "alt13", "alt14", "alt15"};
    return name[regno-16];
  }

  int n = regno - 32;
  static const char* name[] = {
    "sr", "ver", "esr", "fsr", "epc", "efp",
    "ss0", "ss1", "ss2", "ss3", "ss4", "gcr", "gsr"
  };
  if (n < sizeof name/sizeof name[0])
    return name[n];
  return 0;
}

static void
mcore_extract_return_value(type* valtype, regcache* regs, gdb_byte *valbuf)
{
  ULONGEST tmp;
  regcache_cooked_read_unsigned(regs, 2, &tmp);
  store_unsigned_integer(valbuf, 4, BFD_ENDIAN_LITTLE, tmp);
  int len = TYPE_LENGTH(valtype);
  if (len < 4)
    return;
  regcache_cooked_read_unsigned(regs, 3, &tmp);
  store_unsigned_integer(valbuf+4, 4, BFD_ENDIAN_LITTLE, tmp);
}

static return_value_convention
mcore_return_value(gdbarch*, value* function, type* valtype, regcache* regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  auto code = valtype->code();
  switch (code) {
  case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
    if (readbuf) {
      ULONGEST addr;
      regcache_raw_read_unsigned(regcache, 2, &addr);
      read_memory(addr, readbuf, TYPE_LENGTH(valtype));
    }
    return RETURN_VALUE_ABI_RETURNS_ADDRESS;
  }

  if (writebuf)
    asm("int3");

  if (readbuf)
    mcore_extract_return_value(valtype, regcache, readbuf);
  
  return RETURN_VALUE_REGISTER_CONVENTION;
}

static type* mcore_register_type(gdbarch* gdbarch, int regno)
{
  switch (regno) {
  case pc_regno: return builtin_type(gdbarch)->builtin_func_ptr;
  case sp_regno: return builtin_type(gdbarch)->builtin_data_ptr;
  default:       return builtin_type(gdbarch)->builtin_int32;
  }
}

inline void
register_info(gdbarch* gdbarch,ui_file* file, frame_info* frame, int regno)
{
  const char* name = mcore_register_name(gdbarch, regno);
  if (!name)
    return;
  uint32_t value = frame_unwind_register_unsigned(frame, regno);
  fprintf_filtered (file, "%s\t0x%08x\t%d\n", name, value, value);
}

static void
mcore_print_registers_info(gdbarch* gdbarch, ui_file* file,
			   frame_info* frame, int regno, int cpregs)
{
  if (regno >= 0)
    return register_info(gdbarch, file, frame, regno);

  int N = gdbarch_num_regs(gdbarch);
  for (int i = 0 ; i != N ; ++i)
    register_info(gdbarch, file, frame, i);
}

static CORE_ADDR mcore_skip_prologue(gdbarch*, CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  if (!find_pc_partial_function (pc, nullptr, &func_addr, &func_end))
    return pc;
  
  symtab_and_line sal = find_pc_line (func_addr, 0);
  if (sal.end && sal.end < func_end)
    return sal.end;

  return pc;
}

struct mcore_frame {
  bool available;
  CORE_ADDR pc;
  CORE_ADDR prev_sp;
  struct prologue_t {
    CORE_ADDR start;
    CORE_ADDR end;
  } prologue;
  trad_frame_saved_reg saved_reg[64];
};

inline int init_saved_reg(int no, trad_frame_saved_reg& sr)
{
  sr.addr = -1;
  sr.realreg = no;
  return no + 1;
}

inline bool canbe_prologue_start(uint32_t insn)
{
  if (insn == 0x00cf) { // jmp	r15
    return true;
  }

  if (insn == 0x2470) { // subi	r0, 8
    return true;
  }

  if (insn == 0x24f0) { // subi	r0, 16
    return true;
  }

  if (insn == 0x2570) { // subi	r0, 24
    return true;
  }

  if (insn == 0x25f0) { // subi	r0, 32
    return true;
  }

  return false;
}

extern const struct inst mcore_table[140];
extern const unsigned short imsk[]; /*
modify opcodes/mcore-dis.c
//static
const unsigned short imsk[] = {
				    */

static mcore_frame* mcore_frame_create(frame_info *frame)
{
  using namespace std;
  auto ret = new mcore_frame;
  int N = sizeof ret->saved_reg/sizeof ret->saved_reg[0];
  accumulate(&ret->saved_reg[0], &ret->saved_reg[N], 0, init_saved_reg);
  ret->pc = get_frame_pc(frame);
  ret->prev_sp = get_frame_sp(frame);
  auto block_addr = get_frame_address_in_block(frame);  
  bool found = find_pc_partial_function(block_addr, nullptr,
					&ret->prologue.start,
					&ret->prologue.end);
  if (!found) {
    ret->available = false;    
    ret->prologue.start = ret->prologue.end = ret->pc;
    return ret;
  }
  ret->available = true;
  for (auto addr = ret->prologue.start ; ; addr -= 2) {
    ULONGEST insn;
    if (!safe_read_memory_unsigned_integer(addr, 2, BFD_ENDIAN_LITTLE, &insn))
      return ret;
    if (canbe_prologue_start(insn)) {
      ret->prologue.start = addr;
      return ret;
    }
  }
}

static void mcore_frame_this_id(frame_info *frame, void **ptr, frame_id *id)
{
  auto pf = reinterpret_cast<mcore_frame*>(*ptr);
  if (!pf)
    *ptr = pf = mcore_frame_create(frame);
  
  if (!pf->available)
    *id = frame_id_build_unavailable_stack(pf->prologue.start);
  else
    *id = frame_id_build(pf->prev_sp, pf->prologue.start);
}

static value*
mcore_frame_prev_register(frame_info *frame, void **ptr, int regno)
{
  if (regno == sp_regno) {
    auto sp = get_frame_sp(frame);
    return frame_unwind_got_constant(frame, regno, sp);
  }

  if (regno == pc_regno) {
    auto r15 = frame_unwind_register_unsigned(frame, 15);
    return frame_unwind_got_constant(frame, regno, r15);
  }

  auto pf = reinterpret_cast<mcore_frame*>(*ptr);
  if (!pf)
    *ptr = pf = mcore_frame_create(frame);
  return trad_frame_get_prev_register(frame, &pf->saved_reg[0], regno);
}

static frame_unwind mcore_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mcore_frame_this_id,
  mcore_frame_prev_register,
  nullptr,
  default_frame_sniffer
};

static CORE_ADDR mcore_frame_base_address(frame_info *frame, void **ptr)
{
  asm("int3");
  return 0;
}

static frame_base mcore_frame_base = {
  &mcore_frame_unwind,
  mcore_frame_base_address,
  mcore_frame_base_address,
  mcore_frame_base_address
};

static int mcore_kind_from_pc(gdbarch*, CORE_ADDR* addr)
{
  return 0;
}

static const unsigned char* mcore_from_kind(gdbarch*, int kind, int* size)
{
  static unsigned char bkpt[] = { 0, 0 };
  *size = sizeof bkpt;
  return &bkpt[0];
}

static void calc_sp(int* nth, value* arg, CORE_ADDR* sp)
{
  auto arg_type = check_typedef(value_type(arg));
  auto code = arg_type->code();
  switch (code) {
  case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
    asm("int3");
  }
  
  int len = TYPE_LENGTH(arg_type);
  if (len <= 4) {
    if (*nth < 6) {
      ++*nth;
      return;
    }
    *sp -= 4;
    ++*nth;
    return;
  }

  assert(len == 8);
  if (*nth & 1)
    ++*nth;
  if (*nth + 1 < 6) {
    *nth += 2;
    return;
  }
  *sp -= 8;
  *nth += 2;
}

static void set_arg(int* nth, value* arg, regcache* rc, CORE_ADDR sp)
{
  auto arg_type = check_typedef(value_type(arg));
  auto code = arg_type->code();
  switch (code) {
  case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
    asm("int3");
  }

  auto val = value_contents(arg);
  int len = TYPE_LENGTH(arg_type);
  if (len <= 4) {
    if (*nth < 6) {
      auto regval = extract_unsigned_integer(val, 4, BFD_ENDIAN_LITTLE);    
      regcache_cooked_write_unsigned(rc, 2+*nth, regval);
      ++*nth;
      return;
    }
    CORE_ADDR addr = sp + 4 * (*nth - 6);
    write_memory(addr, val, 4);
    ++*nth;
    return;
  }

  assert(len == 8);
  if (*nth & 1)
    ++*nth;
  if (*nth + 1 < 6) {
    auto regval = extract_unsigned_integer(val, 8, BFD_ENDIAN_LITTLE);    
    uint32_t hi = regval >> 32;
    uint32_t lo = regval;
    regcache_cooked_write_unsigned(rc, 2+*nth+0, lo);
    regcache_cooked_write_unsigned(rc, 2+*nth+1, hi);
    *nth += 2;
    return;
  }

  CORE_ADDR addr = sp + 4 * (*nth - 6);
  write_memory(addr, val, 8);
  *nth += 2;
}

static CORE_ADDR
mcore_push_dummy_call(gdbarch* arch, value* func, regcache* rc,
		      CORE_ADDR bp_addr, int nargs, value** argv, CORE_ADDR sp,
		      function_call_return_method rm,
		      CORE_ADDR struct_addr)
{
  using namespace std;
  regcache_cooked_write_unsigned(rc, 15, bp_addr);
  int nth = 0;
  for (int i = 0 ; i != nargs ; ++i)
    calc_sp(&nth, argv[i], &sp);
  regcache_cooked_write_unsigned(rc, sp_regno, sp);
  nth = 0;
  for (int i = 0 ; i != nargs ; ++i)
    set_arg(&nth, argv[i], rc, sp);
  return sp;
}

static value*
mcore_dwarf2_prev_register(frame_info* frame, void**, int regno)
{
  assert(regno == pc_regno);
  auto r15 = frame_unwind_register_unsigned(frame, 15);
  return frame_unwind_got_constant(frame, regno, r15);
}

static void
mcore_dwarf2_frame_init_reg(gdbarch*, int regno,
			    dwarf2_frame_state_reg *reg, frame_info*)
{
  switch (regno) {
  case pc_regno:
    reg->how = DWARF2_FRAME_REG_FN;
    reg->loc.fn = mcore_dwarf2_prev_register;
    return;
  case sp_regno:
    reg->how = DWARF2_FRAME_REG_CFA;
    return;
  }
}

static struct gdbarch* mcore_gdbarch_init(gdbarch_info info, gdbarch_list*)
{
  struct gdbarch *gdbarch = gdbarch_alloc (&info, 0);

  set_gdbarch_num_regs(gdbarch, pc_regno+1);
  set_gdbarch_register_type(gdbarch, mcore_register_type);
  set_gdbarch_register_sim_regno(gdbarch, mcore_register_sim_regno);
  set_gdbarch_dwarf2_reg_to_regnum(gdbarch, mcore_dbg_reg_to_regno);
  set_gdbarch_stab_reg_to_regnum(gdbarch, mcore_dbg_reg_to_regno);
  set_gdbarch_register_name(gdbarch, mcore_register_name);

  set_gdbarch_pc_regnum(gdbarch, pc_regno);
  set_gdbarch_sp_regnum(gdbarch, sp_regno);
  set_gdbarch_print_registers_info(gdbarch, mcore_print_registers_info);

  set_gdbarch_ptr_bit(gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_addr_bit(gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_return_value(gdbarch, mcore_return_value);

  set_gdbarch_skip_prologue (gdbarch, mcore_skip_prologue);
  frame_base_set_default (gdbarch, &mcore_frame_base);
  dwarf2_append_unwinders(gdbarch);
  frame_unwind_append_unwinder(gdbarch, &mcore_frame_unwind);

  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_breakpoint_kind_from_pc(gdbarch, mcore_kind_from_pc);
  set_gdbarch_sw_breakpoint_from_kind(gdbarch, mcore_from_kind);
  set_gdbarch_push_dummy_call(gdbarch, mcore_push_dummy_call);

  set_gdbarch_char_signed(gdbarch, 0);
  set_gdbarch_int_bit(gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit(gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);

  set_gdbarch_wchar_signed(gdbarch, 0);
  set_gdbarch_wchar_bit(gdbarch, 2 * TARGET_CHAR_BIT);

  set_gdbarch_double_bit(gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_double_format(gdbarch, floatformats_ieee_double);
  set_gdbarch_long_double_bit(gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_format(gdbarch, floatformats_ieee_double);

  set_gdbarch_believe_pcc_promotion(gdbarch, 1);

  dwarf2_frame_set_init_reg(gdbarch, mcore_dwarf2_frame_init_reg);

  return gdbarch;
}

void _initialize_mcore_tdep();
void
_initialize_mcore_tdep()
{
  register_gdbarch_init(bfd_arch_mcore, mcore_gdbarch_init);
}

