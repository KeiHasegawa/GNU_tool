(*2) gdb fix

I created the 2nd simple program like below:

% cat ../default.S
	.text
start:
	lui	sp, %hi(stack)
	addi	sp, sp, %lo(stack)
	call	main
end:
	nop
% cat test.c
int f(int a, int b)
{
  return a + b;
}

int main()
{
  return f(5, 6);
}
% cat ../default.x
SECTIONS {
	 . = 0x100;
	 .text : {}
	 .rodata : {}
	 .data : {}
	 .bss  : {}

	 . = 0x1000;
	 stack = .;
}
% riscv-elf-gcc -o test.s test.c -S
% riscv-elf-as -g -o test.o test.s
% riscv-elf-as -o ../default.o -g ../default.S
% riscv-elf-ld -o test.elf ../default.o test.o -T ../default.x

Then I executed it with riscv-elf-run like below:

% rsicv-elf-run --memory-fill 0xcc --memory-region 0xe00,0x200 test.elf
sim: bad insn len 0x2 @ 0x130: 0x1141
program stopped with signal 4 (Illegal instruction).
%

riscv-elf-run detected illegal instruction at below code:

  len = riscv_insn_length (iw);
  if (len != 4)
    {
      sim_io_printf (sd, "sim: bad insn len %#x @ %#" PRIxTA ": %#" PRIxTW "\n",
		     len, pc, iw);
      sim_engine_halt (sd, cpu, NULL, pc, sim_signalled, SIM_SIGILL);
    }

Here, at address 0x130, object code 0x1141 instruction was located:

00000130 <main>:
 130:	1141                	addi	sp,sp,-16

As far as simulator source code, I thought that 2 bytes instruction became
illegal instruction.

% cat -n test.s
     1		.file	"test.c"
     2		.option nopic
=>   3		.attribute arch, "rv32i2p1_m2p0_a2p1_f2p2_d2p2_c2p0_zicsr2p0_zifencei2p0"
     4		.attribute unaligned_access, 0
     5		.attribute stack_align, 16
     6		.text
     7		.align	1
     8		.globl	f
     9		.type	f, @function
    10	f:
    11		addi	sp,sp,-32
...
%

Then I deleted above (=>) 3rd line and assembled test.s, link to generat
test.elf and confirmed that:

00000140 <main>:
 140:	ff010113          	addi	sp,sp,-16  # OK

Fine. This illustrated that compile option was not suitable in this case.

