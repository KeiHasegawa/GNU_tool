d10v-elf-as の調査

残念ながら D10V のインストラクションセットマニュアルがないため, 本当は良くないが
アセンブラの実装からインストラクションセットを調べるという方法を取る.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.d10v-elf/gas
% ./as-new -o a.o a.S
% d10v-elf-objdump -d a.o > a.o.objdump

期待通りアセンブルできている.

M-x gdb
gdb --annotate=3 ./as-new

(gdb) b input_file_get
(gdb) run -o a.o a.S
...
input_file_get のブレークポイントにヒット
(gdb) finish
(gdb) p input_buffer
$2 = "\t.text\nstart:\n\tnop || nop\n\tnop || nop\nend:\n", '\000' <repeats 32724 times>
(gdb)

ファイルを読めている.

話が逸脱するようだが

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.d10v-elf/opcodes/d10v-opc.c

に

const struct d10v_opcode d10v_opcodes[] = {
  { "abs", SHORT_2, 1, EITHER, PAR|WF0, 0x4607, 0x7e1f, { RDST } },
  { "abs", SHORT_2, 1, IU, PAR|WF0, 0x5607, 0x7eff, { ADST } },
...
を発見. これはインストラクションのテーブルらしい.

struct d10v_opcode {
  const char *name;
  int format;
  int cycles;
  int unit;
  int exec_type;
  long opcode;
  long mask;
  unsigned char operands[6];
};

abs の部分のマクロ展開は以下

  { "abs", 1, 1, 0, 4|128, 0x4607, 0x7e1f, { (((((0) + 1) + 1) + 1) + 1) } },

試しに

	.text
start:
	abs	r0, r0
	nop || nop
end:

をアセンブルしてみた.

a.S: Assembler messages:
a.S:3: Error: bad opcode or operands
a.S:3: Error: could not assemble: abs r0

だめらしい.

	.text
start:
	abs	a0, a1
	nop || nop
end:

これもだめ.
エラーメッセージは以下から出ている:

static struct d10v_opcode *
find_opcode (struct d10v_opcode *opcode, expressionS myops[])
{
...
  if (!match)
    {
      as_bad (_("bad opcode or operands"));
      return 0;
    }

(gdb) b find_opcode
(gdb) run
...
find_opcode のブレークポイントにヒット
(gdb) p *opcode
$5 = {name = 0x8117aa6 "abs", format = 1, cycles = 1, unit = 0, 
  exec_type = 132, opcode = 17927, mask = 32287, 
  operands = "\004\000\000\000\000"}
(gdb) p/x *opcode
$6 = {name = 0x8117aa6, format = 0x1, cycles = 0x1, unit = 0x0, 
  exec_type = 0x84, opcode = 0x4607, mask = 0x7e1f, operands = {0x4, 0x0, 
    0x0, 0x0, 0x0, 0x0}}
(gdb)

ここで視点を変えてシミュレータでどう扱っているか調べてみた.

/* abs */
void
OP_4607 (SIM_DESC sd, SIM_CPU *cpu)
{
  int16 tmp;
  trace_input ("abs", OP_REG, OP_VOID, OP_VOID);
  SET_PSW_F1 (PSW_F0);
  tmp = GPR(OP[0]);
  if (tmp < 0)
    {
      tmp = - tmp;
      SET_PSW_F0 (1);
    }
  else
    SET_PSW_F0 (0);
  SET_GPR (OP[0], tmp);
  trace_output_16 (sd, tmp);
}

ということは...

	.text
start:
	abs	r0
	nop || nop
end:

これでアセンブル成功. objdump の結果は

00000000 <start>:
   0:	23 03 de 00 	abs	r0	||	nop	
   4:	2f 00 5e 00 	nop		||	nop	

のようになっている.
以下も試してみた.

	.text
start:
	abs	a0
	nop || nop
end:

アセンブル成功. objdump の結果は

00000000 <start>:
   0:	2f 00 56 07 	nop		||	abs	a0
   4:	2f 00 5e 00 	nop		||	nop	

そういうことらしい.

以下も試してみた
	.text
start:
	abs	r0
	abs	a0
	nop || nop
end:

00000000 <start>:
   0:	63 03 d6 07 	abs	r0	->	abs	a0
   4:	2f 00 5e 00 	nop		||	nop	
