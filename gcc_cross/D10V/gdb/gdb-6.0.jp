d10v-elf-gdb で nop を数命令置いたプログラムが期待通り動作しない原因を調査してみる.

(gdb) b sim_write
(gdb) run
...
Breakpoint 1, sim_write (sd=0x1, addr=256, buffer=0x82ec268 "o", size=12) at interp.c:767

sim_write のブレークポイントにヒット

(gdb) x/12bx buffer
0x82ec268:	0x6f	0x00	0x5e	0x00	0x2f	0x00	0x5e	0x00
0x82ec270:	0x2f	0x00	0x5e	0x00
(gdb) 

objdump の結果は

00000100 <start>:
 100:	6f 00 5e 00 	nop		->	nop	
 104:	2f 00 5e 00 	nop		||	nop	

00000108 <end>:
 108:	2f 00 5e 00 	nop		||	nop	

なのでここは正しい.

xfer_mem にステップインして以下を確認

(gdb) x/12bx memory
0xb7bd4108:	0x6f	0x00	0x5e	0x00	0x2f	0x00	0x5e	0x00
0xb7bd4110:	0x2f	0x00	0x5e	0x00
(gdb)

(gdb) c
...
Breakpoint 1, sim_write (sd=0x1, addr=260, buffer=0x82b9e2c <breakpoint> "/\220^", size=4) at interp.c:767

これは start にセットしたブレークポイント addr = 260 であって 256 ではない. これは...

xfer_mem にステップインして以下を確認

(gdb) x/12b memory-4
0xb7bd4108:	0x6f	0x00	0x5e	0x00	0x2f	0x90	0x5e	0x00
0xb7bd4110:	0x2f	0x00	0x5e	0x00
(gdb)

確かに書き替えられてはいる.


(gdb) b sim_resume
(gdb) c
...
sim_resume のブレークポイントにヒット
(gdb)


  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, NULL,
						imap_register);

(gdb) x/12bx mem
0xb7bb3108:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0xb7bb3110:	0x00	0x00	0x00	0x00
(gdb)

違うところから読み出している.

(gdb) p/x 0xb7bd4108 - 0xb7bb3108
$4 = 0x21000
(gdb) 

現状は 0x100 番地にコードを配置している. 試しに 0x21100 に配置してみる:


00021100 <start>:
   21100:	6f 00 5e 00 	nop		->	nop	
   21104:	2f 00 5e 00 	nop		||	nop	

00021108 <end>:
   21108:	2f 00 5e 00 	nop		||	nop	

同じように確かめてみると
今度はブレークポイントは 0x2110c 番地に置かれていた. これは...

そしてやはり sim_resume で読み出しているところは命令を置いたはずのところから
は読み出せていない.

行番号が正しいかどうか確認してみた.

% d10v-elf-addr2line -e test.elf -a 0x100
0x00000100
/home/khasegawa/lang/53_GNU_tool/gcc_cross/D10V/test/test001/test.S:4
%

test.S の 4 行目になっているが 3 行目が正しい.

% d10v-elf-addr2line -e test.o -a 0
0x00000000
/home/khasegawa/lang/53_GNU_tool/gcc_cross/D10V/test/test001/test.S:4
%

これはアセンブル時にすでにできていなさそうだが...

test.S を以下のように修正した.
% cat test.S
	.text
start:
	nop || nop
	nop || nop
	nop || nop
end:
	nop || nop
% d10v-elf-addr2line -e test.o -a 0
0x00000000
/home/khasegawa/lang/53_GNU_tool/gcc_cross/D10V/test/test001/test.S:3
%

なるほどそういうわけだった.

(gdb) run
Start address 0x100
Transfer rate: 16 bits/sec.
Breakpoint 1 at 0x104: file test.S, line 3.

Breakpoint 1, sim_write (sd=0x1, addr=260, buffer=0x82b9e2c <breakpoint> "/\220^", size=4) at interp.c:767
(gdb)

しかしアドレスが 0x104 になるのは変わらない. しかしこれは gdb の共通部分の問題というか
gdb-6.0 のときは 0x100 ではなくて 0x104 にブレークポイントをセットしていたらしい.

ところでインターネットを検索していたら gdb の overlay 機能が説明されているページを発見.

https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_12.html

そこに

d10v-elf-gcc

を発見.

gcc-2.7.2.3 にはなし
gcc-2.95.3  にもなし
gcc-3.0.1 にもなし
gcc-3.2 にもなし. ここに d30v が出てくる.
なさそう.

	後になって Z8000 の gcc をインターネットのとあるサイトで発見したが, そのソースに
	d10v ディレクトリが含まれていた. z8kgcc で検索するとひっかかる.

ブレークポイントがずれる原因は

d10v_skip_prologue (CORE_ADDR pc)

にあった. ここで pc = 256 に対して 260 を返している. d10v_skip_prologue に
問題があるのかと思ったが, そうではなかった.

同じことを h8300-elf-gdb で確認したところ

h8300_skip_prologue は呼び出されていない.


