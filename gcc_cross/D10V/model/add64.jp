現状 c.c にある int64 + int64 ができていない.

f の先頭アドレスで停止して

(d10v-elf-gdb) x/8bx $sp
0xff4:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x06
(d10v-elf-gdb) p $r0
$1 = 0
(d10v-elf-gdb) p $r1
$2 = 0
(d10v-elf-gdb) p $r2
$3 = 0
(d10v-elf-gdb) p $r3
$4 = 5
(d10v-elf-gdb)

なので引数は渡されている.


	ld2w	r2, @(4, r14)
	ld2w	r10, @(20, r14)
	add2w	r2, r10
=>	ld2w	r0, @r14

(d10v-elf-gdb) p $r2
$7 = 0
(d10v-elf-gdb) p $r3
$8 = 5
(d10v-elf-gdb) p $r10
$9 = 0
(d10v-elf-gdb) p $r11
$10 = 66
(d10v-elf-gdb)

分かりにくいがこの時点ではまだ add2w は実行されていない. r11 が 66 になっているのが
違っている.
ここでさらにステップ実行すると

($r2, $r3) = (0, 5)
($r10, $r11 = (0, 66)
なので

($r2, $r3) = (0, 71)

になる. add2w は正しく動いているが加算しているものが間違えている.

(d10v-elf-gdb) x/8bx $r14+20
0xffc:	0x00	0x00	0x00	0x42	Cannot access memory at address 0x1000
(d10v-elf-gdb)

これは期待しない結果. 何か勘違いしている. ここで勘違いに気付く.

0x42 = 66

なので上のダンプの結果は合っている. 問題は引数の b が $r14 相対 16 にあるとして
コード生成していること.


(d10v-elf-gdb) x/8bx $r14+16
0xff8:	0x00	0x00	0x00	0x06	0x00	0x00	0x00	0x42
(d10v-elf-gdb) x/8bx $r14+12
0xff4:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x06
(d10v-elf-gdb) 

$r14 相対 12 ならば正しそう.

f:
	st	r13, @-sp
	st	r14, @-sp
	subi	sp, 8		; f のフレームサイズは 8

     -4	+---------------+
	|  r14_{old}	|
     -2	+---------------+ 
	|  r13_{old}	|
      0	+---------------+ <- sp_{old}

r13, r14 のサイズは 2 だから. 間違えている. 4 + 8 = 12 という計算が正しい.

これを修正して c.c は期待通り動作しているが, まだキャリービット付きで計算できていない.
キャリービットは cr0 (psw) レジスタのビット 0.


	+-+-+-+-+-+-+-+-+-+
	| | | | | | | | | |
	+-+-+-+-+-+-+-+-+-+
	 E D I R M S F F C
	 A B E P D T 0 1

これを参照する adc 命令のようなものはない.

しかし F0 ならばジャンプするとかはある.
C ならばジャンプはない.


	cpfg	f0, c    ; f0 に c をコピー
	brf0t.s	label	 ; f0 ならばジャンプ.
			 ; つまりキャリービットがセットされていたらジャンプ.

以下のようにコード生成すればよい:

	ld2w	r2, @(4, r14)
	ld2w	r10, @(16, r14)
	add2w	r2, r10			; 下位 32 ビット

	ld2w	r0, @r14
	ld2w	r8, @(12, r14)
	cpfg	f0, c
	add2w	r0, r8			; 上位 32 ビット	
	brf0f.s	.M1
	ldi.s	r8, 0
	ldi.s	r9, 1
	add2w	r0, r8
.M1:
