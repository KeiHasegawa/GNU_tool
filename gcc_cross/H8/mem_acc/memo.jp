メモリアクセス

(*1) 実行

プログラムが意図しないアドレスにジャンプしてしまうことがある. 例えば

test000.S

は意図的に範囲外へジャンプしている. 通常通りビルドしてシミュレーションしてみた.

% h8300-elf-as -g test000.S -o test000.o
% h8300-elf-ld -o test000.elf test000.o -T test000.x -Map test000.map
% h8300-elf-gdb test000.elf

...
(gdb) target sim
Connected to the simulator.
(gdb) load
Loading section .text, size 0xa vma 0x100
Start address 0x100
Transfer rate: 80 bits in <1 sec.
(gdb) b start
Breakpoint 1 at 0x100: file test000.S, line 3.
(gdb) run
Starting program: /home/khasegawa/lang/53_GNU_tool/gcc_cross/mem_acc/test000.elf 

Breakpoint 1, start () at test000.S:3
(gdb) n
(gdb) 
0x00002108 in ?? ()
(gdb) stepi
0x0000210a in ?? ()
(gdb) c
Continuing.

Program received signal SIGILL, Illegal instruction.
0x00000002 in ?? ()
(gdb)

こんな感じである. ロードされたプログラムは 0x100 番地に 0xa バイトなのだから,
その範囲外を実行していて, それをシミュレータ自身も認識できているはずである. 
プログラムの制御が 0x2108 番地に移った時点でシミュレータはエラーを報告することがで
きたかもしれない.

H8 の場合 nop の命令コードが 0x0000 なので, 仮にシミュレータがメモリの初期値を 0 として
いればずっと nop を実行し続けたかもしれない.

上の実行が停止したのは 0 番地を実行したからなのかどうかは不明で, それはシミュレータが
自身の判断で停止し, そしてシミュレータに停止した理由を gdb が問い合わせて, その結果

Program received signal SIGILL, Illegal instruction.

という不可思議なメッセージを出している.

勿論, ロードされた .text セクション以外を意図的に実行するプログラムもある. しかし
その場合でもプログラムが配置されている領域は限定されている. 

現実世界ではそこにメモリがあってアクセス可能だから実行しているというのが H8 のシミュレータ
の開発者の言い分なのかもしれない. 実際そういうシミュレーションを行なうべき場面は確かに存在する.

ところで上の現象で Illegal instruction が検出される部分を調査してみた:

static void
step_once (SIM_DESC sd, SIM_CPU *cpu)
{
...
  pc = h8_get_pc (sd);
  if (pc == 0x10002)
    asm("int3");          ここで停止していることを確認した
...   
      cidx = h8_get_cache_idx (sd, pc);   cidx = 0xffff になり
      if (cidx == (unsigned short) -1 ||
	  cidx >= sd->sim_cache_size)
	goto illegal;                  そしてここで illegal にジャンプしていた

おそらくだが, 現実世界では 2 番地を実行するのが期待値. おやと思うのは, それでは 0x10000
に対しては何をシミュレーションしていたかとうことであるが, もはやどうでもいいか.

(*2) ロード/ストア

test001.S

はわざとらしく, 以下のようなことをしている:

int a = 0x1234;
int b = 0x5678;
int tmp;

void swap_ab()
{
  tmp = a;
  a = b;
  b = tmp;
}

プログラムのロードでは .text, .data セクションが対象になり .bss セクションは
対象外である.

このプログラムが 0x300 番地に配置された tmp にアクセスすることはプログラマが明らかに
意図した動作である.

シミュレータは 0x300 番地をプログラムがアクセスしたときにどのように扱うべきか.

仮に test001 のプログラムが 0x1000 番地にアクセスしたらエラーである. 現実世界はそこに
メモリがあるからそれなりに動作するが, これは本当にプログラマが望んだシミュレータの
動作だろうか.

(*3) メモリ割り当て

(*1) や (*2) の問題を解消するのがメモリ割り当てという概念というか, gdb のコマンドになる.

    => 「BPF プログラミング」も参照. BPF のシミュレータはすべてのユーザーがメモリを
        自分で割り当てる必要がある.

使い方は, プログラムをロードした後, アクセスする領域をシミュレータに伝えるという
ものでロードした領域であれば, このコマンドで改めて伝える必要はない.

(*1) は範囲外にプログラムの制御が飛び出した時点でエラーを捕えるために, 何もメモリ割り当て
しない.

(*2) は .bss を使うから 0x300 番地から 2 バイトだけメモリ割り当てする. しかし .bss
もロードはしないがメモリを割り当てる仕様にしてもよい.

シミュレータは範囲外のメモリアクセスがあった場合エラーとして実行を停止することができるようになる.

(*4) H8 のシミュレータのメモリ確保

  memory_size = 0x10000;
  ...
  h8_set_memory_buf (sd, (unsigned char *) 
		     calloc (sizeof (char), memory_size));

  こんな感じである. これは他のシミュレータとは少しやり方が違っているが, まとめて
  メモリを, そして 64 KByte 必ず確保するという意味では同じである.
  
(*5) シミュレータの修正

ほとんどの他のプロセッサのシミュレータはメモリ確保の方法を統一していて, それらはまとめて
固定のメモリを確保するようにしている. しかしその方法を採用すれば 1 バイト単位でメモリ割り当て
を行うことが可能である.

H8 のシミュレータもその方法を採用する修正を入れてみた. このページにある

sim-load.diff
compile.diff
my_cache.cpp

を採用すれば範囲外のメモリアクセスをエラーとして捕えることができる.
シミュレータユーザが行なうことはスタックの領域にメモリを割り当てることだけである.

ターゲットプログラムがヒープを使用するのであれば, やはりメモリを改めて割り当てる必要がある.

