以下のようなプログラムをビルドして実行してみた.

% cat sample.c
#include <stdio.h>

int f(int a, int b)
{
  return a + b;
}

int main()
{
  printf("%d\n", f(5, 6));
  return 0;
}
% h8300-elf-gcc -g -o sample.elf sample.c
% h8300-elf-gdb sample.elf
(gdb) target sim
(gdb) load
Loading section .init, size 0xa vma 0x100
Loading section .text, size 0x11240 vma 0x10c
Loading section .fini, size 0x6 vma 0x1134c
Loading section .rodata, size 0x5c0 vma 0x11354
Loading section .eh_frame, size 0x4 vma 0x11914
Loading section .ctors, size 0x4 vma 0x11918
Loading section .dtors, size 0x4 vma 0x1191c
Loading section .data, size 0x5b8 vma 0x11920
...
(gdb) b start
(gdb) run
(gdb) stepi
(gdb) stepi
Program received signal SIGILL, Illegal instruction.
start () at ../../../../.././newlib/libc/sys/h8300hms/crt0.S:11
11		mov.w	#_edata,r0
(gdb)

start は sample.elf のエントリポイントでそこから 2 命令を実行したところで
Illegal instruction のエラーになったということ.

エラーの直接の原因は不正なオペコードを検出したからなのだが, load コマンドで
プログラムのロードイメージが 64 KByte を超えていたことがそもそもの原因であった.

このエラーはプログラムのリンク時やプログラムのロード時に捉えられるべきだがそうはなっていな
かったということである.
プログラムのロードは函数 sim_load で行なわれている.

ところでこのプログラムのおおよそのサイズだが 0x100 から 0x11920+0x5b8 = 0x11ed8
ということになる.

メモリ空間が 64KB でヒープとスタックを最後の 0x1000 バイトに割り当てるならば
リンカスクリプトファイルを以下のようにする:

% cat 64K.x
MEMORY {
  hoge (rwx) : ORIGIN = 0, LENGTH = 0xe000
}

SECTIONS {
	 . = 0x100;
	 .text : {}
	 .rodata : {}
	 .data : {}
	 .bss : {
	      _bss_start = .;
	 }
	 _bss_end = .;

	 . = 0xe000;
	 _end = .; 

	 . = 0xf000;
	 _stack = .;
}
%

こうすることで .text, .rodata, .data, .bss が 0xe000 バイトに収まらないと以下のように
リンク時にエラーを検出することができる:

% h8300-elf-ld -o sample.elf start.o sample.o -lc -lgcc -T 64K.x
h8300-elf-ld: sample.elf section `.text' will not fit in region `hoge'
%
