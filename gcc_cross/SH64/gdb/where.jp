現状 where コマンドの結果が正しくない.

% sh64-elf-gdb a.elf -x gdbcom -q
...
Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=5, b=6) at a.c:5
5	  return a + b;
#0  f (a=5, b=6) at a.c:5
#1  0x00000000000001ed in main () at a.c:10    ★
...

このため finish コマンドで内部ブレークポイントを 0x1ed にセットすることになり, その
結果 Illegal instruction 例外が発生している.

おそらく 0x1ed はスタックに戻りアドレスを保存していてそこから読み出していて, そして本当に
0x1ed が保存されているから sh64-elf-gdb がそのような動作になっている. sh64-elf-gdb
が 0x1ed を読み出したときにそれを 0x1ec に変更する必要がある.

以下のように共通ソースに直接修正を入れた.

CORE_ADDR
get_frame_pc (struct frame_info *frame)
{
#if 0
  gdb_assert (frame->next != NULL);
  return frame_unwind_pc (frame->next);
#else
  CORE_ADDR ret = frame_unwind_pc (frame->next);
  ret &= (CORE_ADDR)~0 << 1;
  return ret;
#endif  
}

もっと良いやり方が本当はあるかもしれない. コンパイラを修正する方法とデバッガを修正する方法
があるが面倒なのでこれで満足しておく.

この修正により自前の cc1 の生成した hello world 11 のプログラムが sh64-elf-gdb で
期待通り動作している.

この段階での sh-tdep.c を sh-tdep.c.1 として

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.sh64-elf/sim/sh64

を sh64.1.tar としてこのページにアップロードしておく.
