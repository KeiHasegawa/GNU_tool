(*1) SH64
https://ja.wikipedia.org/wiki/SuperH

(*2) binutils のインストール

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG
% gunzip -c ../binutils-2.30.tar.gz | tar xf -
% mv binutils-2.30 binutils-2.30.sh64-elf
% cd binutils-2.30.sh64-elf
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=sh64-elf --enable-obsolete
% make all
% make install

(*3) gdb のインストール

% xz -d -c ../gdb-10.2-1.src/gdb-10.2.tar.xz | tar xf -
% mv gdb-10.2 gdb-10.2.sh64-elf
% cd gdb-10.2.sh64-elf
% rm -r -f bfd
% ln -s ../binutils-2.30.sh64-elf/bfd bfd
% rm -r -f opcodes
% ln -s ../binutils-2.30.sh64-elf/opcodes opcodes
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=sh64-elf --enable-obsolete

Makefile を修正:

all-bfd と all-opcodes を空のターゲットにする.

% make
...
gcc -DHAVE_CONFIG_H -DWITH_DEFAULT_MODEL='"sh5"' -DWITH_ALIGNMENT=STRICT_ALIGNMENT  -DWITH_DEFAULT_TARGET_BYTE_ORDER=BFD_ENDIAN_BIG  -DWITH_HW=1 -DDEFAULT_INLINE=0  -DWITH_SCACHE=16384       -I. -I. -I../common -I./../common -I../../include -I./../../include -I../../bfd -I./../../bfd -I../../opcodes -I./../../opcodes  -g -O2 -c -o sim-load.o -MT sim-load.o -MMD -MP -MF .deps/sim-load.Tpo ./../common/sim-load.c
./../common/sim-load.c: 関数 ‘sim_load_file’ 内:
./../common/sim-load.c:104:30: エラー: マクロ "bfd_section_size" は引数を 2 要求しますが、1 個しか与えられていません
...
%

以下のようにして回避. これと同じエラーが発生するので同様に回避する.

#undef bfd_section_flags
#define bfd_section_flags(ptr) ((ptr)->flags)

#undef bfd_section_name
#define bfd_section_name(ptr) ((ptr)->name)

#undef bfd_section_size
#define bfd_section_size(ptr) ((ptr)->size)

#undef bfd_section_vma
#define bfd_section_vma(ptr) ((ptr)->vma)

#undef bfd_section_lma
#define bfd_section_lma(ptr) ((ptr)->lma)

#undef bfd_section_alignment
#define bfd_section_alignment(ptr) ((ptr)->alignment_power)

#undef bfd_set_section_flags
#define bfd_set_section_flags(ptr, v) ((ptr)->flags = v)

#undef bfd_set_section_name
#define bfd_set_section_name(ptr, v) ((ptr)->name = v)

#undef bfd_set_section_size
#define bfd_set_section_size(ptr, v) ((ptr)->size = v)

#undef bfd_set_section_vma
#define bfd_set_section_vma(ptr, v) ((ptr)->vma = v)

#undef bfd_set_section_lma
#define bfd_set_section_lma(ptr, v) ((ptr)->lma = v)

#undef bfd_set_section_alignment
#define bfd_set_section_alignment(ptr, v) ((ptr)->alignment_power = v)

% make
...
libtool: compile:  gcc -DHAVE_CONFIG_H -I. -D_GNU_SOURCE -I. -I./../include -I./../bfd -I../bfd -DNOBFD=0 -std=gnu99 -Wall -W -Wall -Wno-narrowing -Wwrite-strings -Wmissing-format-attribute -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -pedantic -Wno-long-long -I./../zlib -g -O2 -MT libctf_la-ctf-open.lo -MD -MP -MF .deps/libctf_la-ctf-open.Tpo -c ctf-open.c -o libctf_la-ctf-open.o
In file included from ./../bfd/elf-bfd.h:28,
                 from ctf-open.c:30:
./../include/bfdlink.h:45:6: エラー: ‘enum notice_asneeded_action’ の再定義です
   45 | enum notice_asneeded_action {
...

以下のように修正
./../include/bfdlink.h:
#if 0
enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};
#endif

% make
...
  CXX    dwarf2/macro.o
dwarf2/macro.c: 関数 ‘void dwarf_decode_macro_bytes(dwarf2_per_objfile*, buildsym_compunit*, bfd*, const gdb_byte*, const gdb_byte*, macro_source_file*, const line_header*, const dwarf2_section_info*, int, int, unsigned int, htab_t)’ 内:
dwarf2/macro.c:468:7: エラー: ‘DIAGNOSTIC_PUSH’ was not declared in this scope
  468 |       DIAGNOSTIC_PUSH
      |       ^~~~~~~~~~~~~~~
...

宣言を直接書いて回避

% make
  CXX    gdb_bfd.o
gdb_bfd.c: 関数 ‘void gdb_bfd_init_data(bfd*, stat*)’ 内:
gdb_bfd.c:426:3: エラー: ‘bfd_set_usrdata’ was not declared in this scope; did you mean ‘bfd_set_format’?
  426 |   bfd_set_usrdata (abfd, gdata);
      |   ^~~~~~~~~~~~~~~
...

以下エラーが発生するたびに他のプロセッッサの gdb のビルドを参考にして
エラーを回避する.

% make
...
ビルド成功
% make install

例によって 0x100 番地に nop を数個配置したプログラムを動かしてみた: 
% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
I'm sorry, Dave, I can't do that.  Symbol format `elf32-sh' unknown.  ★
unsupported machine `sh'
gdbcom:2: Error in sourced command file:
unable to create simulator instance
(sh64-elf-gdb) q
%

これもどこかで見たエラーメッセージ. そのうち修正する.

(gdb) b find_sym_fns
(gdb) run
...
  for (const registered_sym_fns &rsf : symtab_fns)
    if (our_flavour == rsf.sym_flavour)
      return rsf.sym_fns;

  error (_("I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."),
	 bfd_get_target (abfd));  ★

(gdb) p our_flavour
$6 = bfd_target_elf_flavour
(gdb)

symtab_fns に bfd_target_elf_flavour がないらしい. coff, aout, ecoff
はある.

elfread.c をビルドに組み込むことでこのエラーは回避できた.

% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
unsupported machine `sh'                     ★
gdbcom:2: Error in sourced command file:
unable to create simulator instance
(sh64-elf-gdb) q
%

static SIM_RC
sim_model_init (SIM_DESC sd)
{
...
      const SIM_MACH *mach = sim_mach_lookup_bfd_name (STATE_ARCHITECTURE (sd)->printable_name);

      if (mach == NULL)
	{
	  sim_io_eprintf (sd, "unsupported machine `%s'\n",
			  STATE_ARCHITECTURE (sd)->printable_name);   ★

以下の函数が NULL を返すということだが:

const SIM_MACH *
sim_mach_lookup_bfd_name (const char *name)
{
  const SIM_MACH **machp;

  for (machp = & sim_machs[0]; *machp != NULL; ++machp)
    {
      if (strcmp (MACH_BFD_NAME (*machp), name) == 0)
	return *machp;
    }
  return NULL;
}

(gdb) p *machp
$7 = (const SIM_MACH *) 0x8774d20 <sh2_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$9 = (const SIM_MACH *) 0x8774ce0 <sh2e_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$10 = (const SIM_MACH *) 0x8774ca0 <sh2a_fpu_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$11 = (const SIM_MACH *) 0x8774c60 <sh2a_nofpu_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$12 = (const SIM_MACH *) 0x8774c20 <sh3_mach>
(gdb) n
(gdb) 

(gdb) p sim_machs
$13 = 0x8abae40 <sim_machs>
(gdb) p *machp
$14 = (const SIM_MACH *) 0x8774be0 <sh3e_mach>
(gdb) n
(gdb) 

(gdb) 
(gdb) 

(gdb) p *machp
$15 = (const SIM_MACH *) 0x8774ba0 <sh4_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$16 = (const SIM_MACH *) 0x8774ae0 <sh4a_nofpu_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$17 = (const SIM_MACH *) 0x8774b20 <sh4a_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$18 = (const SIM_MACH *) 0x8774aa0 <sh4al_mach>
(gdb) n
(gdb) 

(gdb) p *machp
$19 = (const SIM_MACH *) 0x8774a60 <sh5_mach>
(gdb) n
(gdb) 

というわけでどうやら sh5_mach が返れば良さそう. これはアセンブラを修正
するべきかも. と思ったが --isa=shmedia とすればいいらしい.


% sh64-elf-as -o test.o -g test.S --isa=shmedia  ★
% sh64-elf-ld -o test.elf test.o -T ../default.x
sh64-elf-ld: sh5 アーキテクチャ (入力ファイル`test.o') は sh 出力と互換性がありません
%

今度はリンカでひっかかっている.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.30.sh64-elf/ld
M-x gdb
gdb --annotate=3 ./ld-new
(gdb) cd ~/lang/53_GNU_tool/gcc_cross/SH64/test/test001/
(gdb) run -o test.elf test.o -T ../default.x
...
再現している. エラーしているのは以下の箇所:

      if (compatible == NULL)
	{
	  if (command_line.warn_mismatch)
	    einfo (_("%P%X: %s architecture of input file `%B'"  ★
		     " is incompatible with %s output\n"),
		   bfd_printable_name (input_bfd), input_bfd,
		   bfd_printable_name (link_info.output_bfd));
	}

--oformat elf32-sh64 や --oformat elf64-sh64 を試してみたが同じエラーになる.

(gdb) b bfd_arch_get_compatible
(gdb) run -o test.elf test.o -T ../default.x --oformat elf64-sh64
...

const bfd_arch_info_type *
bfd_default_compatible (const bfd_arch_info_type *a,
			const bfd_arch_info_type *b)
{
  if (a->arch != b->arch)
    return NULL;

  if (a->bits_per_word != b->bits_per_word)
    return NULL;     ★

NULL が返っている直接の原因は以下:

(gdb) p a->bits_per_word
$5 = 64
(gdb) p b->bits_per_word
$6 = 32
(gdb) 

面倒なので以下のように修正してみた:

const bfd_arch_info_type *
bfd_default_compatible (const bfd_arch_info_type *a,
			const bfd_arch_info_type *b)
{
+#if 0  
  if (a->arch != b->arch)
    return NULL;

  if (a->bits_per_word != b->bits_per_word)
    return NULL;

  if (a->mach > b->mach)
    return a;

  if (b->mach > a->mach)
    return b;
+#endif
  return a;
}

この修正で以下のような ELF ファイルを生成することができている.

test.elf:     ファイル形式 elf64-sh64
test.elf
アーキテクチャ: sh5, フラグ 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
開始アドレス 0x0000000000000101
...
セクション .text の逆アセンブル:

0000000000000100 <start>:
 100:	6ff0fff0 	nop	
 104:	6ff0fff0 	nop	
 108:	6ff0fff0 	nop	

000000000000010c <end>:
 10c:	6ff0fff0 	nop	
...

開始アドレスが 0x101 になっているのは気になるが nop の命令長が 4 になっている.

以下は sh-elf-xxx の同じプログラム

test.elf:     ファイル形式 elf32-sh
test.elf
アーキテクチャ: sh, フラグ 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
開始アドレス 0x00000100
...
セクション .text の逆アセンブル:

00000100 <start>:
 100:	00 09       	nop	
 102:	00 09       	nop	
 104:	00 09       	nop	

00000106 <end>:
 106:	00 09       	nop	
...

開始アドレスを 0x100 になるように修正する.


          7f45 4c46 0202 0100 0000 0000 0000 0000  .ELF............
00000010: 0002 002a 0000 0001 0000 0000 0000 0101  ...*............
00000020:

オフセット 0x14 に 0x101 がある.


  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bwrite (&x_ehdr, amt, abfd) != amt)

(gdb) p/x x_ehdr
$37 = {e_ident = {0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, e_type = {0x0, 0x2}, e_machine = {0x0, 0x2a}, 
  e_version = {0x0, 0x0, 0x0, 0x1}, e_entry = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x1, 0x1}, e_phoff = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40}, 
  e_shoff = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x18}, e_flags = {0x0, 0x0, 
    0x0, 0xa}, e_ehsize = {0x0, 0x40}, e_phentsize = {0x0, 0x38}, e_phnum = {
    0x0, 0x1}, e_shentsize = {0x0, 0x40}, e_shnum = {0x0, 0xa}, e_shstrndx = {
    0x0, 0x9}}
(gdb)

セットしているのは直前のコード:

  elf_swap_ehdr_out (abfd, i_ehdrp, &x_ehdr);  ★

そして i_ehdrp もまたその直前でセットされている:


  i_ehdrp = elf_elfheader (abfd);  ★

マクロ展開は以下:

  i_ehdrp = (((abfd) -> tdata.elf_obj_data) -> elf_header);

(gdb) p/x ((abfd) -> tdata.elf_obj_data) -> elf_header
$51 = {{e_ident = {0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 
      0x0, 0x0, 0x0, 0x0, 0x0}, e_entry = 0x101, e_phoff = 0x40, 
    e_shoff = 0x318, e_version = 0x1, e_flags = 0xa, e_type = 0x2, 
    e_machine = 0x2a, e_ehsize = 0x40, e_phentsize = 0x38, e_phnum = 0x1, 
    e_shentsize = 0x40, e_shnum = 0xa, e_shstrndx = 0x9}}
(gdb) 

確かに 0x101 になっている.

static void
sh64_elf64_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
+#if 0
  /* FIXME: Perhaps we shouldn't do this if the entry address was supplied
     numerically, but we currently lack the infrastructure to recognize
     that: The entry symbol, and info whether it is numeric or a symbol
     name is kept private in the linker.  */
  if (elf_elfheader (abfd)->e_type == ET_EXEC)
    elf_elfheader (abfd)->e_entry |= 1;    ★
+#endif    
} 

これは意図的にやっているらしい. しかし採用しないことにする. 上のようにコンパイルアウトしておく.

2022.06.08 9:19 例によって 0x100 番地に nop を数個並べたプログラムを sh64-elf-gdb で
実行できることを目指す. 現状以下のようになっている:

% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x10 lma 0x100
Start address 0x100
Transfer rate: 128 bits in <1 sec.
Breakpoint 1 at 0x100                           ★
Breakpoint 2 at 0x10c: file test.S, line 5.     ★

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00000000 in ?? ()
gdbcom:7: Error in sourced command file:
Cannot find bounds of current function
(sh64-elf-gdb) quit
%

まず start ラベルとソースファイルの対応がとれていない. そして end ラベルとソースファイル
の対応はとれているように見えるが実は間違えている. 5 行目ではなくて 7 行目が正しい.

.debug_line セクションは以下:

 The File Name Table (offset 0x1c):
  Entry	Dir	時刻	サイズ	名前
  1	0	0	0	test.S

 Line Number Statements:
  [0x00000027]  拡張命令コード 2: 設定アドレス 0x102  ★
  [0x00000032]  Special opcode 7: advance Address by 0 to 0x102 and Line by 2 to 3
  [0x00000033]  Special opcode 62: advance Address by 4 to 0x106 and Line by 1 to 4
  [0x00000034]  Special opcode 62: advance Address by 4 to 0x10a and Line by 1 to 5
  [0x00000035]  Special opcode 63: advance Address by 4 to 0x10e and Line by 2 to 7
  [0x00000036]  Advance PC by 2 to 0x110
  [0x00000038]  拡張命令コード 1: 列の終り

アドレスが間違えている. 0x102 ではなくて 0x100 が正しい.

% sh64-elf-objdump --dwarf=line test.o

test.o:     ファイル形式 elf64-sh64
...
セクション .debug_line のデバッグ内容の生ダンプ:
...
 The File Name Table (offset 0x1c):
  Entry	Dir	時刻	サイズ	名前
  1	0	0	0	test.S

 Line Number Statements:
  [0x00000027]  拡張命令コード 2: 設定アドレス 0x2  ★
  [0x00000032]  Special opcode 7: advance Address by 0 to 0x2 and Line by 2 to 3
  [0x00000033]  Special opcode 62: advance Address by 4 to 0x6 and Line by 1 to 4
  [0x00000034]  Special opcode 62: advance Address by 4 to 0xa and Line by 1 to 5
  [0x00000035]  Special opcode 63: advance Address by 4 to 0xe and Line by 2 to 7
  [0x00000036]  Advance PC by 2 to 0x10
  [0x00000038]  拡張命令コード 1: 列の終り

%

これはアセンブラが間違えている.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.30.sh64-elf/gas/
M-x gdb
gdb --annotate=3 ./as-new

(gdb) p section->name
$2 = 0x8156463 ".debug_line"
(gdb) x/59bx location
0x8202114:	0x00	0x00	0x00	0x37	0x00	0x02	0x00	0x00
0x820211c:	0x00	0x1d	0x01	0x01	0xfb	0x0e	0x0d	0x00
0x8202124:	0x01	0x01	0x01	0x01	0x00	0x00	0x00	0x01
0x820212c:	0x00	0x00	0x01	0x00	0x74	0x65	0x73	0x74
0x8202134:	0x2e	0x53	0x00	0x00	0x00	0x00	0x00	0x00
0x820213c:	0x09	0x02	0x00	0x00	0x00	0x00	0x00	0x00
0x8202144:	0x00	0x00	0x14	0x4b	0x4b	0x4c	0x02	0x02
                          ★
0x820214c:	0x00	0x01	0x01
(gdb)

実は調べてみたところ sh64-elf-objdump でアドレス 0x8202144+1 に相当するデータを 2 加算
していたためそのようになっていたことが判明した.

つまりアセンブラはできていて sh64-elf-objdump が間違えていたということ.

% sh64-elf-objdump -s test.o
...
セクション .debug_line の内容:
 0000 00000037 00020000 001d0101 fb0e0d00  ...7............
 0010 01010101 00000001 00000100 74657374  ............test
 0020 2e530000 00000000 09020000 00000000  .S..............
 0030 0000144b 4b4c0202 000101             ...KKL.....     
        ★
...
% sh64-elf-objdump -s test.elf
...
セクション .debug_line の内容:
 0000 00000037 00020000 001d0101 fb0e0d00  ...7............
 0010 01010101 00000001 00000100 74657374  ............test
 0020 2e530000 00000000 09020000 00000000  .S..............
 0030 0102144b 4b4c0202 000101             ...KKL.....     
        ★
...
%

正常に動作している aarch64-elf-objdump と動作の比較を行なってみる.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.aarch64-elf/binutils
M-x gdb
gdb --annotate=3 ./objdump
(gdb) b bfd.c:2163
(gdb) cd ~/lang/53_GNU_tool/gcc_cross/AARCH64/test/test001/
(gdb) run --dwarf=line test.o
...
bfd.c:2163 のブレークポイントにヒット
(gdb) p fn
$2 = (bfd_byte *(*)(bfd *, struct bfd_link_info *, struct bfd_link_order *, 
    bfd_byte *, bfd_boolean, 
    asymbol **)) 0x8158460 <bfd_generic_get_relocated_section_contents>  ★
(gdb) 

同じことを sh64-elf-objdump でやってみると

(gdb) p fn
$33 = (bfd_byte *(*)(bfd *, struct bfd_link_info *, struct bfd_link_order *, 
    bfd_byte *, bfd_boolean, 
    asymbol **)) 0x810af71 <sh_elf64_get_relocated_section_contents>  ★
(gdb)

であるのだが

static bfd_byte *
sh_elf64_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
{
...
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);  ★

のようにしているのでこれに関しては問題なさそう. 問題は引数にあると思われる.

% cat z
b bfd_generic_get_relocated_section_contents
command
if ((int)strcmp(link_order->u.indirect.section->name, ".debug_line"))
c
end
end
%

(gdb) so z
(gdb) run
...
bfd_generic_get_relocated_section_contents のブレークポイントにヒット
(gdb)


      cont = howto->special_function (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
      if (cont != bfd_reloc_continue)  ★
	return cont;

期待通り動作する aarch64-elf-objdump ではこの条件が成立しないのに対して
sh64-elf-objdump ではこの条件が成立している.

  => 勘違い. sh64-elf-objdump の .debug_info セクションの動作. .debug_line
     の動作では上の条件は成立していない.

binutils のバージョンの違いもあるが期待通り動作する aarch64-elf-objdump では
函数 bfd_perform_relocation のローカル変数 relocation が 0 であるが
sh64-elf-objdump では relocation = 2 になっているのが一番の違い.
relocation = 0 になれば期待した動作になる.

relocation の計算方法を確認する.

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;  ★

ここで 2 になっている. この直接の原因は以下:

      relent->addend = rela.r_addend;   ★

さらにこれの直接の原因は直前の

	elf_swap_reloca_in (abfd, native_relocs, &rela);  ★

void
elf_swap_reloca_in (bfd *abfd,
		    const bfd_byte *s,
		    Elf_Internal_Rela *dst)
{
  const Elf_External_Rela *src = (const Elf_External_Rela *) s;
  dst->r_offset = H_GET_WORD (abfd, src->r_offset);
  dst->r_info = H_GET_WORD (abfd, src->r_info);
  dst->r_addend = H_GET_SIGNED_WORD (abfd, src->r_addend);
}


(gdb) x/24bx s
0x81f5000:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x2a
0x81f5008:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0xfe
0x81f5010:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x02
                                                                         ★
(gdb)

以下は期待通り動作している aarch64-elf-objdump

(gdb) x/24bx src
0x82ded48:	0x2a	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x82ded50:	0x01	0x01	0x00	0x00	0x01	0x00	0x00	0x00
0x82ded58:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
(gdb) 

エンディアンの違い等や数字が違っている部分はあるが r_addend メンバは 0 にセットされるか
2 にセットされるかの違いがある.

test.o を emacs の hexl-mode で見たものが以下:

          6e64 0000 0000 0000 0000 0000 0000 002a  nd.............*
00000270: 0000 0001 0000 00fe 0000 0000 0000 0002  ................
00000280:                                     ★

一周回ってやはりアセンブラの出力に問題があったということ. ファイルオフセット 0x278
から 8 バイトにわたって 2 をセットしているがこの期待値は 0 ということ.


	  if (bfd_seek (abfd, i_shdrp[count]->sh_offset, SEEK_SET) != 0
	      || bfd_bwrite (i_shdrp[count]->contents, amt, abfd) != amt) ★

(gdb) x/24bx i_shdrp[count]->contents
0x8213690:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x2a
0x8213698:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0xfe
0x82136a0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x02
                                                                          ★ 
(gdb) 

上の直接の原因は以下:

      src_rela.r_addend = ptr->addend;  ★

さらに上の直接の原因は以下:

static int
shmedia_init_reloc (arelent *rel, fixS *fixP)
{
  /* Adjust parts of *relp according to *fixp, and tell that it has been
     done, so default initializations will not happen.   */
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_64:
    case BFD_RELOC_64_PCREL:
    case BFD_RELOC_SH_IMM_LOW16:
...
      rel->addend = fixP->fx_addnumber + fixP->fx_offset; ★
      
(gdb) p fixP->fx_r_type
$25 = BFD_RELOC_64
(gdb)

試しに以下のように修正してみた:

static int
shmedia_init_reloc (arelent *rel, fixS *fixP)
{
  /* Adjust parts of *relp according to *fixp, and tell that it has been
     done, so default initializations will not happen.   */
  switch (fixP->fx_r_type)
    {
+#if 0    
    case BFD_RELOC_64:
    case BFD_RELOC_64_PCREL:
+#endif    
    case BFD_RELOC_SH_IMM_LOW16:


この修正で以下のようにソースファイルとアドレスの対応がとれている:

% sh64-elf-addr2line -e test.elf -a 0x100
0x0000000000000100
/home/khasegawa/lang/53_GNU_tool/gcc_cross/SH64/test/test001/test.S:3
% sh64-elf-addr2line -e test.elf -a 0x10c
0x000000000000010c
/home/khasegawa/lang/53_GNU_tool/gcc_cross/SH64/test/test001/test.S:7
%

sh64-elf-gdb からこのプログラムを実行してみたが現状以下のようになっている:

% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x10 lma 0x100
Start address 0x100
Transfer rate: 128 bits in <1 sec.
Breakpoint 1 at 0x100   ★
Breakpoint 2 at 0x10c   ★

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00000000 in ?? ()
gdbcom:7: Error in sourced command file:
Cannot find bounds of current function
(sh64-elf-gdb) q

sh64-elf-gdb 視点ではソースファイルとアドレスの対応がとれていない.

2022.06.08 13:48 gdb をビルド中. binutils をビルドし直したためリビルドが必要に
なったらしいが詳しいことは不明. リンクし直す必要はあるのは理解できるのだがリコンパイル
が必要な理由は不明.

2022.06.08 15:04 ビルド後確認してみたところ上の症状は残ったまま. ソースファイルトアドレス
の対応がとれていない原因を調査する.

(gdb) b install_breakpoint
(gdb) run
...
install_breakpoint のブレークポイントにヒット
(gdb) p *b->location.get()
$14 = {type = EXPLICIT_LOCATION, u = {addr_string = 0x0, linespec_location = {
      match_type = symbol_name_match_type::WILD, 
      spec_string = 0x8cb0ba8 "start"}, address = 633612988758097920, 
    explicit_loc = {source_filename = 0x0, function_name = 0x8cb0ba8 "start",
                                       ★
      func_name_match_type = symbol_name_match_type::WILD, label_name = 0x0, 
      line_offset = {offset = 0, sign = LINE_OFFSET_UNKNOWN}}}, 
  as_string = 0x8cb0bb8 "start"}
(gdb)

同様のことを aarch64-elf-gdb でやってみた.

(gdb) p *b->location.get()
$2 = {type = EXPLICIT_LOCATION, u = {addr_string = 0x0, linespec_location = {
      match_type = symbol_name_match_type::WILD, 
      spec_string = 0x8d741e8 "start"}, address = 637050336984432640, 
    explicit_loc = {source_filename = 0x0, function_name = 0x8d741e8 "start", 
      func_name_match_type = symbol_name_match_type::WILD, label_name = 0x0, 
      line_offset = {offset = 0, sign = LINE_OFFSET_UNKNOWN}}}, 
  as_string = 0x8d7c280 "start"}
(gdb) 

想像していたものと違っていた. この時点では動作に違いがない.

static void
say_where (struct breakpoint *b)
{
...
      if (b->loc->symtab != NULL)  ★
	{

期待通り動作している aarch64-elf-gdb ではこの条件が成立しているが sh64-elf-gdb では
成立していない. aarch64-elf-gdb でこの値がセットされるのは以下:

static struct bp_location *
add_location_to_breakpoint (struct breakpoint *b,
			    const struct symtab_and_line *sal)
{
...
  loc->symtab = sal->symtab;  ★

上を直接計算しているのは以下:

      ops->create_sals_from_location (location, &canonical, type_wanted);

SAL は symtab and line の略らしい. 以下の部分で動作に違いが出ている.


  symtab_and_line sal = find_pc_sect_line (func_addr, section, 0);  ★

aarch64-elf-gdb の場合
(gdb) p sal
$25 = {pspace = 0x8d00c18, symtab = 0x8d4f508, symbol = 0x0, section = 0x0, 
  msymbol = 0x0, line = 3, pc = 256, end = 260, explicit_pc = false, 
  explicit_line = false, is_stmt = true, prob = 0x0, objfile = 0x0}
(gdb)

sh64-elf-gdb の場合
(gdb) p sal
$33 = {pspace = 0x8c17670, symtab = 0x0, symbol = 0x0, section = 0x0, 
  msymbol = 0x0, line = 0, pc = 256, end = 0, explicit_pc = false, 
  explicit_line = false, is_stmt = false, prob = 0x0, objfile = 0x0}
(gdb)


以下を実行して aarch64-elf-gdb では nullptr 以外が返るが sh64-elf-gdb では nullptr
が返っている.

  cust = find_pc_sect_compunit_symtab (pc, section);  ★

上の直接の原因は以下の呼び出しで result が nullptr にならないかなるかで違っている.

      result = objf->sf->qf->find_pc_sect_compunit_symtab (objf,
							   msymbol,
							   pc, section,
							   1);
							   
さらに上の直接の原因は以下の呼び出しで ps が nullptr にならないかなるかで違っている.

  struct partial_symtab *ps = find_pc_sect_psymtab (objfile, pc, section,
						    msymbol);

さらに上の直接の原因は以下の呼び出しで pst が nullptr にならないかなるかで違っている.

      struct partial_symtab *pst
	= ((struct partial_symtab *)
	   addrmap_find (objfile->partial_symtabs->psymtabs_addrmap,
			 pc - baseaddr));

以下のコード:

static void *
addrmap_fixed_find (struct addrmap *self, CORE_ADDR addr)
{
  struct addrmap_fixed *map = (struct addrmap_fixed *) self;
  struct addrmap_transition *bottom = &map->transitions[0];
  struct addrmap_transition *top = &map->transitions[map->num_transitions - 1];

  while (bottom < top)

map->num_transitions = 3 が期待値らしい. できていない sh64-elf-gdb は
map->num_transitions = 1 で続く while ループでループしないのが nullptr が返る
原因.

map->_transitions の初期値は 1 で期待通り動作する aarch64-elf-gdb ではインクリメント
されて 3 になる. そのときのスタックが以下:

(gdb) where
#0  splay_foreach_copy (n=0x8d603f4, closure=0x8d613a8) at addrmap.c:425
#1  0x0855b483 in splay_tree_foreach_helper (data=0x8d613a8, fn=0x80ac470 <splay_foreach_copy(splay_tree_node, void*)>, node=0x8d603f4) at ./splay-tree.c:244
#2  splay_tree_foreach (sp=0x8d603d0, fn=0x80ac470 <splay_foreach_copy(splay_tree_node, void*)>, data=0x8d613a8) at ./splay-tree.c:577
#3  0x080ac767 in addrmap_mutable_create_fixed (self=0x8d603c0, obstack=0x8cba3f4) at addrmap.c:455
#4  0x081ced0f in dwarf2_build_psymtabs_hard (per_objfile=0x8cba960) at /usr/local/include/c++/10.2.0/bits/shared_ptr_base.h:1324
#5  dwarf2_build_psymtabs (objfile=0x8d3b6e0) at dwarf2/read.c:6144
#6  0x082a9120 in require_partial_symbols (objfile=0x8d3b6e0, verbose=false) at psymtab.c:102
#7  0x0833fe17 in read_symbols (objfile=0x8d3b6e0, add_flags=...) at symfile.c:804
--Type <RET> for more, q to quit, c to continue without paging--
#8  0x0833f6fd in syms_from_objfile_1 (add_flags=..., addrs=0xbffff328, objfile=0x8d3b6e0) at symfile.c:978
#9  syms_from_objfile (add_flags=..., addrs=0x0, objfile=0x8d3b6e0) at symfile.c:995
#10 symbol_file_add_with_addrs (abfd=0x8d3b610, name=0xbffff84e "test.elf", add_flags=..., addrs=0x0, flags=..., parent=0x0) at symfile.c:1098
#11 0x0834095b in symbol_file_add_from_bfd (parent=0x0, flags=..., addrs=0x0, add_flags=..., name=0xbffff84e "test.elf", abfd=<optimized out>) at symfile.c:1179
#12 symbol_file_add (name=0xbffff84e "test.elf", add_flags=..., addrs=0x0, flags=...) at symfile.c:1192
#13 0x08340c88 in symbol_file_add_main_1 (reloff=0, flags=..., add_flags=..., args=0xbffff84e "test.elf") at symfile.c:1216
#14 symbol_file_add_main (args=0xbffff84e "test.elf", args@entry=<error reading variable: value has been optimized out>, add_flags=..., add_flags@entry=<error reading variable: value has been optimized out>) at symfile.c:1207
#15 0x0825e13a in catch_command_errors (command=<optimized out>, arg=<optimized out>, from_tty=<optimized out>) at main.c:457
--Type <RET> for more, q to quit, c to continue without paging--
#16 0x0826007f in captured_main_1 (context=<optimized out>) at main.c:1123
#17 0x0826021d in captured_main (data=0xbffff544) at main.c:1243
#18 gdb_main (args=0xbffff544) at main.c:1268
#19 0x0806de5c in main (argc=5, argv=0xbffff614) at gdb.c:32
(gdb)

おそらく sh64-elf-gdb では何らかの理由で splay_foreach_copy が呼び出されていない
ということ.

その呼び出しがあるのは以下:

  objfile->partial_symtabs->psymtabs_addrmap
    = addrmap_create_fixed (objfile->partial_symtabs->psymtabs_addrmap,
			    objfile->partial_symtabs->obstack ());

そして splay_tree_foreach_helper で動作に違いが出ている.

違いが出る直接の原因は以下：
int
splay_tree_foreach (splay_tree sp, splay_tree_foreach_fn fn, void *data)
{
  return splay_tree_foreach_helper (sp->root, fn, data);
}

sp->root が nullptr になっているのが sh64-elf-gdb, そうなっていないのが aarch64-elf-gdb

函数 process_psymtab_comp_unit_reader での動作に違いが出ている:


  cu_bounds_kind = dwarf2_get_pc_bounds (comp_unit_die, &best_lowpc,
					 &best_highpc, cu, pst);      ★

aarch64-elf-gdb では cu_bounds_kind = PC_BOUNDS_HIGH_LOW であるが
sh64-elf-gdb では PC_BOUNDS_INVALID になっていてこれが sp->root が nullptr になるか
ならないかの違いの原因になっている.

dwarf2_get_pc_bounds での動作の違いが最初に現われるのは以下:

	  low = attr->value_as_address ();
	  high = attr_high->value_as_address ();  ★

aarch64-elf-gdb では low = 0x100, high = 0x110 だが
sh64-elf-gdb では low = 0x100, high = 0x100 になっている.

実際は関係なかったのだが sh64-elf-gdb では以下のような結果になっていたので

(gdb) p *attr_high
$99 = {name = DW_AT_high_pc, form = DW_FORM_addr, string_is_canonical = 0, 
  u = {str = 0x100 <error: Cannot access memory at address 0x100>, 
    blk = 0x100, unsnd = 256, snd = 256, addr = 256, signature = 256}}

上の Cannot access ... はターゲットシミュレータにメモリが割り当てられていないから
出ているわけではなくて sh-elf-gdb が動いているホストの環境でメモリが割り当てられていないから
出ているメッセージ.

ここで少し脱線するがメモリの割り当てをいつものやり方, つまりプログラムのロード時に自動的に割り
当てる方式にして sim_open で固定で割り当てている部分をコンパイルアウトした.

上の結果はメモリ割り当てに先立って行なわれるので関係はないがいずれ修正するのでこの段階で
やっておいた:

gdb-10.2.sh64-elf/sim/sh64/sim-if.c:

SIM_DESC
sim_open (kind, callback, abfd, argv)
...
{
...
+#if 0  ★
  /* Allocate core managed memory if none specified by user.
     Use address 4 here in case the user wanted address 0 unmapped.  */
  if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)
    sim_do_commandf (sd, "memory region 0,0x%x", SH64_DEFAULT_MEM_SIZE);

  /* Add a small memory region way up in the address space to handle
     writes to invalidate an instruction cache line.  This is used for
     trampolines.  Since we don't simulate the cache, this memory just
     avoids bus errors.  64K ought to do. */
  sim_do_command (sd," memory region 0xf0000000,0x10000");
+#endif  ★

そして sim-load.c にメモリ割り当てのパッチを入れた:

脱線した話はここで元に戻る. sim_open の呼び出し前に dwarf2_get_pc_bounds での動作の違い
が発生する. 改めて:

.debug_info セクションの内容:
...
    <10>   DW_AT_low_pc      : 0x100
    <18>   DW_AT_high_pc     : 0x100   ★

ここが間違い.

% sh64-elf-objdump --dwarf=info test.o

test.o:     ファイル形式 elf64-sh64

.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x2a (32-bit)
   バージョン:    2
   Abbrev Offset: 0x0
   ポインタサイズ:8
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x0
    <18>   DW_AT_high_pc     : 0x0 ★

これはアセンブラが間違えている DW_AT_high_pc の期待値は 0x10.

ここで以下の修正をしたことを思い出した:

static int
shmedia_init_reloc (arelent *rel, fixS *fixP)
{
  /* Adjust parts of *relp according to *fixp, and tell that it has been
     done, so default initializations will not happen.   */
  switch (fixP->fx_r_type)
    {
+#if 0    
    case BFD_RELOC_64:
    case BFD_RELOC_64_PCREL:
+#endif    
    case BFD_RELOC_SH_IMM_LOW16:
  
試しにこの修正をキャンセルしたところ DW_AT_high_pc の値が 0x10 になった.
ということはこの修正自体が正しくなかったということ.

そもそも .debug_line の 2 ずれる現象で fx_offset メンバに 2 をセットしているのは以下:

	fixp->fx_offset += S_GET_VALUE (sym);   ★

そして上の間接的な原因は以下:

  dwarf2_emit_insn (3);  ★

これまでの経験からこれは 4 の誤りに思える. コメントにはそれっぽい理由も書かれているが
無視して 4 に修正した.

+#if 0
  for (symp = symbol_rootP; symp != NULL; symp = symp->sy_next)
    if (S_GET_OTHER (symp) & STO_SH5_ISA32)
      symp->sy_value.X_add_number++;
+#endif

さらに上も原因になって 2 ずれる現象になっていたので上のようにコンパイルアウトした.

しかし現状 0x100 番地に nop を 4 つ並べたプログラムの objdump の結果は以下のようになっている:

セクション .text の逆アセンブル:

0000000000000100 <start+0x1>:
 100:	6ff0fff0 	nop	
 104:	6ff0fff0 	nop	
 108:	          	.byte 0x6f, 0xf0, 0xff

000000000000010b <end>:
 10b:	f0          	.byte 0xf0
 10c:	6ff0fff0 	nop	

そして sh64-elf-gdb の実行結果は以下:

% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x10 lma 0x100
Start address 0x100
Transfer rate: 128 bits in <1 sec.
Breakpoint 1 at 0xff                           ★
Breakpoint 2 at 0x10b: file test.S, line 5.    ★
gdbcom:6: Error in sourced command file:
Warning:
Cannot insert breakpoint 1.
Cannot access memory at address 0xff

(sh64-elf-gdb) q
%

おそらく start ラベルが 0xff, end ラベルが 0x10b と解釈されている.

ずるいが以下のように修正した.

+#if 1
  for (symp = symbol_rootP; symp != NULL; symp = symp->sy_next)
    if (S_GET_OTHER (symp) & STO_SH5_ISA32)
      symp->sy_value.X_add_number++;
+#endif

まずは上のように修正を一旦キャンセルし, 以下のようにできていない部分を回避した.

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_64:
    case BFD_RELOC_64_PCREL:
    case BFD_RELOC_SH_IMM_LOW16:
...
+     if (fixP->fx_offset == 1) {
+	rel->addend = 0;
+	return 1;
+     }
      rel->addend = fixP->fx_addnumber + fixP->fx_offset;
      return 1;

この修正を入れることで sh64-elf-gdb の実行結果は以下のようになった:

% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x10 lma 0x100
Start address 0x100
Transfer rate: 128 bits in <1 sec.
Breakpoint 1 at 0x100: file test.S, line 3.   ★
Breakpoint 2 at 0x10c: file test.S, line 7.   ★

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00000000 in ?? ()
gdbcom:7: Error in sourced command file:
Cannot find bounds of current function
(sh64-elf-gdb) q
%

これはシミュレータのブレークポイントの扱いがおそらく間違っている.

sim_resume からシミュレーションを開始してブレークポイントで sim_engine_halt により
停止することはできている.

ここで pc の値をシミュレータに問い合わせるのに 16 番のレジスタをサイズ 4 で指定していた.
sh-tdep.c が SH64 用になっていなかったということ.

2022.06.09 9:50 現時点でブレークポイントを扱うことができている. しかし nop を実行しようと
しているが, シミュレータが実際実行している命令は

	    mov.b @$rm, $rn

らしい. この結果 0 番地から 1 バイト読み出して不正メモリアクセスが発生している.

-      UHI insn = GETIMEMUHI (current_cpu, pc);
+      UHI insn = GETIMEMUSI (current_cpu, pc);

おそらく命令フェッチのところが間違えているのではと思い上のように修正してみたがこれだけでは
正しい動作にはなっていない.

そもそも SH64 の SHmedia や SHcompact をあまり理解しないままこの作業をしていることが
問題.

2022.06.09 12:04
現状

% sh64-elf-as -o test.o -g test.S --isa=sh2
% sh64-elf-ld -o test.elf test.o -T ../default.x
% sh64-elf-objdump -x -d -g test.elf > test.objdump
% sh64-elf-gdb -q -x gdbcom test.elf

のようにして期待する動作になっているものの

% sh64-elf-as -o test.o -g test.S --isa=shmedia
% sh64-elf-ld -o test.elf test.o -T ../default.x --oformat elf64-sh64
% sh64-elf-objdump -x -d -g test.elf > test.objdump
% sh64-elf-gdb -q -x gdbcom test.elf

ではやはり nop ではなくて mov.b @r?, r? として命令を解釈しているので不正メモリアクセス
が発生している. さてこれは何が正しいのか確認する必要がある.

「SuprH 64 bit RISC Series SH-5 CPU Core, Volume 1: Architecutre」
によると SHmedia と SHcompact の 2 つの命令セットがある.

SHmedia
32 ビット

SHcompact
16 ビット

という特徴がある. 1.2.3 Mode switch では

Mode switch can be effected while executing an unconditional branch or a return
from exception. The lowest bit of the branch target denotes the target
instrunction set. If this is 0 the target is SHcompact, otherwise it is SHmedia.

という記述がある.

シミュレータで何かのタイミングでこのモードを切り変えているか確認してみる.


void
sh64_engine_run_fast (SIM_CPU *cpu)
{
  if (sh64_h_ism_get (cpu) == ISM_MEDIA)  ★

やっているっぽい.

BI
sh64_h_ism_get (SIM_CPU *current_cpu)
{
  return GET_H_ISM ();
}

int
sh64_fetch_register (SIM_CPU *cpu, int nr, unsigned char *buf, int len)
{
...
  /* Fetch PC.  */
  if (nr == SIM_SH64_PC_REGNUM && len == 8)
    {
      *((unsigned64*) buf) = H2T_8 (sh64_h_pc_get (cpu) | sh64_h_ism_get (cpu));
      return len;                                                  ★
    }

なるほどこれが開始アドレスと 1 を論理和に取っている理由. 但しプログラムカウンタは sh64-elf-gdb
の視点ではそのままアドレスとして解釈されるのでこのままでは良くない.

-     *((unsigned64*) buf) = H2T_8 (sh64_h_pc_get (cpu) | sh64_h_ism_get (cpu));
+     *((unsigned64*) buf) = H2T_8 (sh64_h_pc_get (cpu));

そして

SIM_RC
sim_create_inferior (sd, abfd, argv, envp)

で sh64_h_ism_get() が SHmedia を返すように値をセットするようにした.
そしてここで SH64 用のブレーク命令が必要であることに気付いた.

2022.06.09 14:56
現状 SHmedia のモードで 0x100 番地に nop を 4 つ配置したプログラムが動作しつつあるが,
brk 命令を実行し gdb から停止理由を問い合わされ再び実行し brk 命令を実行し, ...
と延々繰り返している. もしかすると 0x100 番地に一度セットされたブレーク命令をキャッシュして
それを保持し続けている可能性がある.

2022.06.09 17:13
0x100 番地から step 実行するときに 0x100 番地が brk 命令のまま実行しているのが上の原因.
このバグの原因が不明. 期待通り動作している ns32k-elf-gdb と動作の比較を行なってみたところ
やはり 0x100 番地から step 実行するときにセットされているブレークポイントは end ラベルの
もののみで 0x100 のブレークポイントはセットされていない状態になっている.

だから 0x100 から step 実行するときに何故 0x100 にブレークポイントがセットされているのか
確認する.

0x0000000000000101 in start () at test.S:3    ★
3		nop

これだったか. 気をつけていたつもりだが修正し切れていなかった.

  if (nr == SIM_SH64_PC_REGNUM && len == 8)
    {
-     *((unsigned64*) buf) = H2T_8 (sh64_h_pc_get (cpu) | sh64_h_ism_get (cpu));  ★
+     *((unsigned64*) buf) = H2T_8 (sh64_h_pc_get (cpu));  ★
      return len;
    }

2022.06.09 17:37 0x100 番地に nop を 4 つ配置したプログラムが SHmedia モードで正常に
動作している:

% sh64-elf-as -o test.o -g test.S --isa=shmedia
% sh64-elf-ld -o test.elf test.o -T ../default.x --oformat elf64-sh64
% sh64-elf-objdump -x -d -g test.elf > test.objdump
% sh64-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x10 lma 0x100
Start address 0x100
Transfer rate: 128 bits in <1 sec.
Breakpoint 1 at 0x100: file test.S, line 3.
Breakpoint 2 at 0x10c: file test.S, line 7.

Breakpoint 1, start () at test.S:3
3		nop
4		nop
5		nop

Breakpoint 2, end () at test.S:7
7		nop
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
%

(*4) gcc のインストール

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG
% xz -d -c ../gcc-10.2.0.tar.xz  | tar xf -
% mv gcc-10.2.0 gcc-10.2.0.sh64-lef
% cd gcc-10.2.0.sh64-elf
% sed -e 's/host_subdir = @host_subdir@/host_subdir = host-i686-pc-linux-gnu/' libgcc/Makefile.in > libgcc/Makefile.in.new
% mv libgcc/Makefile.in.new libgcc/Makefile.in
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=sh64-elf
% make all-gcc
% make all-target-libgcc
% make install-gcc
% make install-target-libgcc

