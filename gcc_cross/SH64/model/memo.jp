cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

以下開発メモ

(*1) 2022.06.11 8:59
現状

int f(double);

int main()
{
  f(1.0);
  return 0;
}

に対して以下のように生成されている.

main:
	addi	r15, -28, r15
	st.q	r15, 0, r13
	st.q	r15, 8, r14
	addi	r15, 0, r14
	st.q	r14, 16, r4
	r0 := r14 + 24           ★1
	fr0 := (const_double:DF 1.0e+0 [0x0.8p+1])
	addi	r0, 0, r4           ★
	pta	f, tr0
	blink	tr0, r13
	(mem/c:SI (mem/f/c:DI (plus:DI (reg/f:DI 14 r14)
            (const_int 16 [0x10])) [1 .result_ptr+0 S8 A8]) [2 <retval>+0 S4 A8]) := 0           ★
	ld.q	r14, 16, r0
	addi	r14, 0, r15
	ld.q	r15, 0, r13
	ld.q	r15, 8, r14
	addi	r15, -28, r15
	ptabs	r13, tr0
	blink	tr0, r13

上の ★ は期待したコードではないが何故これが生成されてしまうのか確認する.


★1 の rtx_insn が生成されたときのスタックは以下:

(gdb) where
#0  rtx_init (rt=0xb785e3a8, code=INSN) at ../.././gcc/rtl.h:2968
#1  0x089d5ee8 in rtx_alloc_stat_v (code=INSN, extra=0) at ../.././gcc/rtl.c:222
#2  0x089d5f03 in rtx_alloc (code=INSN) at ../.././gcc/rtl.c:239
#3  0x0863cb31 in make_insn_raw (pattern=0xb78e4da0) at ../.././gcc/emit-rtl.c:4009
#4  0x0863e70d in emit_insn (x=0xb78e4da0) at ../.././gcc/emit-rtl.c:5092
#5  0x089065de in expand_binop_directly (icode=CODE_FOR_adddi3, mode=E_DImode, binoptab=add_optab, op0=0xb78550b4, op1=0xb78574b0, target=0xb78e28c0, unsignedp=1, methods=OPTAB_LIB_WIDEN, last=0xb78e6ae0) at ../.././gcc/optabs.c:1138
#6  0x089068d9 in expand_binop (mode=E_DImode, binoptab=add_optab, op0=0xb78550b4, op1=0xb78574b0, target=0xb78e28c0, unsignedp=1, methods=OPTAB_LIB_WIDEN) at ../.././gcc/optabs.c:1209
#7  0x08905e6d in expand_simple_binop (mode=E_DImode, code=PLUS, op0=0xb78550b4, op1=0xb78574b0, target=0xb78e28c0, unsignedp=1, methods=OPTAB_LIB_WIDEN) at ../.././gcc/optabs.c:941
--Type <RET> for more, q to quit, c to continue without paging--
#8  0x0868781f in force_operand (value=0xb78e4d50, target=0xb78e28c0) at ../.././gcc/expr.c:7597
#9  0x08655483 in copy_to_mode_reg (mode=E_DImode, x=0xb78e4d50) at ../.././gcc/explow.c:630
#10 0x08655440 in copy_addr_to_reg (x=0xb78e4d50) at ../.././gcc/explow.c:616
#11 0x08534605 in expand_call (exp=0xb78e6b00, target=0x0, ignore=1) at ../.././gcc/calls.c:3890
#12 0x086924c1 in expand_expr_real_1 (exp=0xb78e6b00, target=0x0, tmode=E_VOIDmode, modifier=EXPAND_NORMAL, alt_rtl=0x0, inner_reference_p=false) at ../.././gcc/expr.c:11140
#13 0x08688f22 in expand_expr_real (exp=0xb78e6b00, target=0xb7857430, tmode=E_VOIDmode, modifier=EXPAND_NORMAL, alt_rtl=0x0, inner_reference_p=false) at ../.././gcc/expr.c:8363
#14 0x085496f8 in expand_expr (exp=0xb78e6b00, target=0xb7857430, mode=E_VOIDmode, modifier=EXPAND_NORMAL) at ../.././gcc/expr.h:282
#15 0x0854f85a in expand_call_stmt (stmt=0xb78ee130) at ../.././gcc/cfgexpand.c:2703  ★
...
(gdb) 

#15 から分かるように f(1.0) に対して生成されている. よく分からないが

-int f(double);
+void f(double);

のように変更したところ ★1 の rtx_insn が生成されなくなった. 不明だがこうしておく.

  => 実は (*2) で本当の理由が判明する.

(*2) 2022.06.11 9:18
現状

void f(double);

int main()
{
  f(1.0);
  return 0;
}

に対して以下のようなコードが生成されている:

main:
	addi	r15, -24, r15
	st.q	r15, 0, r13
	st.q	r15, 8, r14
	addi	r15, 0, r14
	st.q	r14, 16, r4
	fr0 := (const_double:DF 1.0e+0 [0x0.8p+1])
	pta	f, tr0
	blink	tr0, r13
	(mem/c:SI (mem/f/c:DI (plus:DI (reg/f:DI 14 r14)
            (const_int 16 [0x10])) [1 .result_ptr+0 S8 A8]) [2 <retval>+0 S4 A8]) := 0  ★
	ld.q	r14, 16, r0
	addi	r14, 0, r15
	ld.q	r15, 0, r13
	ld.q	r15, 8, r14
	addi	r15, -24, r15
	ptabs	r13, tr0
	blink	tr0, r13

★ は期待しないコード. これが生成される理由を調べてみる. ★は [r14+16] := 0 といったところ.
以下生成されたときのスタック:

(gdb) where
#0  rtx_init (rt=0xb785e3f0, code=INSN) at ../.././gcc/rtl.h:2968
#1  0x089d5ee8 in rtx_alloc_stat_v (code=INSN, extra=0) at ../.././gcc/rtl.c:222
#2  0x089d5f03 in rtx_alloc (code=INSN) at ../.././gcc/rtl.c:239
#3  0x0863cb31 in make_insn_raw (pattern=0xb78e4df0) at ../.././gcc/emit-rtl.c:4009
#4  0x0863e70d in emit_insn (x=0xb78e4df0) at ../.././gcc/emit-rtl.c:5092
#5  0x0867c6e4 in emit_move_insn_1 (x=0xb78e4dd0, y=0xb7857430) at ../.././gcc/expr.c:3759
#6  0x0867cb70 in emit_move_insn (x=0xb78e4dd0, y=0xb7857430) at ../.././gcc/expr.c:3855
#7  0x08682861 in store_expr (exp=0xb7855fdc, target=0xb78e4dd0, call_param_p=0, nontemporal=false, reverse=false) at ../.././gcc/expr.c:5929
--Type <RET> for more, q to quit, c to continue without paging--c
#8  0x08681251 in expand_assignment (to=0xb78ee04c, from=0xb7855fdc, nontemporal=false) at ../.././gcc/expr.c:5514
#9  0x08552505 in expand_gimple_stmt_1 (stmt=0xb78e72a0) at ../.././gcc/cfgexpand.c:3749
#10 0x085527fd in expand_gimple_stmt (stmt=0xb78e72a0) at ../.././gcc/cfgexpand.c:3847
...
(gdb)

  result = store_expr (from, to_rtx, 0, nontemporal, false); (*)

(gdb) p debug_tree(from)
 <integer_cst 0xb7855fdc type <integer_type 0xb7a503c0 int> constant 0>
$37 = void
(gdb) p debug_rtx(to_rtx)
(mem/c:SI (mem/f/c:DI (reg/f:DI 142 virtual-stack-vars) [1 .result_ptr+0 S8 A8]) [2 <retval>+0 S4 A8])
$39 = void
(gdb)

main から 0 を返すのに to_rtx が何故そうなるのか理由がサッパり分からない.

expand_assignment が呼び出された段階で

(gdb) p debug_tree(to)
 <result_decl 0xb78ee04c D.1418
    type <integer_type 0xb7a503c0 int public SI
        size <integer_cst 0xb7855c94 constant 32>
        unit-size <integer_cst 0xb7855ca8 constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set 2 canonical-type 0xb7a503c0 precision:32 min <integer_cst 0xb7855e74 -2147483648> max <integer_cst 0xb7855e88 2147483647>
        pointer_to_this <pointer_type 0xb7a50e40>>
    ignored SI a.c:3:5 size <integer_cst 0xb7855c94 32> unit-size <integer_cst 0xb7855ca8 4>
    align:8 warn_if_not_align:0 context <function_decl 0xb78e1400 main>
    (mem/c:SI (mem/f/c:DI (reg/f:DI 142 virtual-stack-vars) [1 .result_ptr+0 S8 A8]) [2 <retval>+0 S4 A8])>  ★
$43 = void
(gdb)

なので既にこの段階でメモリにセットされることが決まっている.
以下に気付いた:

#define CALL_USED_REGISTERS  { \
      0,     1,     1,     1,     1,     1,     1,     1,    \
      ★
      
fr0, ..., fr63 を追加したところでバグを埋め込んでいた. 実は (*1) の問題も
これが原因だとすれば納得がいく.

(*3)
2022.06.11 17:28

現状以下に対して

void f(int a, int b, int c, int d, int e, int x);


int main()
{
  f(1, 2, 3, 4, 5, 6);
  return 0;
}

以下のようなコードが生成されている.

main:
	addi	r15, -16, r15
	st.q	r15, 0, r13
	st.q	r15, 8, r14
	addi	r15, 0, r14
	addi	r15, -8, r15
	addi	r15, 0, tr1                       ★
	(mem:SI (plus:DI (reg:DI 69 tr1 [149])    ★
        (const_int 4 [0x4])) [0  S4 A32]) := 6    ★
	movi	5, r8
	movi	4, r7
	movi	3, r6
	movi	2, r5
	movi	1, r4
	pta	f, tr0
	blink	tr0, r13

問題のコードは

	tr1 := sp
	[tr1] := 6

ということなのだが期待するコードは以下:

	sp := sp - 8
	r8 := 5
	r7 := 4
	r6 := 3
	r5 := 2
	r4 := 1
	call f
	sp := sp + 8


tr1 のレジスタ番号は 69 で選択されている理由は以下:

#define FIXED_REGISTERS  { \
      0,     1,     1,     1,     0,     0,     0,     0,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     0,     0,     0,    \  ★
      0,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1,     1,     1,     1,    \
      1,     1,     1,     1,     1  }

実は fr0 をレジスタアロケーションの対象にしたのだがこれは既に意味がなくなっているので
r4, r5, r6, r7, r8 も含めて 1 にすることにした.

(*4)

2022.06.13 7:43 現状 hello world 11 が sh64-elf-run で動作している. そして
sh64::expand_prologue で生成している全ての rtx_insn* insn に対して

  RTX_FRAME_RELATED_P(insn) = true;

のようにしている. -g オプション付きで hello world 11 をコンパイルしアセンブルすると
以下のようにアセンブルエラーになる:

% ./cc1 -o a.s a.c -g -quiet
% sh64-elf-as -o a.o a.s
a.s: Assembler messages:
a.s:11: Error: unknown opcode
...
% cat -n a.s
     1		.file	"a.c"
     2		.text
     3	.Ltext0:
     4		.cfi_sections	.debug_frame
     5		.global	f
     6		.type	f, @function
     7	f:
     8	.LFB0:
     9	.LM1:
    10		.cfi_startproc
    11		addi	r15, -24, r15
    12		.cfi_def_cfa_offset 24
...
%

さてこれは一体どういうことか. sh64-elf-as で何故エラーにしているのか調べてみるべき.
単純に --isa=shmedia オプションを指定するのを忘れていたことが原因だった.
改めて

% ./cc1 -o a.s a.c -g -quiet
% sh64-elf-as -o a.o a.s --isa=shmedia
% sh64-elf-objdump -x -d -g -s a.o > a.o.objdump
% sh64-elf-ld -o a.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/SH64/tool/start.o a.o -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/SH64/tool/sample.x --oformat elf64-sh64
% sh64-elf-objdump -x -d -g -s a.elf > a.objdump
% sh64-elf-gdb -q -x gdbcom a.elf
Reading symbols from a.elf...
...
Connected to the simulator.
Loading section .text, size 0x134 lma 0x100
Loading section .rodata, size 0x10 lma 0x234
Start address 0x100
Transfer rate: 2592 bits in <1 sec.
Breakpoint 1 at 0x1bd: main. (2 locations)  ★

Program received signal SIGILL, Illegal instruction.
0x00000000000001bc in main () at a.c:6
6	}
アボート
exit 1
%

main にブレークポイントをセットしているがソース行との対応がとれていない. おそらく
sh-tdep.c が未対応ということ. そこを修正する.

  => sh64-elf-gdb 視点で調べた結果そうではなくてアセンブラの修正に問題があった
     ことが判明.

2022.06.14 11:27 現状 `f' にステップインしたときプロローグを適切にスキップできていない.
原因を sh64-elf-gdb の視点で調査してみる.

2022.06.14 14:58 現状 hello world 11 が期待通り動作している. sh64-elf-as と
sh64-elf-gdb の修正で上の問題は回避した.
