(*0) レジスタ

     r0, ..., r15, pc, status

     r13 : リンクレジスタ
     r14 : フレームポインタ
     r15 : スタックポインタ

(*1) 函数呼び出し

	js	r13, func

     疑似コード

        r13 := js 命令の次の命令のアドレス
	pc := func


(*2) 函数復帰

	urs	r15

        但し r15 レジスタの指すアドレスに戻りアドレスが格納されていることを仮定している.
        もしくは戻りアドレスが r13 に格納されている場合は

	ji	r13

(*3) プロローグ

        以下は 4 バイトの領域を使用する自前のコンパイラの函数のプロローグ

	pshm	r13, r14
	sisp	r15, 4
	lr	r14, r15

	+---------------+ <- r15_{new}, r14_{new}
	|		|
	|		|
	+---------------+
	|    r14_{old}	|
	+---------------+
	|    r13_{old}	|
	+---------------+ <- r15_{old}


	ところが仕様では上は 4 ではなくて 2 が正しい. 1750A ではバイトアドレッシングがない.

	int f(int a, int b)
	{
	  return a + b;
	}

	に対してオリジナルの cc1 は以下のようなコードを生成している:

f
	sisp	r15,2     ★
	pshm	r14,r14
	lr	r14,r15
	st	r0,1,r14  ★
	st	r1,2,r14  ★
	l	r0,1,r14
	a	r0,2,r14
	lr	r15,r14
	popm	r14,r14
	aisp	r15,2
	urs	r15

	函数 f は 4 バイトのローカル領域を使用するので最初の命令は

	sisp	r15,4

	ではなくて上のようになる. 最初の引数は r14 相対 2 (バイト)に格納されるので

	st	r0,2,r14

	ではなくて上のようになる. 同様に第 2 引数は r14 相対 4(バイト) に格納されるので
	
	st	r0,4,r14

 	ではなくて上のようになる. 仕様では確かにそれが正しいのだが, 例えばアセンブラで

	li	r15, stack

	のように書いて stack が 0x1000 にアドレス解決した場合に仕様とツールの整合性を
	保つためには

	84 f0 08 00 	li	r15, 0x0800

	のようにする必要がある.
