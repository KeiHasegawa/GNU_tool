cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

以下開発メモ

(*1) 自前の cc1 の生成したプログラムをアセンブル, リンクした ELF ファイルを objdump に
     入力すると警告メッセージが生成される.

% 1750a-elf-objdump --dwarf=info --dwarf=aranges test.elf
.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:        ★
   長さ:        0x1e (32-bit)
   バージョン:    2
   省略オフセット: 0x0
   ポインタサイズ:2
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x100
    <12>   DW_AT_high_pc     : 0x10a
    <14>   DW_AT_name        : (間接文字列、オフセット: 0x0): ../default.S
    <18>   DW_AT_comp_dir    : (間接文字列、オフセット: 0x3): default.S
    <1c>   DW_AT_producer    : (間接文字列、オフセット: 0x12): /khasegawa/lang/53_GNU_tool/gcc_cross/1750A/test/test003
    <20>   DW_AT_language    : 32769	(MIPS assembler)
  コンパイル単位 @ オフセット 0x22:        ★
   長さ:        0x62 (32-bit)
...
.debug_aranges セクションの内容:

  長さ:                     16
  バージョン:               2
  .debug_info 内へのオフセット: 0
  ポインタサイズ:           2
  セグメントサイズ:         0

    アドレス   長さ
    0100 000a 
    0000 0000 
1750a-elf-objdump: 警告: .debug_aranges セクション内オフセット 0x8 の .debug_info が CU ヘッダを指していません。
  長さ:                     16
  バージョン:               2
  .debug_info 内へのオフセット: 8   ★
  ポインタサイズ:           2
  セグメントサイズ:         0

    アドレス   長さ
    010a 0034 
    0000 0000 
%

8 ではなくて 0x22 になるのが期待値. この値を生成しているのはリンカであるからまずはリンカの視点
から調査してみる.

  => 1750a-elf-ld に問題があった. 2022.06.29 8:04 に修正できている.

(*2)
現状自前の cc1 の生成したプログラムを -g オプショション付きで実行すると以下のようになる: 

% 1750a-elf-gdb -q -x gdbcom test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x3e lma 0x100
Start address 0x100
Transfer rate: 496 bits in <1 sec.
Breakpoint 1 at 0x12c: file test.c, line 8.

Breakpoint 1, main () at test.c:8
8	  return f(5, 6);
f (a=5, b=6) at test.c:3
3	  return a + b;
#0  f (a=5, b=6) at test.c:3
#1  0x00000138 in main () at test.c:8
Backtrace stopped: previous frame inner to this frame (corrupt stack?)  ★
core: 2 byte read to unmapped address 0x0 at 0x13a

Program received signal SIGSEGV, Segmentation fault.
0x0000013a in main () at test.c:9
9	}
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
%

まず where コンマンドでエラーメッセージが出ているのでそれを修正する. エラーメッセージ
を出力している箇所は以下:

	  reason = get_frame_unwind_stop_reason (trailing);
	  if (reason >= UNWIND_FIRST_ERROR)
	    printf_filtered (_("Backtrace stopped: %s\n"),  ★
			     frame_stop_reason_string (trailing));

そして間接的な原因は以下:

  if (get_frame_type (this_frame) == NORMAL_FRAME
      && this_frame->next->unwind->type == NORMAL_FRAME
      && frame_id_inner (get_frame_arch (this_frame->next),
			 get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
...
	  this_frame->stop_reason = UNWIND_INNER_ID;  ★

(gdb) p/x get_frame_id (this_frame)
$6 = {stack_addr = 0x13c, code_addr = 0x128, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x get_frame_id (this_frame->next)
$7 = {stack_addr = 0xffc, code_addr = 0x10a, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

stack_addr = 0x13c が間違い. このターゲットプログラムは

start:
	addr  : 0x100
	stack : 0x1000
	ret   : NA

f:
	addr  : 0x10a
	stack : 0x1000 (プロローグ後は 0xffc)
	ret   : 0x138

main:
	addr  : 0x128
	stack : 0x1000
	ret   : 0x108

おそらく以下が間違い:

(define_insn "pshm"
  [
   (set (mem:HI (minus:HI (reg:HI STACK_POINTER_REGNUM) (const_int 2)))
  	(reg:HI FRAME_POINTER_REGNUM))
   (set (mem:HI (minus:SI (reg:HI STACK_POINTER_REGNUM) (const_int 4)))
   	(reg:HI LINK_REGNUM))
   (set (reg:HI STACK_POINTER_REGNUM)
	(minus:HI (reg:HI STACK_POINTER_REGNUM) (const_int 4)))
  ]
  ""
  "pshm	r13, r14")

以下のように修正してリビルド:

(define_insn "pshm"
  [
   (set (mem:HI (pre_dec:HI (reg:HI STACK_POINTER_REGNUM)))
   	(reg:HI LINK_REGNUM))
   (set (mem:HI (pre_dec:HI (reg:HI STACK_POINTER_REGNUM)))
  	(reg:HI FRAME_POINTER_REGNUM))
  ]
  ""
  "pshm	r13, r14")

これで where コマンドが正しく動作している.

(*3)
現状

extern int printf(const char*, ...);

void h(long long ll)
{
  printf("%lld\n", ll);
}

に対して以下のようなコードが生成されている:

h:
	pshm	r13, r14
	sisp	r15, 10
	lr	r14, r15
	st	r0, 0, r14
	st	r1, 2, r14
	st	r2, 4, r14
	st	r3, 6, r14
	aisp	r15, -8
	lr	r0, r15
	st	r0, 8, r14
	(mem:DI (mem/c:HI (plus:HI (reg/f:HI 14 r14)
            (const_int 8 [0x8])) [2 %sfp+8 S2 A8]) [0  S8 A8]) := 0, r14
	li	r0, .LC0
	js	r13, printf
	aisp	r15, 8
	nop
	lr	r15, r14
	aisp	r15, 10
	popm	r14, r14
	urs	r15

そして現状

#define FIXED_REGISTERS     {  \
    0,   1,   1,   1,   1,   1,   1,   1, \
    1,   1,   1,   1,   1,   1,   1,   1, \
    1 }

のようにしている. 試しに

#define FIXED_REGISTERS     {  \
    0,   0,   0,   0,   1,   1,   1,   1, \
    1,   1,   1,   1,   1,   1,   1,   1, \
    1 }

としてみたところ以下のようになった.

h:
	pshm	r13, r14
	sisp	r15, 8
	lr	r14, r15
	st	r0, 0, r14
	st	r1, 2, r14
	st	r2, 4, r14
	st	r3, 6, r14
	aisp	r15, -8
	lr	r1, r15
	(mem:DI (reg:HI 1 r1 [23]) [0  S8 A8]) := 0, r14
	li	r0, .LC0
	js	r13, printf
	aisp	r15, 8
	nop
	lr	r15, r14
	aisp	r15, 8
	popm	r14, r14
	urs	r15

r1 相対に変化している. 理由は不明だが自分の期待したコードに近い.

と思ったが 1750A には pshm 命令があるからそれを使用したほうが簡単. そこで以下を追加.

#define PUSH_ROUNDING(X)	(X)

リコンパイルして期待するコードが生成できている.

(*4)
1750A のアドレッシングの問題

現状函数で 4 バイトの領域が必要な場合に以下のようにプロローグを生成している.

	pshm	r13, r14
	sisp	r15, 4
	lr	r14, r15

1750A の仕様では sisp の第 2 オペランドは 2 が正しい.

   => 実はそうでもないらしい. オリジナルの cc1 が 2 になっているのは後で sizeof(int) = 1
      にしているからと判明する.

2022.06.30 14:42 以下の修正を入れてリビルド

#if 0
#define UNITS_PER_WORD		2
#else
#define UNITS_PER_WORD		1
#define BITS_PER_WORD        16
#endif

生成コードに変化はなし. 一旦元に戻した. オリジナルの cc1 でどのようにフレームサイズを
計算しているか調べてみる.

函数のプロローグは以下の仕組みを使用してコード生成していた:

#ifdef FUNCTION_PROLOGUE
  /* First output the function prologue: code to set up the stack frame.  */
  FUNCTION_PROLOGUE (file, get_frame_size ());
#endif

...
#define FUNCTION_PROLOGUE(FILE, SIZE) {   \
  if (flag_verbose_asm)						\
...
ここで get_frame_size() は 2 を返していることを確認した.
また例の箇所

      insn = final_scan_insn (insn, file, optimize, prescan, 0);

にブレークポイントをセットして, そこで insn をダンプしてみた:

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022
(note 21 2 3 [bb 0] NOTE_INSN_BASIC_BLOCK 0)
$35 = void

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

--Type <RET> for more, q to quit, c to continue without paging--c
source /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-3.0.1.1750a-elf/gcc/final.c:2022:59056:beg:0x8167030

(insn 3 21 4 (set (mem/f:QI (plus:QI (reg/f:QI 14 14)
                (const_int 1 [0x1])) 0)
        (reg:QI 0 0)) 27 {movqi} (nil)
    (nil))
$36 = void
	st	r0,1,r14

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

(insn 4 3 5 (set (mem/f:QI (plus:QI (reg/f:QI 14 14)
                (const_int 2 [0x2])) 0)
        (reg:QI 1 1)) 27 {movqi} (nil)
    (nil))
$37 = void
	st	r1,2,r14

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

(note 5 4 25 NOTE_INSN_FUNCTION_BEG 0)
$38 = void

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

(insn 25 5 12 (set (reg:QI 0 0 [21])
        (mem/f:QI (plus:QI (reg/f:QI 14 14)
                (const_int 1 [0x1])) 0)) 27 {movqi} (nil)
    (nil))
$39 = void
	l	r0,1,r14

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

(insn 12 25 20 (set (reg:QI 0 0 [21])
        (plus:QI (reg:QI 0 0 [21])
            (mem/f:QI (plus:QI (reg/f:QI 14 14)
                    (const_int 2 [0x2])) 0))) 33 {addqi3} (nil)
    (nil))
$40 = void
	a	r0,2,r14

Breakpoint 4, final (first=0xb7c15d80, file=0xb7fcf4c0 <_IO_2_1_stdout_>, optimize=0, prescan=0) at final.c:2022

(insn 20 12 23 (use (reg/i:QI 0 0)) -1 (nil)
    (nil))
$41 = void

これは HI であるはずの int が QI として扱われているということ. これが get_frame_size が
4 ではなくて 2 を返す直接の原因.

それでは最初に第 1 引数の a をスタックに保存する 

(insn 3 21 4 (set (mem/f:QI (plus:QI (reg/f:QI 14 14)
                (const_int 1 [0x1])) 0)
        (reg:QI 0 0)) 27 {movqi} (nil)
    (nil))

がどのように生成されているのか, HI モードであるべきところでなぜ QI に変更されているのか
その仕組みを調べてみる. 以下が原因の 1 つらしい.

#define Pmode QImode

試しに自前の cc1 に以下の修正を入れてみた:

#if 0
#define UNITS_PER_WORD		2
#define Pmode HImode
#else
#define UNITS_PER_WORD		1
#define BITS_PER_WORD		16
#define Pmode QImode
#endif

また以下のように HI モードを QI に変更した.

(define_insn "pshm"
  [
   (set (mem:QI (pre_dec:HI (reg:QI STACK_POINTER_REGNUM)))
   	(reg:QI LINK_REGNUM))
   (set (mem:QI (pre_dec:QI (reg:HI STACK_POINTER_REGNUM)))
  	(reg:QI FRAME_POINTER_REGNUM))
  ]
  ""
  "pshm	r13, r14")

さらに以下も追加した:

(define_insn "addqi3"
  [(set
    (match_operand:QI 0 "nonimmediate_operand" "")
    (plus:QI
     (match_operand:QI 1 "general_operand" "")
     (match_operand:QI 2 "general_operand" "")))]
  ""
  "*
  return m1750a::qi::add(operands[0], operands[1], operands[2]);")

(define_insn "subqi3"
  [(set
    (match_operand:QI 0 "nonimmediate_operand" "")
    (minus:QI
     (match_operand:QI 1 "general_operand" "")
     (match_operand:QI 2 "general_operand" "")))]
  ""
  "*
  return m1750a::qi::sub(operands[0], operands[1], operands[2]);")

2022.07.01 7:00 ビルド開始.
この結果

int f(int a, int b)
{
  return a + b;
}

に対して生成さたコードは以下:

f:
	pshm	r13, r14
	r15 := r15 - 4
	r14 := r15
	st	r0, 0, r14
	st	r1, 2, r14
	l	r0, 0, r14
	a	r0, 2, r14
	r15 := r14
	r15 := r15 + 4
	r14 := (mem:QI (post_inc:QI (reg/f:QI 15 r15)) [0  S1 A8])
	urs	r15

やはり get_frame_size() の戻り値は 4 であって 2 ではない. ということは Pmode が QImode
に define されていることは直接の原因ではないらしい.

オリジナルの cc1 で get_frame_size() の戻り値が 2 になる原因を調査してみる.
get_frame_size() の戻り値は以下のメンバによって決まる.

#ifndef FRAME_GROWS_DOWNWARD
  function->x_frame_offset += size;
#endif

function->x_frame_offset が 0 から 1 に変更されている. size = 1 になる原因を調べてみる.

		  stack_parm
		    = assign_stack_local (GET_MODE (entry_parm),
					  GET_MODE_SIZE (GET_MODE (entry_parm)), 0);  ★

(gdb) p debug_rtx(entry_parm)
(reg:QI 0 0)
$50 = void
(gdb) up

(gdb) p debug_tree(subr)
 <function_decl 0xb7c0d4e0 f
    type <function_type 0xb7c0d478
        type <integer_type 0xb7c222d8 int QI
            size <integer_cst 0xb7c230c0 constant 16>
            unit size <integer_cst 0xb7c230e0 constant 1>
            align 16 symtab 0 alias set -1 precision 16 min <integer_cst 0xb7c23220 -32768> max <integer_cst 0xb7c23240 32767>
            pointer_to_this <pointer_type 0xb7c259c0>>
        HI
        size <integer_cst 0xb7c23780 constant 32>
        unit size <integer_cst 0xb7c237a0 constant 2>
        align 16 symtab 0 alias set -1
        arg-types <tree_list 0xb7c21ca8 value <integer_type 0xb7c222d8 int>
            chain <tree_list 0xb7c21cbc value <integer_type 0xb7c222d8 int>
                chain <tree_list 0xb7c21cd0 value <void_type 0xb7c24478 void>>>>>
    public static QI file a.c line 2
    arguments <parm_decl 0xb7c0d3a8 a type <integer_type 0xb7c222d8 int>
        used QI file a.c line 1 size <integer_cst 0xb7c230c0 16> unit size <integer_cst 0xb7c230e0 1>
        align 16 context <function_decl 0xb7c0d4e0 f> result <integer_type 0xb7c222d8 int> initial <integer_type 0xb7c222d8 int> arg-type <integer_type 0xb7c222d8 int> arg-type-as-written <integer_type 0xb7c222d8 int>
        incoming-rtl (reg:QI 0 0)
        chain <parm_decl 0xb7c0d410 b type <integer_type 0xb7c222d8 int>
            used QI file a.c line 1 size <integer_cst 0xb7c230c0 16> unit size <integer_cst 0xb7c230e0 1>
            align 16 context <function_decl 0xb7c0d4e0 f> result <integer_type 0xb7c222d8 int> initial <integer_type 0xb7c222d8 int> arg-type <integer_type 0xb7c222d8 int> arg-type-as-written <integer_type 0xb7c222d8 int>>>
    result <result_decl 0xb7c0d548 type <integer_type 0xb7c222d8 int>
        regdecl QI file a.c line 2 size <integer_cst 0xb7c230c0 16> unit size <integer_cst 0xb7c230e0 1>
        align 16 context <function_decl 0xb7c0d4e0 f>
        (reg/i:QI 0 0)> initial <block 0xb7c15d60>
    (mem:QI (symbol_ref:QI ("f")) 0) chain <var_decl 0xb7c0d340 __PRETTY_FUNCTION__>>
$52 = void
(gdb)

これは f に対する tree が作成されたときその引数が既に HI ではなくて QI になっているということ.

単純に以下をオリジナルの cc1 でコンパイルしてみた:

int f()
{
  return sizeof(int);
}

生成されたコードは以下:
f

	pshm	r14,r14
	lr	r14,r15
	lisp	r0,1           ★
	lr	r15,r14
	popm	r14,r14
	urs	r15

sizeof(int) ではなくて sizeof(long) や sizeof(long long) を試してみたところそれぞれ
2 や 4 になっている.

sizeof(int) = 1 になっているがこのカラクリは不明だがだから get_frame_size で 1 が返る
ということ.

とここまで考えたが仕様が不明なため作業はここで打ち切ることにする. またの機会はおそらくない.

#define Pmode QImode

に関する修正をキャンセルしておく.
