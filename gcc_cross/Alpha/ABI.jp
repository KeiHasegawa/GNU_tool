(*0) レジスタとその別名

     $0  : ??? (v0)
     $1  : ??? (t0)
     $2  : ??? (t1)
     $3  : ??? (t2)
     $4  : ??? (t3)
     $5  : ??? (t4)
     $6  : ??? (t5)
     $7  : ??? (t6)
     $8  : ??? (t7)
     $9  : ??? (s0)
     $10 : ??? (s1)
     $11 : ??? (s2)
     $12 : ??? (s3)
     $13 : ??? (s4)
     $14 : ??? (s5)
     $15 : フレームポインタ (fp)
     $16 : ??? (a0)
     $17 : ??? (a1)
     $18 : ??? (a2)
     $19 : ??? (a3)
     $20 : ??? (a4)
     $21 : ??? (a5)
     $22 : ??? (t8)
     $23 : ??? (t9)
     $24 : ??? (t10)
     $25 : ??? (t11)
     $26 : リターンアドレスレジスタ (ra)
     $27 : ??? (t12)
     $28 : ??? (at)
     $29 : グローバルポインタ (gp)
     $30 : スタックポインタ (sp)
     $31 : 常に 0 (zero)

(*1) スタートアップルーチン

     現状不明なことがいくつかある. alpha-elf-gcc の生成結果を参考にすると

	jsr	$26, main


     とすれば main への函数呼び出しになるのかと思ったが, objdump の結果は


 108:	20 80 7d a7 	ldq	t12,-32736(gp)
 10c:	16 40 5b 6b 	jsr	ra,(t12),168 <main>

     のようになっている.
     またスタックポインタのセットのしかたが不明である. これも alpha-elf-gcc の
     生成結果を参考にすると

	lda	$30, stack

     とすればよいのかと思ったが, objdump の結果は

 100:	28 80 dd a7 	ldq	sp,-32728(gp)
 104:	00 00 de a7 	ldq	sp,0(sp)

     のようになっている. いずれにしても gp を適切にセットしておく必要があるらしい.

     まずは jsr 命令を調べてみる.

	ldq	t12,-32736(gp)

     であるが現状 gp = 0 なので (long long)-32736 = 0xffffffffffff8020 番地に
     アクセスすることになる. また t12 は 27 番目のレジスタらしい.

     では逆算して gp に 32736 をセットしておけば 0 番地にアクセスすることになる.
     0 番地に 8 バイトメモリを割り当てておく.

     2022.05.25 6:46 現状

	jsr	ra,(t12),174 <main>


     に対して 0xcccccccccccccccc 番地にプログラムの制御が移っている. 0 番地の値が
     初期化されていないのでそうなっているが, 仮にこの値が 0x174 ならば main にジャンプ
     するように思える.

     2022.05.25 8:37 現状 main で停止して step, where, finish が期待通り動作している.
     しかし釈然としない点はいくつかある.
     まず $29(gp) の初期値だが逆算して 32736 = 0x7fe0 にセットしている. これにより
     ldq 命令でアドレス 0 にアクセスしている. そしてアドレス 0 には main の
     アドレス 0x174 をセットしている. これにより jsr 命令でプログラムの制御が
     main に移っている.

     不思議なのは main から f を呼び出せていること.
     => プログラム開始の時点で 0x450 番地に f のアドレス 0x128 が格納されていて, その
        値を jsr 命令の直前の ldq 命令で読み出している.


(alpha-elf-gdb) x/16wx 0x448
0x448:	0x00000478	0x00000000	0x00000128	0x00000000
0x458:	0x00000480	0x00000000	0x00001000	0x00000000
0x468:	0x00000174	0x00000000	0x00000300	0x00000000
0x478 <abcdefg>:	0x0000007b	0x00000000	0x00000478	0x00000000
(alpha-elf-gdb) 

--------------------------------------------------------------  .got セクション
0x448 : 0x478 つまり abcdefg のアドレス      
0x450 : 0x128 つまり f のアドレス
0x458 : 0x480 つまり ptr のアドレス
0x460 : 0x1000 つまり stack のアドレス
0x468 : 0x174 つまり main のアドレス
0x470 : 0x300 つまり .LC0 のアドレス
-------------------------------------------------------------- .sdata セクション
0x478 : 0x7b = 123 つまり abcdefg の初期値
0x480 : 0x478 つまり abcdefg のアドレスで ptr の初期値
--------------------------------------------------------------

     .got セクションがどのようにして生成されているかは不明だが, .got セクションが
     生成されるとして, その配置アドレスを知ることができれば, 現状オフセット 0x20
     に main のアドレスがセットされている.

     2022.05.25 9:48 現状 0 番地に main のアドレスをセットしているが, 0x468 を参照
     するようにしてみる.

     2022.05.25 13:20 現状 .got セクションを 0x100 に配置するようにしている. そして
     スタートアップルーチンは以下のようになっている:

	.text
start:
	lda	$29, 0x8000($31)
	lda	$29, 0x100($29)        ★
	lda	$30, stack
	jsr	$26, main
end:
	halt

     このスタートアップルーチンは .got セクションが 0x100 に配置されていることを仮定し
     ている. しかしプログラムのサイズには依存しない.
     