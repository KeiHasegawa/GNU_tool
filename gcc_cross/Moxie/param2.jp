moxie-elf-gcc の debug_info の修正

% cat a.c
int f(int a, int b)
{
  return a + b;
}
%

(gdb) run -quiet a.c -quiet -dumpbase a.c -auxbase-strip a.s -g -o a.s

再現している:

	.string	"a"
	.byte	0x1
	.byte	0x1
	.byte	0xb
	.4byte	0x58
	.uleb128 0x2
	.byte	0x91
	.sleb128 0          <- 12 の間違い
	.uleb128 0x3
	.string	"b"
	.byte	0x1
	.byte	0x1
	.byte	0x12
	.4byte	0x58
	.uleb128 0x2
	.byte	0x91
	.sleb128 4          <- 16 の間違い

単純に最初のパラメータのオフセット位置に 12 加算するのを忘れているだけ
なのだと考えた.

gcc-10.2.0.moxie-elf/gcc/config/moxie/moxie.h

#define FIRST_PARM_OFFSET(F) 12

定義はある.

まずはこれを直接生成している箇所を知りたいがどうすればよいか.
事前に final_1 で命令を生成していることは知っているので
そこで生成されているかどうかをまずは確認する. 生成されていないとすれば
その後なので.

% cat x
b final_1
command
set asm_out_file=stdout
end
b final.c:2020
%

(gdb) so x
(gdb) run
...
(gdb) disa
(gdb) fin
.LM3:
	ret
(gdb)

ということは final_1 では debug_info が生成されていない. この後で生成
されるらしい.

      dwarf2out_frame_finish ();

この行を next 実行したところで問題の箇所の前の部分が生成されていること
に気付いた.


      (*debug_hooks->finish) (main_input_filename);

そしてこの行を実行したところ問題の箇所を生成していることに気付いた.

  output_comp_unit (comp_unit_die (), have_macinfo,
		    dwarf_split_debug_info ? checksum : NULL);

さらにこの行を実行したところ問題の箇所を生成していることに気付いた.

  output_die (die);

さらにこの行を実行したところ問題の箇所を生成していることに気付いた.
そしてこの時点でようやっと write にもブレークポイントをセットすれば
よいことに気付いた. しかし write のブレークポイントがヒットしすぎてこ
れはこれで不便であることにも気付いた.


	.uleb128 0x2
	.byte	0x91
	.sleb128 0
	.uleb128 0x3

この 4 つが一緒に出ている.

	  output_loc_sequence (AT_loc (a), -1);

これを next 実行したとき

	.byte	0x91
	.sleb128 4

が出ている.

(gdb) b dwarf2out.c:10643
(gdb) run
...

3 回きているが 2 回目が a, 3 回目が b だった. 

これは 2 回目の a のもの
(gdb) p *a
$28 = {dw_attr = DW_AT_location, dw_attr_val = {val_class = dw_val_class_loc, 
    val_entry = 0x0, v = {val_addr = 0xb78f0258, val_offset = 3079602776, 
      val_loc_list = 0xb78f0258, val_view_list = 0xb78f0258, 
      val_loc = 0xb78f0258, val_int = 3079602776, val_unsigned = 3079602776, 
      val_double = {low = 3079602776, high = 0}, val_wide = 0xb78f0258, 
      val_vec = {array = 0xb78f0258, length = 0, elt_size = 0}, 
      val_die_ref = {die = 0xb78f0258, external = 0}, 
      val_fde_index = 3079602776, val_str = 0xb78f0258, 
      val_lbl_id = 0xb78f0258 "", val_flag = 88 'X', val_file = 0xb78f0258, 
      val_file_implicit = 0xb78f0258, 
      val_data8 = "X\002\217\267\000\000\000", val_decl_ref = 0xb78f0258, 
      val_vms_delta = {lbl1 = 0xb78f0258 "", lbl2 = 0x0}, val_discr_value = {
        pos = -1215364520, v = {sval = 0, uval = 0}}, 
      val_discr_list = 0xb78f0258, val_symbolic_view = 0xb78f0258 ""}}}

これは 3 回目の b のもの
(gdb)p *a
$29 = {dw_attr = DW_AT_location, dw_attr_val = {val_class = dw_val_class_loc, 
    val_entry = 0x0, v = {val_addr = 0xb78f0294, val_offset = 3079602836, 
      val_loc_list = 0xb78f0294, val_view_list = 0xb78f0294, 
      val_loc = 0xb78f0294, val_int = 3079602836, val_unsigned = 3079602836, 
      val_double = {low = 3079602836, high = 0}, val_wide = 0xb78f0294, 
      val_vec = {array = 0xb78f0294, length = 0, elt_size = 0}, 
      val_die_ref = {die = 0xb78f0294, external = 0}, 
      val_fde_index = 3079602836, val_str = 0xb78f0294, 
      val_lbl_id = 0xb78f0294 "", val_flag = 148 '\224', 
      val_file = 0xb78f0294, val_file_implicit = 0xb78f0294, 
      val_data8 = "\224\002\217\267\000\000\000", val_decl_ref = 0xb78f0294, 
      val_vms_delta = {lbl1 = 0xb78f0294 "", lbl2 = 0x0}, val_discr_value = {
        pos = -1215364460, v = {sval = 0, uval = 0}}, 
      val_discr_list = 0xb78f0294, val_symbolic_view = 0xb78f0294 ""}}}

いまひとつ 0 や 4 はどこを参照しているかこれからは分からないが

      dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);

これだった. val1->v.val_int が 0 や 4 にセットされている.


static inline dw_loc_descr_ref
new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,
	       unsigned HOST_WIDE_INT oprnd2)
{
  dw_loc_descr_ref descr = ggc_cleared_alloc<dw_loc_descr_node> ();

  descr->dw_loc_opc = op;
  descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd1.val_entry = NULL;
  descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;

4 がセットされたのはここだった. ということは oprnd1 がどのように計算さ
れたかを調べればよい.

  reg = arg_pointer_rtx;
  offset += ARG_POINTER_CFA_OFFSET (current_function_decl);

ここはそれっぽいのだが以下のようにすれば回避できている.

#define ARG_POINTER_CFA_OFFSET(X) 0

ここで起こっていたことはパラメータのオフセット自体は 12, 16, ... のように
適切(?)に計算されていたのだが上の部分により offset が 12 になり
さらにそれが計算したオフセットから引かれていたということである.

この修正をする前は

/* On most machines, the CFA coincides with the first incoming parm.  */
#ifndef ARG_POINTER_CFA_OFFSET
#define ARG_POINTER_CFA_OFFSET(FNDECL) \
  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)
#endif

これを参照していた.

本来この修正をどこに入れるべきなのかは不明だが config.h が作成される
タイミングが不明なのでとりあえず config.h にそのまま修正を残しておく.
修正の方法は正しくないが, 期待した動作にはなる. そのうちより良い方法が判明するかもしれない.
=> 入れるのならば moxie.h の中らしい.

残念ながらこの修正は正しくなかった. この修正を入れた後, 再帰呼び出しの函数で where コマンド
を実行したときパラメータの値が正しく表示できない問題が発生している.

この修正は葉の函数には正しく動作しているが, 葉でない函数には正しく動作していない.


AVR, Blackfin, MIPS, MN10300, Microblaze が引数を渡すときにスタックにオフセットを
持たせるやりかたになっている.

avr-elf-gcc は DWARF を採用していないので参考にはならなかった.

bfin-elf-gcc では葉か葉でないかに関わらず

  offset += ARG_POINTER_CFA_OFFSET (current_function_decl);

ここで offset は 0 から 0. つまり ARG_POINTER_CFA_OFFSET (current_function_decl)
は 0 を常に返しているらしい. そして以下がその定義:

#define ARG_POINTER_CFA_OFFSET(FNDECL) \
  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)

/* We define a dummy ARGP register; the parameters start at offset 0 from
   it. */
#define FIRST_PARM_OFFSET(DECL) 0

bfin.h にそれっぽいコメントがある. だからこの場合は 0 に define しているということ.
結果的に moxie-elf-gcc はできていないのだが, これが 12 だから誤りということはなさそう
ではある.

一応以下も調べた:
(gdb) p crtl->args.pretend_args_size
$7 = 0
(gdb)

mips-elf-gcc は gcc-3.4.4 からコンパイルしたもので勝手が少し違っている.
ARG_POINTER_CFA_OFFSET というマクロは dwarf2out.c の中には出現しない.

しかし mips.h の中には以下の宣言がある.

/* The argument pointer always points to the first argument.  */
#define FIRST_PARM_OFFSET(FNDECL) 0

やはり特殊な DWARF 用のレジスタが用意されているようだ.

mn10300-elf-gcc で試してみたところ bfin-elf-gcc と同じ動作であった.
そして以下の定義:

mn10300.h

#define FIRST_PARM_OFFSET(FNDECL) 4

/* But the CFA is at the arg pointer directly, not at the first argument.  */
#define ARG_POINTER_CFA_OFFSET(FNDECL) 0

これからすると arg pointer もしくは argument pointer なるものを moxie でも導入した
くなる気はする. というよりもうすでにあるのだろうが, それが機能していないのだろう.
少し横道にそれるかもしれないが MN10300 の ABI からすると 4 ではなくて
8 になりそうな気がするがあくまでも根拠のない推測である. 実際 mn10300-elf-gcc に問題は
見つかっていない.

microblaze-elf-gcc の場合も bfin-elf-gcc, mn10300-elf-gcc と同じ動作.
そして

microblaze.h

#define UNITS_PER_WORD          4
...
#define FIRST_PARM_OFFSET(FNDECL)		(UNITS_PER_WORD)

#define ARG_POINTER_CFA_OFFSET(FNDECL)		0

これも Microblaze の ABI からすると 4 ではなくて 24 になりそうだが, やはり
microblaze-elf-gcc に問題はないからこれはこれで正しいのだろう.

さてこんなところだが, 共通しているのは offset の値はいずれも 0 から 0 で
ARG_POINER_CFA_OFFSET(x) は 0 に結果的になる.

ところで AVR, Blackfin, MIPS, MN10300, Microblaze を参考にしようとしたが
これらのプロセッサはレジスタで渡しされない引数をスタックに置くときオフセットを
開けて置くタイプのものであったが結局これが影響しているかどうかは不明である.

crtl->args.pretend_args_size

という名前からそのように判断したのだが, そもそもこれは 0 だから関係ない.

さて修正方針だが

(1) ARG_POINTER_CFA_OFFSET(FNDECL) を 0 に define するのならば葉でない函数の
    オフセットを修正する必要がある.

(2) ARG_POINTER_CFA_OFFSET(FNDECL) の定義はこれまで通りにするのならば葉の函数
    のオフセットを修正する必要がある.

ということでこれだと手間が変わらないことになる. いずれにしても函数が葉か葉でないかは
判断することが要求されている.

int
leaf_function_p (void)
{

このような函数がある. これは勿論だが函数の中を処理しているときに rtx_insn の列を
順番に見ていくということをしているものである.

crtl->is_leaf

にこの値をセットしているようだからこれを参照することにすればよい.

結局 config.h の修正は取り消して moxie.h に以下を入れることにした.

#define FIRST_PARM_OFFSET(F) 12

+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+ (crtl->is_leaf ? 0 : FIRST_PARM_OFFSET(FNDECL))

しかしこれもまだできていない. 勘違いしていたのは葉の函数ができていないのではなくて
葉でない函数もできていなかったということ.
「パラメータの表示(gdb からの見えているもの)」を参照.


