*** gdb-10.2.org/gdb/moxie-tdep.c	2021-04-25 13:06:26.000000000 +0900
--- gdb-10.2.moxie-elf/gdb/moxie-tdep.c	2022-01-02 10:42:09.000000000 +0900
***************
*** 480,487 ****
  		   struct type *valtype, struct regcache *regcache,
  		   gdb_byte *readbuf, const gdb_byte *writebuf)
  {
!   if (TYPE_LENGTH (valtype) > 8)
!     return RETURN_VALUE_STRUCT_CONVENTION;
    else
      {
        if (readbuf != NULL)
--- 480,493 ----
  		   struct type *valtype, struct regcache *regcache,
  		   gdb_byte *readbuf, const gdb_byte *writebuf)
  {
!   if (TYPE_LENGTH (valtype) > 8) {
!     if (readbuf) {
!       ULONGEST addr;
!       regcache_raw_read_unsigned(regcache, RET1_REGNUM, &addr);
!       read_memory(addr, readbuf, TYPE_LENGTH(valtype));
!     }
!     return RETURN_VALUE_ABI_RETURNS_ADDRESS;
!   }
    else
      {
        if (readbuf != NULL)
***************
*** 562,568 ****
--- 568,578 ----
    if (cache->base == 0)
      return;
  
+ #if 0
    *this_id = frame_id_build (cache->saved_sp, cache->pc);
+ #else
+   *this_id = frame_id_build (cache->base, cache->pc);
+ #endif
  }
  
  /* Get the value of register regnum in the previous stack frame.  */
***************
*** 1045,1050 ****
--- 1055,1234 ----
    return 0;
  }
  
+ #include <cassert>
+ #include <numeric>
+ #include <map>
+ 
+ static bool is_aggregate(type_code code)
+ {
+   switch (code) {
+   case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
+     return true;
+   default:
+     return false;
+   }
+ }
+ 
+ static int aggregate_space(int s, value* arg)
+ {
+   auto arg_type = check_typedef(value_type(arg));
+   auto code = arg_type->code();
+   if (!is_aggregate(code))
+     return s;
+   int len = TYPE_LENGTH(arg_type);
+   return s + len;
+ }
+ 
+ static void calc_sp(int* nth, value* arg, CORE_ADDR* sp, CORE_ADDR* asp,
+ 		    std::map<int, CORE_ADDR>& tbl)
+ {
+   auto arg_type = check_typedef(value_type(arg));
+   auto code = arg_type->code();
+   int len = TYPE_LENGTH(arg_type);
+   if (is_aggregate(code)) {
+     *asp -= len;
+     tbl[*nth] = *asp;
+     *sp -= 4;
+     ++*nth;
+     return;
+   }
+ 
+   if (len <= 4) {
+     *sp -= 4;
+     ++*nth;
+     return;
+   }
+ 
+   assert(len == 8);
+   if (*nth + 1 < 6) {
+     *sp -= 8;
+     *nth += 2;
+     return;
+   }
+ 
+   *sp -= 8;
+   *nth += 2;
+ }
+ 
+ static void set_arg(int* nth, value* arg, regcache* rc, CORE_ADDR sp,
+ 		    const std::map<int, CORE_ADDR>& tbl)
+ {
+   using namespace std;
+   
+   auto arg_type = check_typedef(value_type(arg));
+   auto code = arg_type->code();
+   auto val = value_contents(arg);
+   int len = TYPE_LENGTH(arg_type);
+   
+   if (is_aggregate(code)) {
+     auto p = tbl.find(*nth);
+     assert(p != end(tbl));
+     auto cp_addr = p->second;
+     write_memory(cp_addr, val, len);
+     if (*nth < 6) {
+       regcache_cooked_write_unsigned(rc, R0_REGNUM+*nth, cp_addr);
+       ++*nth;
+       return;
+     }
+     CORE_ADDR addr = sp + 8 + 4 + 4 * (*nth);
+     union {
+       uint32_t i;
+       gdb_byte c[4];
+     } u = { (uint32_t)cp_addr };
+     int x = 1;
+     if (*(char*)&x) {
+       // gdb runs at a little endian processor
+       swap(u.c[0], u.c[3]);
+       swap(u.c[1], u.c[2]);
+     }
+     write_memory(addr, &u.c[0], 4);
+     ++*nth;
+     return;
+   }
+ 
+   if (len <= 4) {
+     if (*nth < 6) {
+       auto regval = extract_unsigned_integer(val, 4, BFD_ENDIAN_BIG);
+       regcache_cooked_write_unsigned(rc, R0_REGNUM+*nth, regval);
+       ++*nth;
+       return;
+     }
+     CORE_ADDR addr = sp + 8 + 4 + 4 * (*nth);
+     write_memory(addr, val, 4);
+     ++*nth;
+     return;
+   }
+ 
+   assert(len == 8);
+   if (*nth + 1 < 6) {
+     auto regval = extract_unsigned_integer(val, 8, BFD_ENDIAN_BIG);
+     uint32_t hi = regval >> 32;
+     regcache_cooked_write_unsigned(rc, R0_REGNUM+*nth+0, hi);
+     uint32_t lo = regval;
+     regcache_cooked_write_unsigned(rc, R0_REGNUM+*nth+1, lo);
+     *nth += 2;
+     return;
+   }
+ 
+   if (*nth == 5) {
+     auto regval = extract_unsigned_integer(val, 8, BFD_ENDIAN_BIG);
+     uint32_t hi = regval >> 32;
+     regcache_cooked_write_unsigned(rc, R0_REGNUM+*nth+0, hi);
+     CORE_ADDR addr = sp + 8 + 4 + 4 * (*nth);
+     write_memory(addr+4, val+4, 4);
+     *nth += 2;
+     return;
+   }
+ 
+   CORE_ADDR addr = sp + 8 + 4 + 4 * (*nth);
+   write_memory(addr, val, 8);
+   *nth += 2;
+ }
+ 
+ static CORE_ADDR
+ moxie_push_dummy_call(gdbarch* arch, value* func, regcache* rc,
+ 		      CORE_ADDR bp_addr, int nargs, value** argv, CORE_ADDR sp,
+ 		      function_call_return_method rm,
+ 		      CORE_ADDR struct_addr)
+ {
+   using namespace std;
+   sp &= 0xfffffffc;
+   CORE_ADDR asp = sp;
+   sp -= accumulate(&argv[0], &argv[nargs], 0, aggregate_space);
+   map<int, CORE_ADDR> tbl;
+   int nth = 0;
+   for (int i = 0 ; i != nargs ; ++i)
+     calc_sp(&nth, argv[i], &sp, &asp, tbl);
+   sp -= 8;
+   union {
+     uint32_t i;
+     gdb_byte c[4];
+   } u = { (uint32_t)bp_addr };
+   int x = 1;
+   if (*(char*)&x) {
+     // gdb runs at a little endian processor
+     swap(u.c[0], u.c[3]);
+     swap(u.c[1], u.c[2]);
+   }
+   write_memory(sp, &u.c[0], 4);
+   sp -= 4;
+   regcache_cooked_write_unsigned(rc, MOXIE_SP_REGNUM, sp);
+   ULONGEST fp;
+   regcache_cooked_read_unsigned(rc, MOXIE_FP_REGNUM, &fp);
+   u.i = fp;
+   if (*(char*)&x) {
+     // gdb runs at a little endian processor
+     swap(u.c[0], u.c[3]);
+     swap(u.c[1], u.c[2]);
+   }
+   write_memory(sp, &u.c[0], 4);
+   regcache_cooked_write_unsigned(rc, MOXIE_FP_REGNUM, sp);
+   nth = 0;
+   for (int i = 0 ; i != nargs ; ++i)
+     set_arg(&nth, argv[i], rc, sp, tbl);
+   return sp;
+ }
+ 
  /* Allocate and initialize the moxie gdbarch object.  */
  
  static struct gdbarch *
***************
*** 1098,1103 ****
--- 1282,1289 ----
    /* Support reverse debugging.  */
    set_gdbarch_process_record (gdbarch, moxie_process_record);
  
+   set_gdbarch_push_dummy_call(gdbarch, moxie_push_dummy_call);
+   
    return gdbarch;
  }
  
