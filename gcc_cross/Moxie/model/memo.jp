cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

(*) 備考
ビルドの手順で AARCH64 では以下のようにパッチを適用する必要があったが

% patch -p1 < ../gcc-10.2.0.aarch64-elf.mine.diff

Moxie ではたまたま差分がなかったため, この手順は必要なし.

開発記録.

Moxie のスタックフレームは Blackfin のスタックフレームに似ているのでそのときの
解析結果を参考にした.

(1) マクロ TARGET_LRA_P の宣言の追加.
(2) マクロ TARGET_LEGITIMATE_ADDRESS_P の定義となる函数の修正
(3) マクロ ARG_POINTER_REGNUM と ELIMINABLE_REGS の宣言の修正
    函数 INITIAL_ELIMINATION_OFFSET の修正
(4) マクロ REG_PARM_STACK_SPACE の宣言の追加
(5) 函数 FIRST_PARM_OFFSET では 0 を返す
(6) マクロ OUTGOING_REG_PARM_STACK_SPACE の宣言の追加.
          ACCUMULATE_OUTGOING_ARGS
(7) マクロ FRAME_GROWS_DOWNWARD を 1 に define する.
(8) プロローグでフレームサイズの他に函数呼び出しの引数の分を加算して
    スタックポインタをずらす.
(9) FRAME_POINTER_CFA_OFFSET の宣言を追加    

上の項目 (1) から (8) を修正して hello world 11 が動作するようになっている.
Moxie では (9) が必要になった.

現状 -g オプション付きでコンパイルしたものを moxie-elf-gdb で動作させると
f にステップインしてプロローグを適切にスキップできているが, 引数の a と b
を正しく表示できていない.

.debug_info は

<2><c9>: 省略番号: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><d6>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 4 	(DW_OP_fbreg: 4)

のようになっている. a は fp	相対 12, b は fp 相対 16 なのでこの部分が正しくない.

オリジナルの cc1 で生成した .debug_info を確認してみた:

 <2><c9>: 省略番号: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 c 	(DW_OP_fbreg: 12)
 <2><d6>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 10 	(DW_OP_fbreg: 16)

できている.

自前の cc1 の生成した a.s を以下のように修正してみた

	.section	.debug_info,"",@progbits
...
	.string	"a"
	.byte	0x1
	.byte	0x3
	.byte	0xb
	.4byte	0x5d
	.uleb128 0x2
	.byte	0x91
	.sleb128 12	# 0 を 12 に
	.uleb128 0x6
	.string	"b"
	.byte	0x1
	.byte	0x3
	.byte	0x12
	.4byte	0x5d
	.uleb128 0x2
	.byte	0x91
	.sleb128 16	# 4 を 16 に

この部分を生成しているところを調べてみた.

          compile_file ();

この函数から戻ってくるところで .debug_info が出されているらしい.

(gdb) b compile_file
(gdb) run


      (*debug_hooks->finish) (main_input_filename);  この部分だった.


さらに調べると

  output_comp_unit (comp_unit_die (), have_macinfo,
		    dwarf_split_debug_info ? checksum : NULL);  この部分


さらに調べると

  output_die (die);  この部分
  
さらに調べると

	  output_loc_sequence (AT_loc (a), -1);  この部分
	  break;

さらに調べると

    case DW_OP_fbreg:
      dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);  ここ
      break;

lval1->v.val_int

が 0 や 4 になっているのでこれを 12 や 16 にする.

	  offset += frame_pointer_fb_offset;
	  HOST_WIDE_INT const_offset;
	  if (offset.is_constant (&const_offset))
	    return new_loc_descr (DW_OP_fbreg, const_offset, 0);

0 や 4 は上の条件が成立してセットされていた.

frame_pointer_fb_offset が -12 になっていて結果的に offset から 12 が引かれてい
るのが期待しない動作.

static void
compute_frame_pointer_to_fb_displacement (poly_int64 offset)
{
...
  frame_pointer_fb_offset = -offset;

ここでセットしている.
オリジナルの cc1 はどういうやり方でオフセット 12 や 16 を計算しているか調べてみる.

compute_frame_pointer_to_fb_displacement

が呼び出された時点では引数 offset=0 であることを確認した. これは自前の cc1 と同じ.

  elim = strip_offset_and_add (elim, &offset);

この行を実行したときに自前の cc1 は offset=12 だがオリジナルの cc1 は 0 で
0 になるのが期待値.

自前の cc1
(gdb) p debug_rtx(elim)
(plus:SI (reg/f:SI 0 $fp)
    (const_int 12 [0xc]))
$66 = void
(gdb) 


オリジナルの cc1
(gdb) p debug_rtx(elim)
(reg/f:SI 0 $fp)
$6 = void
(gdb)

オリジナルでも自前でも ira_use_lra_p = false であることを確認した.

eliminate_regs (reg, VOIDmode, NULL_RTX))

の戻り値が異なるということ.

      if (regno < FIRST_PSEUDO_REGISTER)
	{
	  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];
	       ep++)
	    if (ep->from_rtx == x && ep->can_eliminate)
ここ	      return plus_constant (Pmode, ep->to_rtx, ep->previous_offset);

	}

オリジナルの cc1 も自前の cc1 も ep->to_rtx = frame_pointer_rtx であるが,
オリジナルの cc1 は ep->previous_offset = 0 で自前の cc1 は 12
になっている.

この間に

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)
{

や

int
moxie_initial_elimination_offset (int from, int to)
{

は呼び出されていなかったがもしかすると事前に計算されていた可能性もある.

オリジナルの cc1
#define ELIMINABLE_REGS							\
{{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },			\
 { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}			

自前の cc1
#define ELIMINABLE_REGS				\
{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},	\
 { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},	\
 { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}

ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM

に対しては自前の cc1 では意図して 12 を計算している.
オリジナルの cc1 では

#define STACK_POINTER_REGNUM MOXIE_SP     // 1
#define FRAME_POINTER_REGNUM MOXIE_QFP    // 16
#define HARD_FRAME_POINTER_REGNUM MOXIE_FP  // 0
#define ARG_POINTER_REGNUM MOXIE_QAP       // 17

のように HARD_FRAME_POINTER_REGNUM と FRAME_POINTER_REGNUM MOXIE
とを分けている.

この部分を真似てみることにしてみた:

#define REGISTER_NAMES {		\
  "$fp",  "$sp",  "$r0",  "$r1",	\
  "$r2",  "$r3",  "$r4",  "$r5",	\
  "$r6",  "$r7",  "$r8",  "$r9",	\
  "$r10", "$r11", "$r12", "$r13",	\
  "?fp",  "?ap" }
   ここ     ここ
#define FIXED_REGISTERS {		\
    1,      1,      0,      0,		\
    0,      0,      0,      0,		\
    1,      1,      1,      1,		\
    1,      1,      1,      1,		\
    1,      1 }
   ここ     ここ
#define CALL_USED_REGISTERS {		\
    1,      1,      1,      1,		\
    1,      1,      1,      1,		\
    1,      1,      1,      1,		\
    1,      1,      1,      1,		\
    1,      1 }
   ここ     ここ

#define       HARD_FRAME_POINTER_REGNUM    0        ここ
constexpr int STACK_POINTER_REGNUM       = 1;
constexpr int R0_REGNUM                  = 2;
#define       FRAME_POINTER_REGNUM         16       ここ
#define       ARG_POINTER_REGNUM           17       ここ
constexpr int FIRST_PSEUDO_REGISTER      = 18;      ここ

#define REG_CLASS_CONTENTS \
/* NO_REGS */		{{ 0x00000000 }, \
/* SPECIAL_REGS */	 { 0x00030003 }, \        ここ
/* GENERAL_REGS */	 { 0x0000fffc }, \
/* ALL_REGS */           { 0x0003ffff }}          ここ


#define ELIMINABLE_REGS							\
{{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },			\
 { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}	これ		

reg_class REGNO_REG_CLASS(int regno)
{
  switch (regno) {
  case STACK_POINTER_REGNUM:
  case FRAME_POINTER_REGNUM:
  case ARG_POINTER_REGNUM:
  case HARD_FRAME_POINTER_REGNUM:          ここ
    return SPECIAL_REGS;
  default:
    return GENERAL_REGS;
  }
}

とここまで修正して気付いたが

オリジナル
#define REG_PARM_STACK_SPACE(FNDECL) (6 * UNITS_PER_WORD)
#define FIRST_PARM_OFFSET(F) 12

自前
#define REG_PARM_STACK_SPACE(FNDECL)		8
int FIRST_PARM_OFFSET(tree func)
{
  (void)func;
  return 0;
}

REG_PARM_STACK_SPACE は 24 が正しい.
なので上の修正は全部一旦キャンセルしてこれだけを修正して確認する. 2022.02.10 7:30

8:30 に確認したがやはり修正されていない.

現在似たようなスタックフレームになっている mn10300 も並行して開発しているのでそちら
の結果も見てからにする.

mn10300 も似たような症状になっている. 以下 .debug_info の抜粋:

 <2><c9>: 省略番号: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><d6>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 4 	(DW_OP_fbreg: 4)

やはりフレームポインタ相対 0, 4 になっている. 8, 12 になっているのが正しい.

そして Blackfin のコンパイラの生成結果を確認したところ, .debug_info は
フレームポインタ相対 0, 4 になっていた. しかしそれでも gdb で a や b は
正しく(?) 表示されていた. おそらくデバッガが頑張っていたということなのかも.

いずれにしても Blackfin を真似ても .debug_info は期待した通りにはならないということ.

そこで HARD_FRAME_POINTER_REGNUM と FRAME_POINTER_REGNUM とを異なる値に
定義する修正を入れてみる.

=> やってみたが, .debug_info は変わらず以下

 <2><a3>: 省略番号: 6 (DW_TAG_formal_parameter)
    <a4>   DW_AT_name        : a
    <a6>   DW_AT_decl_file   : 1
    <a7>   DW_AT_decl_line   : 3
    <a8>   DW_AT_decl_column : 11
    <a9>   DW_AT_type        : <0x5d>
    <ad>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><b0>: 省略番号: 6 (DW_TAG_formal_parameter)
    <b1>   DW_AT_name        : b
    <b3>   DW_AT_decl_file   : 1
    <b4>   DW_AT_decl_line   : 3
    <b5>   DW_AT_decl_column : 18
    <b6>   DW_AT_type        : <0x5d>
    <ba>   DW_AT_location    : 2 byte block: 91 4 	(DW_OP_fbreg: 4)

また f が以下のようになった:

f:
	sto.l	0($fp), $r0
	sto.l	4($fp), $r1
	ldo.l	$r0, 0($fp)
	ldo.l	$r6, 4($fp)
	add	$r0, $r6
	ret

これはできていない.

一旦入れた修正を元に戻す. そしてついでに以下を入れてみた.

#define ARG_POINTER_CFA_OFFSET(FNDECL) 0

しかし .debug_info は相変わらず.
現状

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)
{
  offset = 0;
  if (from == ARG_POINTER_REGNUM)
    offset = 12;  この 12 が

f:
	sto.l	12($fp), $r0     引数の最初の保存先を決めている.
	sto.l	16($fp), $r1


static void
compute_frame_pointer_to_fb_displacement (poly_int64 offset)
{
...
#ifdef FRAME_POINTER_CFA_OFFSET
  reg = frame_pointer_rtx;
  offset += FRAME_POINTER_CFA_OFFSET (current_function_decl);
#else
  reg = arg_pointer_rtx;
  offset += ARG_POINTER_CFA_OFFSET (current_function_decl);
#endif

FRAME_POINTER_CFA_OFFSET で調整すれば良さそう.

#define FRAME_POINTER_CFA_OFFSET(FDECL) 0

できている.
