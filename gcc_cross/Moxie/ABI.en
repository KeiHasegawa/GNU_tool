Moxie ABI

(*1) Function call
(*2) Return from function
(*3) Prologue
(*4) Epilogue
(*5) Normal argument and return value
(*6) `long long' argument and return value
(*7) Floating point number argument and return value
(*8) Structure argument and return value


(*1) Function call

	jsra	func

	Pseudo code

	sp -= 8
	memory[sp] = (`jsra' instruction next address)
	sp -= 4
	memory[sp] = fp
	fp = sp
	pc = func

(*2) Return from function

	ret

	Pseudo code

	fp = memory[fp]
	fp += 4
	pc = memory[fp]
	fp += 8
	sp = fp


(*3) Prologue

	dec	$sp, 128

	Above is prologue for function which uses 128 bytes local area.
	`jsra' instruction saves `fp' and return address, so just decrement
	sp.

	+----------------------+ <- sp_{new}
	|                      |	
	|                      |
	|      local area      |
	|                      |
	|                      |
	+----------------------+ +128 <- sp_{old}, fp
	|          fp          |
	+----------------------+ +132
	|    return address    |
	+----------------------+ +136
	|                      |
	+----------------------+ +140


(*4) Epilogue

	ret

	Above is epilogue and it doesn't depend on its the mount of local area.
	`fp' and `sp' are restored and return to callee.

(*5) Normal argument and return value

	1st : r0
	...
	6th : r5
	7th : use stack with offset 24

	For example,

	int f(int a0, int a1, int a2, int a3, int a4, int a5,
	      int a6, int a7, int a8);

        f(10, 11, 12, 13, 14, 15, 16, 17, 18);

	At the start address of `f', registers and stack layout become
	like below:

	r0 = 10, ..., r5 = 15

	+----------------------+ <- sp, fp
	|          fp          |
	+----------------------+ +4
	|    return address    |
	+----------------------+ +8
	|                      |
	+----------------------+ +12
	|         ****         |
	+----------------------+ +16
	|         ****         |
	+----------------------+ +20
	|         ****         |
	+----------------------+ +24
	|         ****         |
	+----------------------+ +28
	|         ****         |
	+----------------------+ +32
	|         ****         |
	+----------------------+ +36
	|          16          |
	+----------------------+ +40
	|          17          |
	+----------------------+ +44
	|          18          |
	+----------------------+ +48

	Function return value is set to `r0'.

(*6) `long long' argument and return value

	sizeof(long long) = 8

	For `long long' type argument, 2 registers are used.
	For `long long' return value, `r0' and `r1' are used.

	For example,

	long long f(int a0, long long a1, long long a2, long long a3);

	f(10, 11LL, 12LL, 0x123456789abcdef0LL);

	At the start address of `f', registers and stack layout become
	like below:

	r0 = 10, r1 = 0, r2 = 11, r3 = 0, r4 = 12, r5 = 0x12345678

	+----------------------+ <- sp, fp
	|          fp          |
	+----------------------+ +4
	|    return address    |
	+----------------------+ +8
	|                      |
	+----------------------+ +12
	|         ****         |
	+----------------------+ +16
	|         ****         |
	+----------------------+ +20
	|         ****         |
	+----------------------+ +24
	|         ****         |
	+----------------------+ +28
	|         ****         |
	+----------------------+ +32
	|         ****         |
	+----------------------+ +36
	|      0x9abcdef0      |
	+----------------------+ +40

(*7) Floating point number argument and return value

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

        Moxie doesn't have FPU so software calculates floating point
	number operation.
	For `float', same with (*5). For `double', `long double' same
	with (*6).

(*8) Structure argument and return value

	When calling function which takes structure type argument,
	make copy and pass its address.
	When calliing function which returns structure type, the address
	of the return vallue is set to `r0'.
