Moxie の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

調査していて気付いたが, アセンブラのプログラムでのステップ実行がおかしい.
1 命令実行するべきところで 3 命令実行していたりする.


(*1) 函数呼び出し

	jsra	func

	疑似コード

	sp -= 8
	memory[sp] = (jsra 命令の次のアドレス)
	sp -= 4
	memory[sp] = fp
	fp = sp
	pc = func

(*2) 函数復帰

	ret

	疑似コード

	fp = memory[fp]
	fp += 4
	pc = memory[fp]
	fp += 8
	sp = fp


(*3) プロローグ

	dec	$sp, 128

	上は 128 バイトのローカルエリアを使用する函数のプロローグである. jsra 命令で
	sp と戻りアドレスが保存されているので単に sp をずらすだけになっている.

	+----------------------+ <- sp_{new}
	|                      |	
	|                      |
	|      local area      |
	|                      |
	|                      |
	+----------------------+ +128 <- sp_{old}, fp
	|          fp          |
	+----------------------+ +132
	|    return address    |
	+----------------------+ +136
	|                      |
	+----------------------+ +140


(*4) エピローグ

	ret

	上は使用するローカルエリアのバイト数に依存しない函数のエピローグである.
	fp, sp が復元され呼び出し元に復帰する.

(*5) 通常の函数の引数と戻り値

	第 1 引数 : r0
	...
	第 6 引数 : r5
	第 7 引数以降 : スタックを 24 バイト開けて使用する

	int f(int a0, int a1, int a2, int a3, int a4, int a5,
	      int a6, int a7, int a8);

        f(10, 11, 12, 13, 14, 15, 16, 17, 18);

	に対して f の先頭アドレスでは

	r0 = 10, ..., r5 = 15
	

	+----------------------+ <- sp, fp
	|        fp_{old}      |
	+----------------------+ +4
	|    return address    |
	+----------------------+ +8
	|                      |
	+----------------------+ +12
	|         ****         |
	+----------------------+ +16
	|         ****         |
	+----------------------+ +20
	|         ****         |
	+----------------------+ +24
	|         ****         |
	+----------------------+ +28
	|         ****         |
	+----------------------+ +32
	|         ****         |
	+----------------------+ +36
	|          16          |
	+----------------------+ +40
	|          17          |
	+----------------------+ +44
	|          18          |
	+----------------------+ +48

	のようになっている.
	i 番目の引数をスタックに保存するとき fp 相対 12 + 4 *i の位置に保存する.
	
	函数の戻り値は r0 にセットされる.

(*6) long long を引数にとる函数, 返す函数

	sizeof(long long) = 8

	long long の引数に対してレジスタが 2 つ使用される.
	long long の戻り値は r0 と r1 にセットされる.

	long long f(int a0, long long a1, long long a2, long long a3);

	f(10, 11LL, 12LL, 0x123456789abcdef0LL);

	に対して f の先頭アドレスでは

	r0 = 10, r1 = 0, r2 = 11, r3 = 0, r4 = 12, r5 = 0x12345678

	+----------------------+ <- sp, fp
	|          fp          |
	+----------------------+ +4
	|    return address    |
	+----------------------+ +8
	|                      |
	+----------------------+ +12
	|         ****         |
	+----------------------+ +16
	|         ****         |
	+----------------------+ +20
	|         ****         |
	+----------------------+ +24
	|         ****         |
	+----------------------+ +28
	|         ****         |
	+----------------------+ +32
	|         ****         |
	+----------------------+ +36
	|      0x9abcdef0      |
	+----------------------+ +40

	のようになっている.
	
(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

        Moxie には FPU がないのでソフトウェアで浮動少数点数演算を行なう.
	float に対しては (*5) の規則が, double, long double に対しては (*6) の
	規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すとき, コピーが作成されそのアドレスが引数として渡さ
	れる.
	構造体を返す函数を呼び出すとき, 戻り値を格納するアドレスを r0 にセットする.
