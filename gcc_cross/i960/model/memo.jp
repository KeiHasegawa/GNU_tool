以下開発メモ

(*1)
現状

hello world 11

を実行すると

_main:
	mov	6, g1
	mov	5, g0
	callx	_f
	mov	g0, g1
	ldconst	.LC0, g0
	callx	_printf
	mov	0, g0
	ret

_main の ret 命令を実行すると

	mov	0, g0

に戻っている. おそらくだが, これはシミュレータのバグっぽい(実は違っていた).
しかし

	ret

を実行する寸前で

(i960-elf-gdb) p/x $r2
$2 = 0x194
(i960-elf-gdb)


00000170 <_main>:
 170:	06 1e 88 5c 	mov	6,g1
 174:	05 1e 80 5c 	mov	5,g0
 178:	00 30 00 86 	callx	154 <_f>
 17c:	54 01 00 00 
 180:	10 16 88 5c 	mov	g0,g1
 184:	00 30 80 8c 	lda	19c <_main+0x2c>,g0
 188:	9c 01 00 00 
 18c:	00 30 00 86 	callx	148 <_printf>
 190:	48 01 00 00 
 194:	00 1e 80 5c 	mov	0,g0
 198:	00 00 00 0a 	ret

なのでこの ret 命令が問題なのではなくて r2 レジスタの値が間違えている.
と思ったがそうでもないらしい.

戻りアドレスは r0 相対 8 にあるアドレスなので

(i960-elf-gdb) x/5w $r0
0x1b000:	0x00000000	0x0001b000	0x00000140	0x00000000
0x1b010:	0x00000000
(i960-elf-gdb)

0x140 に戻るのが正しい.

 138:	00 30 00 86 	callx	170 <_main>
 13c:	70 01 00 00 
 140:	f0 ee db ba 	.word	0xbadbeef0

なのでやはりこれはシミュレータに問題がありそう(実は違った).

0x198 番地の ret 命令のシミュレーションで 0x140 にプログラムの制御が移るのが期待する
動作. 現状では 0x194 にプログラムの制御が移っている.

調べてみると g15(fp) 相対 8 にアクセスして確かに 0x194 がそこにある.
どこかでここを壊している可能性がある.
以下の呼び出しの結果が r2 レジスタにセットされ,

(gdb) p/x sim_core_read_unaligned_4 (0x817e3d8, 0x194, 0, 0x1b008)

この結果プログラムの制御がそこに移る.
そこで気付いたのはアドレス 0x16c の ret 命令で

(gdb) p/x sim_core_read_unaligned_4 (0x817e3d8, 0x194, 0, 0x1b008)
$15 = 0x180
(gdb) 

すでにこの時点で 0x180 に書き換えられている. 期待値は 0x140.

_main のブレークポイントにヒットしたとき.

(i960-elf-gdb) x/3wx 0x1b000
0x1b000:	0x00000000	0x0001b000	0x00000140
(i960-elf-gdb)

問題の ret 命令を実行する寸前では

(i960-elf-gdb) x/3wx 0x1b000
0x1b000:	0x0001b000	0x0001b040	0x00000194
(i960-elf-gdb)

のようになっている. どこかでこの領域を壊している. ウォッチポイントをセットしてみたところ

_f:
	addo	8, sp, sp

i960-elf-gdb は addo 命令でこの領域を壊しているとしている. さてこれは一体?

シミュレータ目線で調べてみた. 0x154 番地の addo 命令のシミュレーションの時点では

(gdb) p/x pc
$16 = 0x154
(gdb) p/x sim_core_read_unaligned_4 (0x817e3d8, 0x194, 0, 0x1b008)
$17 = 0x180
(gdb) 

既に 0x180 に書き換えられている. ということは callx 命令に問題があるということか.

改めて callx 命令の仕様をシミュレータの動作からだが理解してみると g15(fp) 相対 [0, 64)
に r0, ..., r15 を書き込んでいる.

葉の函数ではこの領域は使用されないが, 葉以外の函数だとこの領域は書き潰されてしまう.
単純にフレームのサイズを 64 足しておけば良さそう. と思ったがフレームザイズのみ
広げても現状プロローグで sp をずらしているだけだから意味がない.

fp をプロローグで更新する必要がある.

プロローグを修正して正常動作を確認した.

オリジナルの cc1 で生成したコードで実行するとやはりこの部分ができていないためプログラム
が終了しない.

(*2)
2022.03.25 11:00

#undef PREFERRED_DEBUGGING_TYPE
#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG

を追加してビルド開始.
