test3.S をアセンブルした結果を objdump すると期待した結果にならない件の調査.

(gdb) run -o test3.o test3.S

% i960-elf-objdump -g test3.o > test3.o.objdump
...
int f (int a /* 0x40 */, int b /* 0x44 */)
{ /* 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 2 addr 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 3 addr 0xc */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 4 addr 0x18 */
} /* 0x20 */
int main ()
{ /* 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x20 */
} /* 0x24 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x28 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x3c */

再現している.

test3.S は d30v-elf-gcc の生成したアセンブラを参考にして作成した:

~/lang/53_GNU_tool/gcc_cross/D30V/test/test003/

d30v-elf-as のアセンブル結果を objdumjp した結果は

int f (int a /* 0x0 */, int b /* 0x4 */)
{ /* 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 2 addr 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 3 addr 0x18 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 4 addr 0x28 */
} /* 0x40 */
int main ()
{ /* 0x40 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 7 addr 0x40 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 7 addr 0x58 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 8 addr 0x60 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.c line 9 addr 0x70 */
} /* 0x80 */

ということは i960-elf-as の場合 main のアドレス(オフセット)が 0x0 ではなくて 0x20 になって
いればできていそうに思える. ここが修正されれば main の最後のアドレス(オフセット)が 0x44 に
なり, その結果, 現状は 8 行目, 9 行目が main の外に飛び出しているものも中に入りそうに思える.

ということで main のアドレス(オフセット)が 0x0 になる原因を調査する.

これは i960-elf-objdump 視点で調べてみる.

M-x gdb
gdb --annotate ./objdump.j
(gdb) run -g test3.o
...
再現している.
(gdb) b fprintf
(gdb) run
...
数回 continue を繰り返して

static boolean
pr_start_block (p, addr)
     PTR p;
     bfd_vma addr;
{

から main の 0x0 が印字されていることを確認した.

おそらく -g 自体の出力はプロセッサが違っても正しくできると想像し d30v-elf-gcc の生成した
test.o に対して同じことをやってみた.

(gdb) delete
(gdb) run -g test.o
...

想像した通りになっている.

(gdb) b pr_start_block
(gdb) run
...
pr_start_block のブレークポイントにヒット. これで

int f (int a /* 0x0 */, int b /* 0x4 */)
{ /* 0x0 */

を印字.

(gdb) c
...
pr_start_block のブレークポイントにヒット. これで

int main ()
{ /* 0x40 */

を印字.

ここは想定した通り. main に対して pr_start_block が呼び出されたとき引数の addr = 0x40
がどのように計算されているか調べてみる.

f の最後

} /* 0x40 */

の値をそのまま main のオフセットとして使用しているのが期待される動作. ここをつきとめる.

(gdb) b fprintf
(gdb) run
...
数回 continue して以下の函数だと判明:

static boolean
pr_end_block (p, addr)
     PTR p;
     bfd_vma addr;
{

(gdb) p/x addr
$7 = 0x40
(gdb) up

ここからきていた:

  if (block->locals != NULL || block->parent == NULL)
    {
      if (! (*fns->end_block) (fhandle, block->end))
	return false;
    }

(gdb) p/x block->end
$8 = 0x40
(gdb) p block
$9 = (struct debug_block *) 0x80dcc88
(gdb)

だとすれば main 函数を表現している debug_block は f を表現している debug_block とは
違うだろうから, 単純に

(f を表現している debug_block).end = (main 函数を表現している debug_block).start

になっていれば期待した動作になっている. 以下は main の 0x40 を表示したときの状態:

(gdb) p block
$11 = (struct debug_block *) 0x80dd128
(gdb) p/x block->start
$13 = 0x40
(gdb)

これが期待する動作. この 0x40 をセットする瞬間を捕える. 以下だった:

debug_record_function (handle=0x80dc098, name=0x80dd8d0 "main", return_type=0x80dc950, global=true, addr=64) at debug.c:808
...
  b->start = addr;

できていない i960-elf-as の生成した test3.o の場合おそらく addr = 0x0 で呼び出されている
ということのはず.

(gdb) delete
(gdb) b debug_record_function
(gdb) run -g test3.o
...
Breakpoint 5, debug_record_function (handle=0x80dc0a8, name=0x80dcb80 "f", return_type=0x80dc880, global=true, addr=0) at debug.c:783
(gdb) c
Continuing.

Breakpoint 5, debug_record_function (handle=0x80dc0a8, name=0x80dd710 "main", return_type=0x80dc880, global=true, addr=0) at debug.c:783
(gdb)

そうなっていたことを上で確認した. 一方できている d30v-elf-as の生成した test.o ならば

(gdb) run -g test.o
...
Breakpoint 5, debug_record_function (handle=0x80dc098, name=0x80dcc68 "f", return_type=0x80dc950, global=true, addr=0) at debug.c:783
(gdb) c
Continuing.

Breakpoint 5, debug_record_function (handle=0x80dc098, name=0x80dd8d0 "main", return_type=0x80dc950, global=true, addr=64) at debug.c:783
(gdb)

のように main は addr = 64 = 0x40 で呼び出されている.

binutils-2.10.1.i960-elf/binutils/rddbg.c

	      type = bfd_get_8 (abfd, stab + 4);
	      if (type == 36)
		asm("int3");
	      other = bfd_get_8 (abfd, stab + 5);
	      desc = bfd_get_16 (abfd, stab + 6);
	      value = bfd_get_32 (abfd, stab + 8);  value を計算している.

ここに当りをつけた.

(gdb) run
...

0    f の先頭
64   f の最後
64   main の先頭
64   main の最後

~/lang/53_GNU_tool/gcc_cross/D30V/test/test003/test.s
...
	.stabs	"f:F(0,1)",36,0,2,f
...
	.stabs	"",36,0,0,.Lscope0-f
...
	.stabs	"main:F(0,1)",36,0,7,main
...
	.stabs	"",36,0,0,.Lscope1-main

一方できていない i960-elf-as がアセンブルしたものは

~/lang/53_GNU_tool/gcc_cross/i960/test/test002/test3.S
...
	.stabs	"f:F1",36,0,2,_f
...
	.stabs	"",36,0,0,Lscope0-_f
...
	.stabs	"main:F1",36,0,7,_main
...
	.stabs	"",36,0,0,Lscope1-_main

のようにしている. そのように手作業で作成した. できているように思える.

(gdb) run -g test3.o

0x0    f の先頭
0x20   f の最後
0x0    main の先頭
0x24   main の最後

のようになっている. そこで 3 番目を 0x20 4 番目を 0x44 に変更してみた:
...
int f (int a /* 0x40 */, int b /* 0x44 */)
{ /* 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 2 addr 0x0 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 3 addr 0xc */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 4 addr 0x18 */
} /* 0x20 */
int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */
} /* 0x64 */
[Inferior 1 (process 7216) exited normally]
(gdb)

デバッガで変数を変更してできている. ということは

test4.S
...
	.stabs	"main:F1",36,0,7,32
...
	.stabs	"",36,0,0,68

即値を指定してアセンブルしたものを objdump にしてみたところ

int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */
} /* 0x64 */

できている. test4.o は以下のように

00000200: 1800 0000 0000 0000 2400 0000 2000 0000  ........$... ...
00000210: 7203 0000 2400 0700 2000 0000 0000 0000  r...$... .......
00000220: 4400 0700 2000 0000 0000 0000 4400 0800  D... .......D...

オフセット 0x20c に 0x20
オフセット 0x22c に 0x44
がある. test3.o と比較してみたが単純ではなかった. いずれにせよ

 	.stabs	"main:F1",36,0,7,_main

 	.stabs	"",36,0,0,Lscope1-_main

ができていない. もしかすると上だけができていないのかもしれない.
アセンブラそのものをデバッグしてみた

M-x gdb
gdb --annotate=3 ./as-new.j

binutils-2.10.1.i960-elf/gas/read.c:

		      (*pop->poc_handler) (pop->poc_val);

この呼び出しが以下の呼び出しになっている:

/* Regular stab directive. */

void
s_stab (what)
     int what;
{
  s_stab_generic (what, STAB_SECTION_NAME, STAB_STRING_SECTION_NAME);
}

ここは構文解析をしているだけらしい.

static void 
s_stab_generic (what, stab_secname, stabstr_secname)
     int what;
     char *stab_secname;
     char *stabstr_secname;
{
...
  type = longint;
  if (type == 36)
    asm("int3");

ここにきている.

      p = frag_more (8);
      md_number_to_chars (p, (valueT) stroff, 4);
      md_number_to_chars (p + 4, (valueT) type, 1);
      md_number_to_chars (p + 5, (valueT) other, 1);
      md_number_to_chars (p + 6, (valueT) desc, 2);

(gdb) x/8bx p
0x81075bc:	0x09	0x00	0x00	0x00	0x24	0x00	0x02	0x00
(gdb)

ここに値をセットしている. 上は以下を処理したときの結果.

	.stabs	"_f:F1",36,0,2,_f

objdump 視点の調査で分かった「ブロック」の開始と終了をどこかで生成していると想像できる.
それをどこで生成しているのか調べてみる.

とここで

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.10.1.i960-elf/gas/as-new.j: bfd assertion fail elf.c:3394
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.10.1.i960-elf/gas/as-new.j: bfd assertion fail elf.c:3396
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.10.1.i960-elf/gas/as-new.j: bfd assertion fail elf.c:3394
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.10.1.i960-elf/gas/as-new.j: bfd assertion fail elf.c:3396

のようにエラーしていることに気付く.

#if 0	
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, true);
#else
	struct stat buf;
	int n = stat(abfd->filename, &buf);
	BFD_ASSERT(n == 0);
	int size = buf.st_size;
	if (shdrp->sh_addralign > 1) {
	  int tmp = BFD_ALIGN (off, shdrp->sh_addralign);
	  if (tmp <= size)
	    off = _bfd_elf_assign_file_position_for_section (shdrp, off, true);
	  else {
	    BFD_ASSERT(!shdrp->sh_size);          ここだった
	    BFD_ASSERT(!shdrp->bfd_section);
	    BFD_ASSERT(!shdrp->contents);
	    off = _bfd_elf_assign_file_position_for_section (shdrp, off, false);
	  }
	}
#endif	

一旦この修正をキャンセルしておく.

(gdb) b bfd_set_section_contents
(gdb) run -o test3.o test3.S
...
.stab セクションに対して bfd_set_section_contents が呼び出されたことを確認

(gdb) x/444bx &f->fr_literal[0]
0x81075b0:	0x01	0x00	0x00	0x00	0x00	0x00	0x24	0x00
0x81075b8:	0x7a	0x03	0x00	0x00	0x09	0x00	0x00	0x00
0x81075c0:	0x64	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075c8:	0x47	0x00	0x00	0x00	0x64	0x00	0x00	0x00
0x81075d0:	0x00	0x00	0x00	0x00	0x4e	0x00	0x00	0x00
0x81075d8:	0x3c	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075e0:	0x5d	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x81075e8:	0x00	0x00	0x00	0x00	0x7f	0x00	0x00	0x00
0x81075f0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075f8:	0x95	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x8107600:	0x00	0x00	0x00	0x00	0xbc	0x00	0x00	0x00
0x8107608:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107610:	0xec	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x8107618:	0x00	0x00	0x00	0x00	0x21	0x01	0x00	0x00
0x8107620:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107628:	0x6a	0x01	0x00	0x00	0x80	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8107630:	0x00	0x00	0x00	0x00	0xb3	0x01	0x00	0x00
0x8107638:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107640:	0xd6	0x01	0x00	0x00	0x80	0x00	0x00	0x00
0x8107648:	0x00	0x00	0x00	0x00	0xfd	0x01	0x00	0x00
0x8107650:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107658:	0x1f	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107660:	0x00	0x00	0x00	0x00	0x40	0x02	0x00	0x00
0x8107668:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107670:	0x52	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107678:	0x00	0x00	0x00	0x00	0x65	0x02	0x00	0x00
0x8107680:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107688:	0x7e	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107690:	0x00	0x00	0x00	0x00	0xab	0x02	0x00	0x00
0x8107698:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076a0:	0xc5	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x81076a8:	0x00	0x00	0x00	0x00	0xe1	0x02	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x81076b0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076b8:	0x02	0x03	0x00	0x00	0x80	0x00	0x00	0x00
0x81076c0:	0x00	0x00	0x00	0x00	0x0e	0x03	0x00	0x00
0x81076c8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076d0:	0x50	0x03	0x00	0x00	0x80	0x00	0x00	0x00
0x81076d8:	0x00	0x00	0x00	0x00	0x63	0x03	0x00	0x00
0x81076e0:	0x24	0x00	0x02	0x00	0x00	0x00	0x00	0x00
0x81076e8:	0x68	0x03	0x00	0x00	0xa0	0x00	0x01	0x00
0x81076f0:	0x40	0x00	0x00	0x00	0x6d	0x03	0x00	0x00
0x81076f8:	0xa0	0x00	0x01	0x00	0x44	0x00	0x00	0x00
0x8107700:	0x00	0x00	0x00	0x00	0x44	0x00	0x02	0x00
0x8107708:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107710:	0x44	0x00	0x03	0x00	0x0c	0x00	0x00	0x00
0x8107718:	0x00	0x00	0x00	0x00	0x44	0x00	0x04	0x00
0x8107720:	0x18	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107728:	0x24	0x00	0x00	0x00	0x20	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8107730:	0x72	0x03	0x00	0x00	0x24	0x00	0x07	0x00
0x8107738:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107740:	0x44	0x00	0x07	0x00	0x20	0x00	0x00	0x00
0x8107748:	0x00	0x00	0x00	0x00	0x44	0x00	0x08	0x00
0x8107750:	0x28	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107758:	0x44	0x00	0x09	0x00	0x3c	0x00	0x00	0x00
0x8107760:	0x00	0x00	0x00	0x00	0x24	0x00	0x00	0x00
0x8107768:	0x24	0x00	0x00	0x00
(gdb) 


(gdb) p/x *(char*)0x8107734
$8 = 0x24
(gdb)

これを変更している瞬間を捕える.

      p = frag_more (8);
      md_number_to_chars (p, (valueT) stroff, 4);
      md_number_to_chars (p + 4, (valueT) type, 1);   ここだった.
      md_number_to_chars (p + 5, (valueT) other, 1);
      md_number_to_chars (p + 6, (valueT) desc, 2);

      .stabs	"main:F1",36,0,7,_main

これの _main をどのように処理しているかだが, まずはできている d30v-elf-as で調べてみたい.
上と同様のことを d30v-elf-as でやってみた:

(gdb) x/468bx &f->fr_literal[0]
0x81760b8:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0x26
0x81760c0:	0x00	0x00	0x04	0x3a	0x00	0x00	0x00	0x08
0x81760c8:	0x64	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81760d0:	0x00	0x00	0x00	0x46	0x64	0x00	0x00	0x00
0x81760d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x4d
0x81760e0:	0x3c	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81760e8:	0x00	0x00	0x00	0x5c	0x80	0x00	0x00	0x00
0x81760f0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x86
0x81760f8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176100:	0x00	0x00	0x00	0xa0	0x80	0x00	0x00	0x00
0x8176108:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0xcf
0x8176110:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176118:	0x00	0x00	0x01	0x07	0x80	0x00	0x00	0x00
0x8176120:	0x00	0x00	0x00	0x00	0x00	0x00	0x01	0x44
0x8176128:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176130:	0x00	0x00	0x01	0x95	0x80	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8176138:	0x00	0x00	0x00	0x00	0x00	0x00	0x01	0xe6
0x8176140:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176148:	0x00	0x00	0x02	0x11	0x80	0x00	0x00	0x00
0x8176150:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0x40
0x8176158:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176160:	0x00	0x00	0x02	0x6a	0x80	0x00	0x00	0x00
0x8176168:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0x93
0x8176170:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176178:	0x00	0x00	0x02	0xad	0x80	0x00	0x00	0x00
0x8176180:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0xc8
0x8176188:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176190:	0x00	0x00	0x02	0xe8	0x80	0x00	0x00	0x00
0x8176198:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x21
0x81761a0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761a8:	0x00	0x00	0x03	0x3f	0x80	0x00	0x00	0x00
0x81761b0:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x5f
--Type <RET> for more, q to quit, c to continue without paging--
0x81761b8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761c0:	0x00	0x00	0x03	0x84	0x80	0x00	0x00	0x00
0x81761c8:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x98
0x81761d0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761d8:	0x00	0x00	0x03	0xfc	0x80	0x00	0x00	0x00
0x81761e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x04	0x13
0x81761e8:	0x24	0x00	0x00	0x02	0x00	0x00	0x00	0x00
0x81761f0:	0x00	0x00	0x04	0x1c	0xa0	0x00	0x00	0x01
0x81761f8:	0x00	0x00	0x00	0x00	0x00	0x00	0x04	0x25
0x8176200:	0xa0	0x00	0x00	0x01	0x00	0x00	0x00	0x04
0x8176208:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x02
0x8176210:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176218:	0x44	0x00	0x00	0x03	0x00	0x00	0x00	0x18
0x8176220:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x04
0x8176228:	0x00	0x00	0x00	0x28	0x00	0x00	0x00	0x00
0x8176230:	0x24	0x00	0x00	0x00	0x00	0x00	0x00	0x40
--Type <RET> for more, q to quit, c to continue without paging--
0x8176238:	0x00	0x00	0x04	0x2e	0x24	0x00	0x00	0x07
0x8176240:	0x00	0x00	0x00	0x40	0x00	0x00	0x00	0x00
0x8176248:	0x44	0x00	0x00	0x07	0x00	0x00	0x00	0x00
0x8176250:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x07
0x8176258:	0x00	0x00	0x00	0x18	0x00	0x00	0x00	0x00
0x8176260:	0x44	0x00	0x00	0x08	0x00	0x00	0x00	0x20
0x8176268:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x09
0x8176270:	0x00	0x00	0x00	0x30	0x00	0x00	0x00	0x00
0x8176278:	0x24	0x00	0x00	0x00	0x00	0x00	0x00	0x40
0x8176280:	0x00	0x00	0x00	0x00	0x64	0x00	0x00	0x00
0x8176288:	0x00	0x00	0x00	0x80
(gdb) p *(int**)0x8176240
$6 = (int *) 0x40000000
(gdb) watch *(int**)0x8176240
Hardware watchpoint 2: *(int**)0x8176240

ここを変更している瞬間を捕える.

#1  0x0806dd8b in fixup_segment (fixP=0x81595e4, this_segment=0x816c580) at write.c:1090
      if (!fixP->fx_done)
	md_apply_fix (fixP, &add_number, this_segment);

ここだった. よく分からないのがこれが

void
bfd_putb32 (bfd_vma data, void *p)
{

の呼び出しになっているということ.

   0x0806dd86 <+1343>:	call   0x8073ca0 <md_apply_fix>
=> 0x0806dd8b <+1348>:	add    $0x10,%esp

やはり md_apply_fix の呼び出し. ここは深くは追求しない.


(gdb) p *fixP
$9 = {fx_next = 0x8159638, fx_pcrel = 0, fx_done = 0, fx_no_overflow = 0, 
  fx_signed = 0, fx_tcbit = 0, fx_tcbit2 = 0, fx_unused = 0, 
  fx_pcrel_adjust = 0, fx_size = 4, fx_r_type = BFD_RELOC_32, 
  fx_frag = 0x8176080, fx_where = 392, fx_addsy = 0x81591f0, fx_subsy = 0x0, 
  fx_offset = 64, fx_dot_value = 392, fx_dot_frag = 0x8176080, 
  fx_addnumber = 0, fx_file = 0xbffff832 "test.S", fx_line = 59}
(gdb)

test.S:59:
	.stabs	"main:F(0,1)",36,0,7,main

これっぽい. そして fx_r_type = BFD_RELOC_32 になっている. これがどういう意味を
持つかは想像でしかないが, おそらくアセンブル時には決まっていないということなのだと思う.

同じことを i960-elf-as でやってみた:

      if (!fixP->fx_done)
	{
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);  ここにきている.
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif


(gdb) p *fixP
$9 = {fx_pcrel_adjust = 0 '\000', fx_size = 4 '\004', fx_pcrel = 0, 
  fx_plt = 0, fx_im_disp = 0, fx_tcbit = 0, fx_done = 0, fx_no_overflow = 0, 
  fx_signed = 0, fx_frag = 0x80f17d0, fx_where = 4, fx_addsy = 0x80dac38, 
  fx_subsy = 0x0, fx_offset = 0, fx_next = 0x80dad04, fx_bit_fixP = 0x0, 
  fx_r_type = 4294967295, fx_addnumber = 0, fx_file = 0xbffff82f "test3.S", 
  fx_line = 63, tc_fix_data = {bsr = 1}}
(gdb)

test3.S:63:
	callx	___main

ということは

	.stabs	"f:F1",36,0,2,_f

や

	.stabs	"main:F1",36,0,7,_main

に対しては自分が期待した処理がされていないということ. だからこそできていないのかも.
と思ったが, 以下のようにブレークポイントを埋め込んでみたところきている:

      switch (fixP->fx_line) {
      case 28: case 53: case 55: case 74:
	asm("int3");
	break;
      default:
	break;
      }

      if (!fixP->fx_done)
	{

fixP->fx_line が 28 と 55 に対してきている. 55 のときの add_number が 0 の
ままになっているのが期待する動作と異なっている.

(gdb) p *fixP
$30 = {fx_pcrel_adjust = 0 '\000', fx_size = 4 '\004', fx_pcrel = 0, 
  fx_plt = 0, fx_im_disp = 0, fx_tcbit = 0, fx_done = 0, fx_no_overflow = 0, 
  fx_signed = 0, fx_frag = 0x8107580, fx_where = 392, fx_addsy = 0x80dab64, 
  fx_subsy = 0x0, fx_offset = 0, fx_next = 0x80dabfc, fx_bit_fixP = 0x0, 
  fx_r_type = BFD_RELOC_32, fx_addnumber = 0, fx_file = 0xbffff82f "test3.S", 
  fx_line = 55, tc_fix_data = {bsr = 0}}
(gdb) 

ここはそれっぽい. add_number の期待値は 0x20 なのでそれをデバッガで変更してみた.
しかし生成された test3.o の objdump の結果は以下:

int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
} /* 0x44 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */

0x44 のまま. ここが 0x64 になっていてほしかったがそういうものでもないらしい.

しかしまずは add_number が 0x20 にならない理由を調べてみる.
と思ったがまずは d30v-elf-as の場合は add_number が 0x40 になる理由を調べみる
ことにした.

d30v-elf-as にも以下のようなブレークポイントを埋め込んでみた:

      switch (fixP->fx_line) {
      case 29: case 59:
	asm("int3");
	break;
      default:
	break;
      }

      if (!fixP->fx_done)
	md_apply_fix (fixP, &add_number, this_segment);


59 行目で停止したときは add_number = 0x40 になっている. そこで 29 行目で停止したとき
に add_number にウォッチポイントをセットしてみた:

      add_number = fixP->fx_offset;

ここで

0 -> 24 -> 40 -> 64

のように変更されて, そして 59 行目に対する埋め込んだブレークポイントにヒットしている.
同じことを i960-elf-as でも試してみた.

0 -> 12 -> 24 -> 0

      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;   ここ
      pcrel = fixP->fx_pcrel;
      plt = fixP->fx_plt;

24 から 0 ではなくて 32 になっていれば期待している動作. ということは fixP->fx_offset
が 0 になる理由を調べるべき.

fix_new_internal (frag=0x8107580, where=392, size=4, add_symbol=0x80dab64, sub_symbol=0x0, offset=0, pcrel=0, r_type=BFD_RELOC_32) at write.c:175

ここで 0 にセットしていた. ということは fix_new_internal(offset=0) で呼び出されている
ことがそもそも期待しない動作. そこで以下のようにブレークポイントを埋め込んでみた:

fixS *
fix_new_exp (frag, where, size, exp, pcrel, r_type)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* TRUE if PC-relative relocation. */
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type */
#else
     int r_type;		/* Relocation type */
#endif
{
  if (frag==(fragS*)0x8107580 && where==392 && size==4 && exp==(expressionS*)0xbffff368 && pcrel==0 && r_type==BFD_RELOC_32)
    asm("int3");

ここで問題の瞬間を捕えられている.

    case O_symbol:
      add = exp->X_add_symbol;           ここにきている.
      /* Fall through.   */
    case O_constant:
      off = exp->X_add_number;
      break;

ということは, exp->X_add_number が 0x20 であるべきものが 0 になっているということ.

d30v-elf-as では以下のようになっていた:

static fixS *
fix_new_internal (fragS *frag,		/* Which frag?  */
...


  fixP->fx_offset = offset;  一旦ここで 0 にセット.


adjust_reloc_syms (abfd=0x8158410, sec=0x816c580, xxx=0x0) at write.c:902
...
	fixp->fx_offset += S_GET_VALUE (sym);  ここで 64 に更新

(gdb) p *sym
$26 = {flags = {local_symbol = 0, written = 0, resolved = 1, resolving = 0, 
    used_in_reloc = 0, used = 1, volatil = 0, forward_ref = 0, 
    mri_common = 0, weakrefr = 0, weakrefd = 0}, hash = 4293691881, 
  name = 0x81595a0 "main", frag = 0x816d400, bsym = 0x817527c, x = 0x81595c0}
(gdb) 

それっぽい.この動きになっていれば良さそう.

#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp)) この条件が成立して
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;  ここで done にいく.
	  }
#endif	  
...
	fixp->fx_offset += S_GET_VALUE (sym);

なので上をコンパイルアウトした. これで以下のような出力になっている.


int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
} /* 0x44 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */

ここだけ修正してもだめらしいが,

config/tc-i960.h

#ifndef OBJ_ELF
#define tc_fix_adjustable(FIXP)		((FIXP)->fx_bsr == 0)
#else
#define tc_fix_adjustable(FIXP)						\
  ((FIXP)->fx_bsr == 0							\
   && ! S_IS_EXTERNAL ((FIXP)->fx_addsy)				\
   && ! S_IS_WEAK ((FIXP)->fx_addsy))
#endif

ここに定義がある. define するのが正しいとすれば定義を間違えている可能性もある.

d30v-elf-as がどうなっているか調べてみた. define されていない.
そこで試しに

#if 0
#ifndef OBJ_ELF
#define tc_fix_adjustable(FIXP)		((FIXP)->fx_bsr == 0)
#else
#define tc_fix_adjustable(FIXP)						\
  ((FIXP)->fx_bsr == 0							\
   && ! S_IS_EXTERNAL ((FIXP)->fx_addsy)				\
   && ! S_IS_WEAK ((FIXP)->fx_addsy))
#endif
#endif

のように修正してみた.

int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
} /* 0x44 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */

しかし状況は変わらない. 0x44 の部分は別の対応が必要らしい.

一旦埋め込んでいたブレークポイントを削除した:

  if (frag==(fragS*)0x8107580 && where==392 && size==4 && exp==(expressionS*)0xbffff368 && pcrel==0 && r_type==BFD_RELOC_32)
    asm("int3");
...
  if (strcmp(sec->name, ".stab") == 0)
    asm("int3");
...
	if (sym == (symbolS *) 0x80dab64)
	  asm("int3");
...
      switch (fixP->fx_line) {
      case 28: case 53: case 55: case 74:
	asm("int3");
	break;
      default:
	break;
      }

.stab に対して bfd_set_section_contents をしているときの状態は以下:

(gdb) x/444bx f->fr_literal
0x81075b0:	0x01	0x00	0x00	0x00	0x00	0x00	0x24	0x00
0x81075b8:	0x7a	0x03	0x00	0x00	0x09	0x00	0x00	0x00
0x81075c0:	0x64	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075c8:	0x47	0x00	0x00	0x00	0x64	0x00	0x00	0x00
0x81075d0:	0x00	0x00	0x00	0x00	0x4e	0x00	0x00	0x00
0x81075d8:	0x3c	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075e0:	0x5d	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x81075e8:	0x00	0x00	0x00	0x00	0x7f	0x00	0x00	0x00
0x81075f0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81075f8:	0x95	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x8107600:	0x00	0x00	0x00	0x00	0xbc	0x00	0x00	0x00
0x8107608:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107610:	0xec	0x00	0x00	0x00	0x80	0x00	0x00	0x00
0x8107618:	0x00	0x00	0x00	0x00	0x21	0x01	0x00	0x00
0x8107620:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107628:	0x6a	0x01	0x00	0x00	0x80	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8107630:	0x00	0x00	0x00	0x00	0xb3	0x01	0x00	0x00
0x8107638:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107640:	0xd6	0x01	0x00	0x00	0x80	0x00	0x00	0x00
0x8107648:	0x00	0x00	0x00	0x00	0xfd	0x01	0x00	0x00
0x8107650:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107658:	0x1f	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107660:	0x00	0x00	0x00	0x00	0x40	0x02	0x00	0x00
0x8107668:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107670:	0x52	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107678:	0x00	0x00	0x00	0x00	0x65	0x02	0x00	0x00
0x8107680:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107688:	0x7e	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x8107690:	0x00	0x00	0x00	0x00	0xab	0x02	0x00	0x00
0x8107698:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076a0:	0xc5	0x02	0x00	0x00	0x80	0x00	0x00	0x00
0x81076a8:	0x00	0x00	0x00	0x00	0xe1	0x02	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x81076b0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076b8:	0x02	0x03	0x00	0x00	0x80	0x00	0x00	0x00
0x81076c0:	0x00	0x00	0x00	0x00	0x0e	0x03	0x00	0x00
0x81076c8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81076d0:	0x50	0x03	0x00	0x00	0x80	0x00	0x00	0x00
0x81076d8:	0x00	0x00	0x00	0x00	0x63	0x03	0x00	0x00
0x81076e0:	0x24	0x00	0x02	0x00	0x00	0x00	0x00	0x00
0x81076e8:	0x68	0x03	0x00	0x00	0xa0	0x00	0x01	0x00
0x81076f0:	0x40	0x00	0x00	0x00	0x6d	0x03	0x00	0x00
0x81076f8:	0xa0	0x00	0x01	0x00	0x44	0x00	0x00	0x00
0x8107700:	0x00	0x00	0x00	0x00	0x44	0x00	0x02	0x00
0x8107708:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107710:	0x44	0x00	0x03	0x00	0x0c	0x00	0x00	0x00
0x8107718:	0x00	0x00	0x00	0x00	0x44	0x00	0x04	0x00
0x8107720:	0x18	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107728:	0x24	0x00	0x00	0x00	0x20	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8107730:	0x72	0x03	0x00	0x00	0x24	0x00	0x07	0x00
0x8107738:	0x20	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107740:	0x44	0x00	0x07	0x00	0x20	0x00	0x00	0x00
0x8107748:	0x00	0x00	0x00	0x00	0x44	0x00	0x08	0x00
0x8107750:	0x28	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8107758:	0x44	0x00	0x09	0x00	0x3c	0x00	0x00	0x00
0x8107760:	0x00	0x00	0x00	0x00	0x24	0x00	0x00	0x00
0x8107768:	0x24	0x00	0x00	0x00
(gdb) p *(int**)0x8107738
$107 = (int *) 0x20
(gdb) watch *(int**)0x8107738
(gdb) run
...
期待したところで 0x20 に更新されている. これまでの修正を確認した.

一方 0x44 だがこれは数個あってどれかは自信が全くない. だからできている d30v-elf-as
でどのように更新しているか調べてみた.

やはり .stab に対して bfd_set_section_contents をしているときの状態をまず確認してみた:

(gdb) x/468bx f->fr_literal
0x81760b8:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0x26
0x81760c0:	0x00	0x00	0x04	0x3a	0x00	0x00	0x00	0x08
0x81760c8:	0x64	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81760d0:	0x00	0x00	0x00	0x46	0x64	0x00	0x00	0x00
0x81760d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x4d
0x81760e0:	0x3c	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81760e8:	0x00	0x00	0x00	0x5c	0x80	0x00	0x00	0x00
0x81760f0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x86
0x81760f8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176100:	0x00	0x00	0x00	0xa0	0x80	0x00	0x00	0x00
0x8176108:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0xcf
0x8176110:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176118:	0x00	0x00	0x01	0x07	0x80	0x00	0x00	0x00
0x8176120:	0x00	0x00	0x00	0x00	0x00	0x00	0x01	0x44
0x8176128:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176130:	0x00	0x00	0x01	0x95	0x80	0x00	0x00	0x00
--Type <RET> for more, q to quit, c to continue without paging--
0x8176138:	0x00	0x00	0x00	0x00	0x00	0x00	0x01	0xe6
0x8176140:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176148:	0x00	0x00	0x02	0x11	0x80	0x00	0x00	0x00
0x8176150:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0x40
0x8176158:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176160:	0x00	0x00	0x02	0x6a	0x80	0x00	0x00	0x00
0x8176168:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0x93
0x8176170:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176178:	0x00	0x00	0x02	0xad	0x80	0x00	0x00	0x00
0x8176180:	0x00	0x00	0x00	0x00	0x00	0x00	0x02	0xc8
0x8176188:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176190:	0x00	0x00	0x02	0xe8	0x80	0x00	0x00	0x00
0x8176198:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x21
0x81761a0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761a8:	0x00	0x00	0x03	0x3f	0x80	0x00	0x00	0x00
0x81761b0:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x5f
--Type <RET> for more, q to quit, c to continue without paging--
0x81761b8:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761c0:	0x00	0x00	0x03	0x84	0x80	0x00	0x00	0x00
0x81761c8:	0x00	0x00	0x00	0x00	0x00	0x00	0x03	0x98
0x81761d0:	0x80	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x81761d8:	0x00	0x00	0x03	0xfc	0x80	0x00	0x00	0x00
0x81761e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x04	0x13
0x81761e8:	0x24	0x00	0x00	0x02	0x00	0x00	0x00	0x00
0x81761f0:	0x00	0x00	0x04	0x1c	0xa0	0x00	0x00	0x01
0x81761f8:	0x00	0x00	0x00	0x00	0x00	0x00	0x04	0x25
0x8176200:	0xa0	0x00	0x00	0x01	0x00	0x00	0x00	0x04
0x8176208:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x02
0x8176210:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x8176218:	0x44	0x00	0x00	0x03	0x00	0x00	0x00	0x18
0x8176220:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x04
0x8176228:	0x00	0x00	0x00	0x28	0x00	0x00	0x00	0x00
0x8176230:	0x24	0x00	0x00	0x00	0x00	0x00	0x00	0x40
--Type <RET> for more, q to quit, c to continue without paging--
0x8176238:	0x00	0x00	0x04	0x2e	0x24	0x00	0x00	0x07
0x8176240:	0x00	0x00	0x00	0x40	0x00	0x00	0x00	0x00
0x8176248:	0x44	0x00	0x00	0x07	0x00	0x00	0x00	0x00
0x8176250:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x07
0x8176258:	0x00	0x00	0x00	0x18	0x00	0x00	0x00	0x00
0x8176260:	0x44	0x00	0x00	0x08	0x00	0x00	0x00	0x20
0x8176268:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x09
0x8176270:	0x00	0x00	0x00	0x30	0x00	0x00	0x00	0x00
0x8176278:	0x24	0x00	0x00	0x00	0x00	0x00	0x00	0x40
0x8176280:	0x00	0x00	0x00	0x00	0x64	0x00	0x00	0x00
0x8176288:	0x00	0x00	0x00	0x80
(gdb) 

とここで勘違いしていたことに気付いた.

int main ()
{ /* 0x20 */
  /* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 7 addr 0x40 */
} /* 0x44 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 8 addr 0x48 */
/* file /home/khasegawa/lang/53_GNU_tool/gcc_cross/i960/test/test002/test.c line 9 addr 0x5c */


main の最後のアドレスは 0x44 で正しい. 0x24 だったのが 0x44 に更新されたわけだ.
正しくないのが

0x40 -> 0x20
0x48 -> 0x28
0x5c -> 0x3c 

と今度はこっちがずれている.

おそらく

	.stabs	"main:F1",36,0,7,_main

に対しては

	fixp->fx_offset += S_GET_VALUE (sym);

の処理がされるのが正しいのだが,

	.stabd	68,0,7
...	
	.stabd	68,0,8
...	
	.stabd	68,0,9

に対しては

#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp)) この条件が成立して
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;  ここで done にいく.
	  }
#endif	  

が正しいのだろう. これを確認する. 以下のように修正.

#if 0
#ifndef OBJ_ELF
#define tc_fix_adjustable(FIXP)		((FIXP)->fx_bsr == 0)
#else
#define tc_fix_adjustable(FIXP)						\
  ((FIXP)->fx_bsr == 0							\
   && ! S_IS_EXTERNAL ((FIXP)->fx_addsy)				\
   && ! S_IS_WEAK ((FIXP)->fx_addsy))
#endif
#else
#define tc_fix_adjustable(FIXP) i960_fix_adjustable(FIXP)
#endif

以下を追加:

int i960_fix_adjustable(fixS* fixp)
{
  asm("int3");
  int n = fixp->fx_line;
  switch (n) {
  case 67:
  case 28:
  case 55:    
  case 1: case 2:
    return 1;
  default:
    return 0;
  }
}

これは _f, _main, Ltext0 に対して 1 をそれ以外には 0 を返したものである.
これは test3.S に対してのみ正しく動作している. と思ったができていなかった.

ここで調整するのはあまり良くなさそう.

まずは write.c を直接修正して期待する動作を確認するべき.

	.stabs	"f:F1",36,0,2,_f                 (*)
...
	.stabd	68,0,2
...
	.stabd	68,0,3
...
	.stabd	68,0,4
...
	.stabs	"",36,0,0,Lscope0-_f
...
	.stabs	"main:F1",36,0,7,_main           (*)
...
	.stabd	68,0,7
...
	.stabd	68,0,8
...
	.stabd	68,0,9
...
	.stabs	"",36,0,0,Lscope1-_main

に対して (*) でオフセットを設定し, そのオフセットを保持した形で
他のところではオフセットを...

とここまで書いて d30v-elf-as の入力が,

	.stabs	"f:F(0,1)",36,0,2,f
...
	.stabn 68,0,2,.LM1-f
...
	.stabn 68,0,3,.LM2-f
...
	.stabn 68,0,4,.LM3-f

のように少し様子が違っていることに気付く. つまり test3.S は期待値として正しいつもりで
いたがその限りではなかったということ.

一旦この調査は終了してコンパイラの観点から期待値を作成してみる. とは言え
.stab を生成するコンパイラが 3.4.4 では d30v-elf-gcc のみで
10.2.0 も含めれば avr-elf-gcc もある. 参考になるかどうかは疑問.








