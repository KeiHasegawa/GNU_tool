現状自前の cc1 が生成したプログラム

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.i960-elf.mine/host-i686-pc-linux-gnu/gcc/a.elf

を実行し, f にステップインするとプロローグを適切にスキップできていない.

f にブレークポイントをセットすればプロローグは適切にスキップできている. またその場合でも引数の
a と b を正しく表示できていない.

まずはステップインしたとき適切にプロローグをスキップすることを目標にする. このプログラムの
スタックフレームは以下:

start:
	code  : 0x100
	stack : 0x1b000
	size  : なし
	ret   : なし

main:
	code  : 0x174
	stack : 0x1b040 (プロローグ後 0x1b080)
	size  : 0x40
	ret   : 0x140 (0x1b008 に保存)

f:
	code  : 0x154
	stack : 0x1b0c0 (プロローグ後 0x1b108)
	size  : 0x48
	ret   : 0x18c (0x1b048 に保存)

現状 i960_frame_prev_register で即値を返すようにして f にステップインしたときに
プロローグを適切にスキップできるようになっている.

次の目標は a と b の値を正しく表示すること.

(i960-elf-gdb) p &a
$1 = (int *) 0x1b0b8
(i960-elf-gdb) p &b
$2 = (int *) 0x1b0bc

a はフレーム相対 64, b はフレーム相対 68 だから

0x1b0c0 + 0x40 = 0x1b100
0x1b0c0 + 0x44 = 0x1b104

が正しい:

(i960-elf-gdb) p *(int*)0x1b100
$3 = 5
(i960-elf-gdb) p *(int*)0x1b104
$4 = 6

a.objdump の抜粋

int32 f (int32 a /* 0x40 */, int32 b /* 0x44 */)

ということはコンパイラは必要な情報は出しているっぽい. そこで以下のように修正してみた:

static CORE_ADDR
i960_frame_base_address(frame_info* frame, void** ptr)
{
#if 0  
  auto pf = reinterpret_cast<i960_frame*>(*ptr);
  if (!pf)
    *ptr = pf = i960_frame_create(frame);
  return pf->prev_sp - pf->size;
#else
  return 0x1b0c0;
#endif  
}

期待した動作になっている. 計算が正しくないらしい. ここで以下が正しいと気付く.

static CORE_ADDR
i960_frame_base_address(frame_info* frame, void** ptr)
{
  auto pf = reinterpret_cast<i960_frame*>(*ptr);
  if (!pf)
    *ptr = pf = i960_frame_create(frame);
  return pf->prev_sp;

続いて where コマンドを実行してみた.

(i960-elf-gdb) where
#0  f (a=5, b=6) at a.c:5
#1  0x0000018c in main () at a.c:10
Backtrace stopped: previous frame inner to this frame (corrupt stack?)

これは以前も見たことがあるメッセージだが対応の仕方は不明.

(gdb) b backtrace_command
(gdb) run
...
backtrace_command のブレークポイントにヒット
(gdb) b stack.c:2118          # 確かここでメッセージを出力していたはず.
(gdb) c
...
きている.

エラーの直接の原因は

	  reason = get_frame_unwind_stop_reason (trailing);
	  if (reason >= UNWIND_FIRST_ERROR)

(gdb) p reason
$7 = UNWIND_INNER_ID
(gdb) 

ということなのだが,

(gdb) p *trailing
$8 = {level = 1, pspace = 0x8db3688, aspace = 0x8db3b30, 
  prologue_cache = 0x8e20d40, unwind = 0x8c8f9c0 <i960_frame_unwind>, 
  prev_arch = {p = false, arch = 0x0}, prev_pc = {status = CC_UNKNOWN, 
    masked = false, value = 0}, prev_func = {addr = 0, status = CC_UNKNOWN}, 
  this_id = {p = frame_id_status::COMPUTED, value = {stack_addr = 110656, 
      code_addr = 372, special_addr = 0, stack_status = FID_STACK_VALID, 
      code_addr_p = 1, special_addr_p = 0, artificial_depth = 0}}, 
  base = 0x0, base_cache = 0x0, next = 0x8d6ce6c, prev_p = true, prev = 0x0, 
  stop_reason = UNWIND_INNER_ID, stop_string = 0x0}
(gdb)

stop_reason = UNWIND_INNER_ID になるのがその原因. ここに値をセットする瞬間を捕える.

  if (get_frame_type (this_frame) == NORMAL_FRAME
      && this_frame->next->unwind->type == NORMAL_FRAME
      && frame_id_inner (get_frame_arch (this_frame->next),
			 get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    {
...
      if (!morestack_name || strcmp (morestack_name, "__morestack") != 0)
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // this frame ID is inner }\n");
	    }
	  this_frame->stop_reason = UNWIND_INNER_ID;   ここだった.
	  return NULL;

最初の条件が成立するのが期待しない動作らしい.

(gb) p frame_id_inner(get_frame_arch(this_frame->next), get_frame_id(this_frame), get_frame_id(this_frame->next))
$9 = true

おそらくどちらのフレーム ID も i960_frame_this_id で作成したものだと思われる.
まずは frame_id_inner が true を返す理由を調べてみる.

    inner = gdbarch_inner_than (gdbarch, l.stack_addr, r.stack_addr);

ここで true がセットされている.
おそらくだが i960 はスタックがアドレスの高い方向に成長するタイプなのでデフォルト
の判定では正しくない. デフォルトの判定は以下

int
core_addr_lessthan (CORE_ADDR lhs, CORE_ADDR rhs)
{
  return (lhs < rhs);
}

そこで以下を追加

static int i960_core_addr_lessthan(CORE_ADDR lhs, CORE_ADDR rhs)
{
  return lhs > rhs;
}
...
  set_gdbarch_inner_than(arch, i960_core_addr_lessthan);

これで問題のメッセージは出なくはなった.

現状

static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{

では自分が正しいと考えている値を即値で返しているのだが where コマンドが
期待したところで終了していない:

(i960-elf-gdb) where
#0  f (a=5, b=6) at a.c:5
#1  0x0000018c in main () at a.c:10
#2  0x00000140 in start () at start.S:16
(i960-elf-gdb)

#2 の行は他のプロセッサのツールでは表示していなかった(それは意図してではないのだが).

とりあえずこれはこれで問題なしとしておく.

現状

static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{

で即値を返してはいるものの

step
where
finish

が期待通り動作している. 

これらの期待値を参考に実装してみたが, callx 命令の仕様から他のプロセッサの同じルーチンと
比べて複雑になっている.

複雑になっている理由は戻りアドレスを計算するためには, 前のフレームの情報が必要なのだが,

static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{
  auto next = get_next_frame(frame);
  auto pf = i960_frame_create(next);
...

や

static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{
  auto prev = get_prev_frame(frame);
  auto pf = i960_frame_create(prev);
...

のようにしてみても期待した動作にはなっていないためで, 現状はやりたいことを

static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{
  auto pf = reinterpret_cast<i960_frame*>(*ptr);
  auto up = i960_frame_impl::up(pf);  

のように自前でやっている. これは本当は良くないのかもしれない.

現状の状態での i960-tdep.c を i960-tdep.c.002 としてアップロードしておく.
このファイルには

#ifdef CHECK_VALUE
...
  assert(...);

や

#ifdef USE_MY_VALUE
static value*
i960_frame_prev_register(frame_info* frame, void** ptr, int regno)
{
  // 期待値をハードコーディング 

のように hello world 11 だけに対してのみ正しく動くコードが入っている. そのうち
削除される予定.
