M68HC11 の ABI

(*0) レジスタ
(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*0) レジスタ

pc : プログラムカウンタ
sp : スタックポインタ
ccr : Condition Code Register

        7 6 5 4 3 2 1 0
       +-+-+-+-+-+-+-+-+
       |S|X|H|I|N|Z|V|C|
       +-+-+-+-+-+-+-+-+

       S : Stop disable
       X : X-interrupt mask
       H : Half carry flag
       I : I-interrupt mask
       N : Negative
       Z : Zero
       O : Overflow
       C : Carry

d : D レジスタ 16 ビット
x : X レジスタ 16 ビット
y : Y レジスタ 16 ビット
d, x, y が汎用レジスタ. 勿論命令によって指定できたりできなかったりする. 

a : d の上位 8 ビット
b : d の下位 8 ビット

_.frame : レジスタではない. メモリの特定のアドレスをフレームポインタとして使用している.

(*1) 函数呼び出し

	bsr	func

	疑似コード

	memory[sp-1] = (bsr 命令の次のアドレス)
	sp -= 2	
	pc = func

(*2) 函数復帰

	rts

	疑似コード

	sp += 2
	pc = memory[sp-1]
	

(*3) プロローグ

				疑似コード
	ldx	*_.frame	x = _.frame
	pshx			memory[sp-1] = x
				sp -= 2
	tsx			x = sp + 1
	xgdx			x <-> d
	addd	#-128		d -= 128
	xgdx			x <-> d
	txs			sp = x - 1
	sts	*_.frame	_.frame = sp

	上は 128 バイトのローカルエリアを使用する函数のプロローグである.

	+------------------+ 
	|     sp_{new}     | _.frame
	+------------------+ 
        ~                  ~
        ~                  ~
	+------------------+ <- sp_{new}
	|                  |
	|                  |
	|    local area    |
	|                  |
	|                  |
	+------------------+ +129 
	|   _.frame_{old}  | <- sp_{old}
	+------------------+ +131
	|  return address  |
	+------------------+ +133


(*4) エピローグ
				疑似コード
	tsy			y = sp + 1
	xgdy			y <-> d
	addd	#128		d += 128
	xgdy			y <-> d
	tys			sp = y - 1
	puly			sp += 2
				y = memory[sp-1]
	sty	*_.frame	_.frame = y
	rts

	上は 128 バイトのローカルエリアを使用する函数のエピローグである.
	_.frame, sp が復元され呼び出し元に復帰する.
	
(*5) 通常の函数の引数と戻り値

        sizeof(int) = 4  オプション指定なしもしくは -mlong オプション
	sizeof(int) = 2  -mshort オプション

	第 1 引数 : d レジスタ. sizeof(int) = 4 の場合は x レジスタに
                   上位 2 バイト
	第 2 引数以降 : スタックに積む

	int f(int a0, int a1, int a2, int a3);

	f(10, 11, 12, 13);

	に対して f の先頭アドレスでは以下のようになっている. 以下は sizeof(int) = 4
        の場合:

	d = 10, x = 0

	+------------------+ -1
	|                  | <- sp
	+------------------+ +1
	|  return address  |
	+------------------+ +3
	|                  |
	|        11        |
	+------------------+ +7
	|                  |
	|        12        |
	+------------------+ +11
	|                  |
	|        13        |
	+------------------+ +15

	sizeof(int) = 2 の場合はスタックのオフセットは 4 ではなくて 2
	ずつずれる.

        函数の戻り値は d レジスタにセットされる. sizeof(int) = 4 の場
	合は x レジスタに上位 2 バイトがセットされる.

(*6) long long を引数にとる函数, 返す函数

        long long 型の引数はスタックで渡される.
	long long 型の戻り値は d レジスタに戻り値を格納するためのアドレスがセットされる.

	long long f(int a0, long long a1);

	f(10, 0x123456789abcdef0LL);

	に対して f の先頭アドレスでは以下のようになっている.

	+------------------+ -1
	|                  | <- sp
	+------------------+ +1
	|  return address  |
	+------------------+ +3
	|                  |
	|        10        |
	+------------------+ +7
	|                  |
	|    0x12345678    |
	+------------------+ +11
	|                  |
	|    0x9abcdef0    |
	+------------------+ +15

(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

        Motorola 68HC11 には FPU がないのでソフトウェアで浮動少数点数演算を行なう.
	float の第 1 引数に対して X, Y レジスタが使用される. 残りはスタックに
	積まれる.
	float を返す函数は X, Y レジスタに値がセットされる.

	double, long double の引き数はスタックに積んで渡される.
	double, long double の戻り値の函数を呼び出すとき d レジスタに戻り値を
	格納するアドレスをセットする.

(*8) 構造体を引数にとる函数, 構造体を返す函数

	構造体を引数に取る函数を呼び出すときスタックに引数の値をセットする.
	構造体を返す函数を呼び出すとき, 戻り値を格納するアドレスを d レジスタにセットする.
	
