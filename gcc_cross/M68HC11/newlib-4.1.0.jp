newlib-4.1.0 のインストール

gunzip -c ../newlib-4.1.0.tar.gz | tar xf -
mv newlib-4.1.0 newlib-4.1.0.m68hc11-elf
cd newlib-4.1.0.m68hc11-elf
find . -name 'Makefile.*' -exec ../erase_O2 {} \;
find . -name 'configure' -exec ../erase_O2 {} \;
./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=m68hc11-elf
make && exit 1
find . -name 'Makefile' -exec ../erase_Os {} \;
make
...

m68hc11-elf-gcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/m68hc11 -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/libnosys -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/libgloss/m68hc11  -m68hc11 -DPACKAGE_NAME=\"newlib\" -DPACKAGE_TARNAME=\"newlib\" -DPACKAGE_VERSION=\"4.1.0\" -DPACKAGE_STRING=\"newlib\ 4.1.0\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\" -I. -I../../../../.././newlib/libc/time -DPREFER_SIZE_OVER_SPEED -O0 -mrelax -DNO_EXEC -DABORT_PROVIDED -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES -DHAVE_INIT_FINI      -g -O0 -c -o lib_a-strftime.o `test -f 'strftime.c' || echo '../../../../.././newlib/libc/time/'`strftime.c
../../../../.././newlib/libc/time/strftime.c: 関数 ‘__strftime’ 内:
../../../../.././newlib/libc/time/strftime.c:1426:1: エラー: unable to find a register to spill in class ‘A_REGS’
 1426 | }
      | ^
../../../../.././newlib/libc/time/strftime.c:1426:1: エラー: this is the insn:
(insn 2600 2599 2603 340 (parallel [
            (set (reg:SI 14 *_.d1 [orig:346 _293 ] [346])
                (minus:SI (reg:SI 332 [ _279 ])
                    (reg:SI 14 *_.d1 [orig:432 iftmp.45_439 ] [432])))
            (clobber (scratch:HI))
        ]) "../../../../.././newlib/libc/time/strftime.c":1231:8 57 {*subsi3}
     (expr_list:REG_DEAD (reg:SI 14 *_.d1 [orig:432 iftmp.45_439 ] [432])
        (expr_list:REG_DEAD (reg:SI 332 [ _279 ])
            (nil))))
../../../../.././newlib/libc/time/strftime.c:1426: 前のエラーにより混乱していますので、脱出します


M-x gdb
gdb --annotate ./cc1
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/libc/time
(gdb) run -quiet -I . -I ../../../../.././newlib/libc/time -imultilib m68hc11 "-D__INT__=32" -Dmc6811 -DMC6811 -Dmc68hc11 -D PREFER_SIZE_OVER_SPEED -D NO_EXEC -D ABORT_PROVIDED -D SMALL_MEMORY -D MISSING_SYSCALL_NAMES -D HAVE_INIT_FINI -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include ../../../../.././newlib/libc/time/strftime.c -quiet -dumpbase strftime.c -m68hc11 -mrelax -auxbase-strip lib_a-strftime.o -g -O0 -O0 -o /tmp/ccyb0KZT.s

エラーを gdb から実行して再現できている.

同じことを gcc-9.1.0 の cc1 でやってみたところ, 以下のようになった:

../../../../.././newlib/libc/time/strftime.c: 関数 ‘__strftime’ 内:
../../../../.././newlib/libc/time/strftime.c:1426:1: エラー: cannot do z-register replacement
 1426 | }
      | ^
(insn 3838 3837 3839 (set (reg:HI 8 z)
        (plus:HI (reg:HI 8 z)
            (reg/f:HI 9 *_.frame))) "../../../../.././newlib/libc/time/strftime.c":695:24 -1
     (expr_list:REG_EQUIV (plus:HI (reg/f:HI 9 *_.frame)
            (const_int 512 [0x200]))
        (nil)))
during RTL pass: mach

これは gcc-10.2.0 で必要だった z レジスタの対応が抜けているために起こっているエラー
のように思える.

そこで m68hc11.h のコメントにあるように -ffixed-z で gcc-9.1.0 の cc1 を起動してみた:

(gdb) run -quiet -I . -I ../../../../.././newlib/libc/time -imultilib m68hc11 "-D__INT__=32" -Dmc6811 -DMC6811 -Dmc68hc11 -D PREFER_SIZE_OVER_SPEED -D NO_EXEC -D ABORT_PROVIDED -D SMALL_MEMORY -D MISSING_SYSCALL_NAMES -D HAVE_INIT_FINI -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include ../../../../.././newlib/libc/time/strftime.c -quiet -dumpbase strftime.c -m68hc11 -mrelax -auxbase-strip lib_a-strftime.o -g -O0 -O0 -o /tmp/ccyb0KZT.s -ffixed-z

../../../../.././newlib/libc/time/strftime.c: 関数 ‘__strftime’ 内:
../../../../.././newlib/libc/time/strftime.c:1426:1: エラー: unable to find a register to spill in class ‘A_REGS’
 1426 | }
      | ^
../../../../.././newlib/libc/time/strftime.c:1426:1: エラー: this is the insn:
(insn 2602 2601 2605 342 (parallel [
            (set (reg:SI 14 *_.d1 [orig:346 _293 ] [346])
                (minus:SI (reg:SI 332 [ _279 ])
                    (reg:SI 14 *_.d1 [orig:432 iftmp.45_439 ] [432])))
            (clobber (scratch:HI))
        ]) "../../../../.././newlib/libc/time/strftime.c":1231:8 57 {*subsi3}
     (expr_list:REG_DEAD (reg:SI 14 *_.d1 [orig:432 iftmp.45_439 ] [432])
        (expr_list:REG_DEAD (reg:SI 332 [ _279 ])
            (nil))))
../../../../.././newlib/libc/time/strftime.c:1426: 前のエラーにより混乱していますので、脱出します

これは gcc-10.2.0 の cc1 と同じような症状.
同様のことを gcc-8.1.0 でもやってみたところ同じエラーが発生する.
同様のことを gcc-7.1.0 でもやってみたところ同じエラーが発生する.
同様のことを gcc-6.1.0 でもやってみたところ正常終了している.

しかし, gcc-6.1.0 でも strptime.c のビルドで以下のようにエラーしている:

m68hc11-elf-gcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/m68hc11 -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/libnosys -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/libgloss/m68hc11  -m68hc11 -DPACKAGE_NAME=\"newlib\" -DPACKAGE_TARNAME=\"newlib\" -DPACKAGE_VERSION=\"4.1.0\" -DPACKAGE_STRING=\"newlib\ 4.1.0\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\" -I. -I../../../../.././newlib/libc/time -DPREFER_SIZE_OVER_SPEED -ffixed-z -mrelax -DNO_EXEC -DABORT_PROVIDED -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES -DHAVE_INIT_FINI      -g -ffixed-z -c -o lib_a-strptime.o `test -f 'strptime.c' || echo '../../../../.././newlib/libc/time/'`strptime.c
../../../../.././newlib/libc/time/strptime.c: 関数 ‘strptime_l’ 内:
../../../../.././newlib/libc/time/strptime.c:503:1: エラー: unable to find a register to spill in class ‘A_REGS’
 }
 ^
../../../../.././newlib/libc/time/strptime.c:503:1: エラー: this is the insn:
(insn 267 266 268 41 (parallel [
            (set (reg:SI 319)
                (ashift:SI (reg:SI 319)
                    (const_int 5 [0x5])))
            (clobber (scratch:HI))
        ]) ../../../../.././newlib/libc/time/strptime.c:209 114 {*ashlsi3_const}
     (expr_list:REG_EQUAL (ashift:SI (reg:SI 14 *_.d1 [317])
            (const_int 5 [0x5]))
        (nil)))
../../../../.././newlib/libc/time/strptime.c:503: 前のエラーにより混乱していますので、脱出します

これもやはり gdb から再現している
M-x gdb
gdb --annotate ./cc1
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/libc/time
(gdb) run -quiet -I . -I ../../../../.././newlib/libc/time -imultilib m68hc11 "-D__INT__=32" -Dmc6811 -DMC6811 -Dmc68hc11  -D PREFER_SIZE_OVER_SPEED -D NO_EXEC -D ABORT_PROVIDED -D SMALL_MEMORY -D MISSING_SYSCALL_NAMES -D HAVE_INIT_FINI -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include ../../../../.././newlib/libc/time/strptime.c -quiet -dumpbase strptime.c -m68hc11 -mrelax -auxbase-strip lib_a-strptime.o -g -ffixed-z -ffixed-z -o /tmp/ccXuPwxf.s

同じことを gcc-5.1.0 でもためしてみたところ正常終了している.
しかし gcc-5.1.0 でも stdlib/rand_r.c でエラーしている:

m68hc11-elf-gcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/m68hc11 -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/libgloss/libnosys -L/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/libgloss/m68hc11  -m68hc11 -DPACKAGE_NAME=\"newlib\" -DPACKAGE_TARNAME=\"newlib\" -DPACKAGE_VERSION=\"4.1.0\" -DPACKAGE_STRING=\"newlib\ 4.1.0\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\" -I. -I../../../../.././newlib/libc/stdlib -DPREFER_SIZE_OVER_SPEED -ffixed-z -mrelax -DNO_EXEC -DABORT_PROVIDED -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES -DHAVE_INIT_FINI      -g -ffixed-z -c -o lib_a-rand_r.o `test -f 'rand_r.c' || echo '../../../../.././newlib/libc/stdlib/'`rand_r.c
../../../../.././newlib/libc/stdlib/rand_r.c: 関数 ‘rand_r’ 内:
../../../../.././newlib/libc/stdlib/rand_r.c:37:1: エラー: unable to find a register to spill in class ‘A_REGS’
 }
 ^
../../../../.././newlib/libc/stdlib/rand_r.c:37:1: エラー: this is the insn:
(insn 34 33 35 5 (parallel [
            (set (reg:SI 72)
                (ashift:SI (reg:SI 72)
                    (const_int 5 [0x5])))
            (clobber (scratch:HI))
        ]) ../../../../.././newlib/libc/stdlib/rand_r.c:32 114 {*ashlsi3_const}
     (expr_list:REG_EQUAL (ashift:SI (reg:SI 14 *_.d1 [71])
            (const_int 5 [0x5]))
        (nil)))
../../../../.././newlib/libc/stdlib/rand_r.c:37: 前のエラーにより混乱していますので、脱出します

M-x gdb
gdb --annotate ./cc1
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/libc/stdlib
(gdb) run -quiet -I . -I ../../../../.././newlib/libc/time -imultilib m68hc11 "-D__INT__=32" -Dmc6811 -DMC6811 -Dmc68hc11  -D PREFER_SIZE_OVER_SPEED -D NO_EXEC -D ABORT_PROVIDED -D SMALL_MEMORY -D MISSING_SYSCALL_NAMES -D HAVE_INIT_FINI -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/m68hc11-elf/m68hc11/newlib/targ-include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include ../../../../.././newlib/libc/stdlib/rand_r.c -quiet -m68hc11 -mrelax -g -ffixed-z -ffixed-z -o /tmp/ccXuPwxf.s

とすれば gdb から cc1 を起動して再現できている.

同じことを gcc-4.2.0 の cc1 を gdb から起動して試してみたところ:

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/newlib-4.1.0.m68hc11-elf/newlib/libc/include/stdlib.h:134: エラー: wrong number of arguments specified for ‘__deprecated__’ attribute

のようにエラーしている. gcc-4.2.0 を再インストールしてもこのエラーはそのまま. ということは
__deprecated__ の仕様が変更されたのだろう.

4.2.0 => OK
4.3.0 => NG
4.5.4 => NG
4.6.0 => NG
4.6.4 => NG

であった. 
ということは, newlib-4.1.0 をビルドできる可能性のある, かつビルド済みの gcc は 5.1.0
ということになる.

まずは gcc-5.1.0 で newlib-4.1.0 をビルドすることに挑戦してみる.

gdb から再現させてみた. そして
(gdb) b _fatal_insn
(gdb) run
...
(gdb) where


	if (! find_reg (chain, i))
	  {
	    if (dump_file)
	      fprintf (dump_file, "reload failure for reload %d\n", r);
	    spill_failure (chain->insn, rld[r].rclass);   ここでエラーしている
	    
単純に A_REGS = (X or Y or Z) をはずしてみた. gcc-10.2.0 の修正の経緯から
Z もはずしてみた.

#if 0
#define REG_ALLOC_ORDER							\
{ HARD_D_REGNUM, HARD_X_REGNUM, HARD_Y_REGNUM,				\
  SOFT_REG_ORDER, HARD_Z_REGNUM, HARD_PC_REGNUM, HARD_A_REGNUM,		\
  HARD_B_REGNUM, HARD_CCR_REGNUM, HARD_FP_REGNUM, SOFT_FP_REGNUM,	\
  HARD_SP_REGNUM, SOFT_TMP_REGNUM, SOFT_Z_REGNUM, SOFT_SAVED_XY_REGNUM, \
  SOFT_AP_REGNUM, FAKE_CLOBBER_REGNUM  }
#else
#define REG_ALLOC_ORDER							\
{ HARD_D_REGNUM, HARD_X_REGNUM, HARD_Y_REGNUM,				\
  SOFT_REG_ORDER, HARD_PC_REGNUM, 		\
  HARD_B_REGNUM, HARD_CCR_REGNUM, HARD_FP_REGNUM, SOFT_FP_REGNUM,	\
  HARD_SP_REGNUM, SOFT_TMP_REGNUM, SOFT_Z_REGNUM, SOFT_SAVED_XY_REGNUM, \
  SOFT_AP_REGNUM, FAKE_CLOBBER_REGNUM  }
#endif

しかし症状は変わらない. そんなに単純ではないらしい. さてどうしたものだろう.

               10.2.0  9.1.0  8.1.0  7.1.0  6.1.0  5.1.0
strftime.c     NG      NG     NG     NG     OK     OK
strptime.c     ??      ??     ??     ??     NG     OK
rand_r.c       ??      ??     ??     ??     ??     NG

動作の比較ができればデバッグできる可能性はある.
strftime.c のコンパイルを 7.1.0 と 6.1.0 とで比較することができないだろうか.

gcc-7.1.0 でエラーとなるのは

static void
find_reload_regs (struct insn_chain *chain)
{
  if (chain->insn->u2.insn_uid == 2456)
    asm("int3");  この条件が成立するとき


(gdb) p debug_insn_slim(chain->insn)
 2456: {*_.d1:SI=r334:SI-*_.d1:SI;clobber scratch;}
      REG_DEAD *_.d1:SI
      REG_DEAD r334:SI
$2 = void

この命令である.

gcc-6.1.0 で以下を試してみた:
% cat xx
b find_reload_regs
command
silent
p debug_insn_slim(chain->insn)
c
end

(gdb) source xx
(gdb) run
...
 2456: {*_.d1:SI=r349:SI-*_.d1:SI;clobber scratch;}
      REG_DEAD r349:SI
      REG_DEAD *_.d1:SI
$1324 = void

334 と 349 の違いはあるもののそれ以外は同じ.

  for (i = 0; i < chain->n_reloads; i++)  chain->n_reloads はどちらも 4


  qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);

これが完了した時点でいずれも以下:

(gdb) x/4h reload_order 
0x907bc20 <_ZL12reload_order>:	1	3	0	2


  for (i = 0; i < n_reloads; i++)
    {
      int r = reload_order[i];

      /* Ignore reloads that got marked inoperative.  */
      if ((rld[r].out != 0 || rld[r].in != 0 || rld[r].secondary_p)
	  && ! rld[r].optional
	  && rld[r].regno == -1) {
	if (! find_reg (chain, i))  ここが r = 2, i = 3 で実行したとき

つまり最後のレジスタ(?)で gcc-7.1.0 で FAIL. gcc-6.1.0 では OK という
違いになっている.
おそらく

  order_regs_for_reload (chain);

も関係しているのだろうが, まずは find_reg(chain, 3) でどのような違いがあるか調査してみる.

	if (chain->insn->u2.insn_uid == 2456 && i == 3)
	  asm("int3");
	if (! find_reg (chain, i))

とすればやりやすいかも.


  for (k = 0; k < order; k++)
    {
      int other = reload_order[k];

      if (rld[other].regno >= 0 && reloads_conflict (other, rnum))
	for (j = 0; j < rld[other].nregs; j++)
	  SET_HARD_REG_BIT (used_by_other_reload, rld[other].regno + j);
    }

このループを完了した時点で

used_by_other_reload = {7, 0}   gcc-7.1.0
used_by_other_reload = {3, 0}   gcc-6.1.0

のように違いが出ている.


  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
    {
#ifdef REG_ALLOC_ORDER
      unsigned int regno = reg_alloc_order[i];
#else
      unsigned int regno = i;
#endif

      if (! TEST_HARD_REG_BIT (not_usable, regno)
	  && ! TEST_HARD_REG_BIT (used_by_other_reload, regno)
	  && HARD_REGNO_MODE_OK (regno, rl->mode))
	{

gcc-6.1.0 では regno = 2 でここにきている. そして見つかっている. 一方,
gcc-7.1.0 では regno = 2 でこの条件が成立していない.

(gdb) p reg_alloc_order
$11 = {1, 0, 2, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 
  29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 8, 4, 
  5, 6, 7, 9, 46, 3, 10, 11, 12, 47, 13}

これは gcc-7.1.0 と gcc-6.1.0 とで変わらない.

gcc-7.1.0 で
(gdb) p TEST_HARD_REG_BIT (not_usable, 2)
$12 = false
(gdb) p TEST_HARD_REG_BIT (used_by_other_reload, 2)
$13 = true

なのでやはり used_by_other_reload[0] = 7 であることが find_reg で 2 が見つからない
原因である.
ということは used_by_other_reload[0] のビット 2 をセットしている理由を調べてみる.
話が逸れるが

1 HARD_D_REGNUM
0 HARD_X_REGNUM
2 HARD_Y_REGNUM

なので, find_reg で HARD_Y_REGNUM が条件を満たさないとたいていエラーになるように思える.
しかしこれはあくまでも推測.

話をもとに戻すと

      if (rld[other].regno >= 0 && reloads_conflict (other, rnum))

この条件が
gcc-7.1.0 では other = 0, rnum = 2 で成立するから used_by_other_reload[0] が 7
になっている.
gcc-6.1.0 では other = 0, runm = 2 で成立しないから 3 のまま.

いずれの場合も
(gdb) p rld[other].regno
$4778 = 2

である.

(gdb) p reloads_conflict (0, 2)


static int
reloads_conflict (int r1, int r2)
{
...
  enum reload_type r2_type = rld[r2].when_needed;
...
  if (r2_type == RELOAD_OTHER)
    return 1;                      gcc-7.1.0 ではここで 1 が返っている.

gcc-6.1.0 では r2_type は RELOAD_FOR_INPUT なので少なくともここで 1 が返ること
はない.

rld[2].when_needed

に違いが出ているということ. だとすればここに値をセットするタイミングを捉えるべき.

	if (chain->insn->u2.insn_uid == 2456 && i == 3)
	  asm("int3");
	if (! find_reg (chain, i))

ここで停止した時点では既に rld[2].when_needed には値がセットされている. そして
そのままこれまでの調査のとおり gcc-7.1.0 ではエラーする.

rld[2].when_need のアドレスをウォッチすることで

gcc-6.1.0 では
0 -> 9 -> 0 -> 9 -> 0
のように変化してそして上のブレークポイントに到達している.

gcc-7.1.0 では
0 -> 9 -> 0 -> 9 -> 0 -> 9 -> 0 -> 9 -> 0 -> 9
のように変化してそして上のブレークポイントに到達している.

さてこれはどう見るべきなのか...

この調査とは別に「gcc ターゲット依存部」で .md ファイルの書式について調査してみたところ
gcc のどのバージョンかは不明だが仕様が大幅に変更されて下位互換ではなくなっていることに気付
いた.

例えば i386.md のかなり初期のバージョンでは 

(define_insn "cmpsi"
  [(set (cc0)
	(compare (match_operand:SI 0 "general_operand" "mr,ri")
		 (match_operand:SI 1 "general_operand" "ri,mr")))]
  ""
...

(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "je %l0")

のように条件分岐を実現していたが, この方法は gcc-10.2.0 では少なくとも動作しないようである.
この .md ファイルの仕様変更が今回のバグの直接的な原因かは不明だが, 可能性は 0 ではない.
ちなみに m68hc11.md での上の部分は

(define_expand "cbranchsi4"
  [(set (cc0)
	(compare (match_operand:SI 1 "tst_operand" "")
		 (match_operand:SI 2 "cmp_operand" "")))
   (set (pc)
	(if_then_else (match_operator 0 "ordered_comparison_operator"
		       [(cc0) (const_int 0)])
		      (label_ref (match_operand 3 "" ""))
		      (pc)))]
  ""
...

のように新仕様に合っているっぽいのでここは問題なさそう.

