float f(int a)
{
  return a;
}

を実装中. オリジナルの cc1 では

	ldd	3,y
	ldx	1,y
	bsr	__floatsisf

のようなコードを生成しているがソースファイルで明示的にこのようにしているところはなかった.
そこで

; float <- int32, uint32
(define_insn "floatsisf2"
  [(set (match_operand:SF 0 "nonimmediate_operand" "")
        (float:SF (match_operand:SI 1 "general_operand" "")))]
  ""
  "%0 := (float)%1")

を削除してみた. しかし内部ライブラリ函数を呼び出すようなコードが生成されることはなく

変わりに

[fp+5]_{DI} := (sign)[fp+1]

d := (float)[fp+5]

のようなコードが生成されるだけであった.

できているオリジナルの cc1 はどうやっているのか調べてみた:

Breakpoint 1, final (first=0xb7c52120, file=0x8431330, optimize=0, prescan=0) at final.c:1572
$29 = (rtx) 0xb7bcbf80
(call_insn/u 12 47 18 (set (reg:SF 0 x)
        (call (mem:QI (symbol_ref:HI ("__floatsisf")) [0 S1 A8])
            (const_int 0 [0x0]))) 182 {call_value} (nil)
    (expr_list:REG_EH_REGION (const_int -1 [0xffffffff])
        (nil))
    (expr_list (use (reg:SI 0 x [ a ]))
        (nil)))
$30 = void

この rtx が生成されたときのスタックは以下:

(gdb) where
#0  rtx_alloc (code=CALL_INSN) at rtl.c:187
#1  0x080e8f9a in make_call_insn_raw (pattern=0xb7bc7300) at emit-rtl.c:3517
#2  emit_call_insn (x=0xb7bc7300) at emit-rtl.c:4765
#3  emit_call_insn (x=0xb7bc7300) at emit-rtl.c:4743
#4  0x080a58c3 in emit_call_1 (funexp=funexp@entry=0xb7c12e70, rounded_stack_size=rounded_stack_size@entry=0, struct_value_size=struct_value_size@entry=0, valreg=0xb7bc92a0, old_inhibit_defer_pop=1, call_fusage=0xb7bc72dc, ecf_flags=17, args_so_far=0xbfffe9d8, next_arg_reg=<optimized out>, stack_size=<optimized out>, funtype=<optimized out>, fndecl=<optimized out>) at calls.c:471
#5  0x080a659a in emit_library_call_value_1 (retval=retval@entry=1, orgfun=orgfun@entry=0xb7c12e70, value=value@entry=0x0, fn_type=<optimized out>, outmode=<optimized out>, nargs=<optimized out>, p=<optimized out>) at calls.c:4265
#6  0x080a6c56 in emit_library_call_value (orgfun=0xb7c12e70, value=0x0, fn_type=LCT_CONST, outmode=SFmode, nargs=1) at calls.c:4451
#7  0x081849b7 in expand_float (to=0xb7bc9250, from=0xb7bc7294, unsignedp=0) at optabs.c:4662
--Type <RET> for more, q to quit, c to continue without paging--c
#8  0x080fd9da in expand_expr_real (exp=0xb7c11d5c, target=0xb7bc9250, tmode=SFmode, modifier=EXPAND_NORMAL, alt_rtl=0x0) at expr.c:8048
#9  0x081dd5de in expand_return (retval=0xb7c5a2b8) at stmt.c:3258
#10 0x080812b8 in genrtl_return_stmt (stmt=0xb7c11d70) at c-semantics.c:523
#11 expand_stmt (t=0xb7c11d70) at c-semantics.c:794
#12 0x0808132b in genrtl_compound_stmt (t=0xb7c11d0c) at c-semantics.c:719
#13 expand_stmt (t=0xb7c11d0c) at c-semantics.c:826
#14 0x08213dca in tree_rest_of_compilation (fndecl=0xb7bcad80, nested_p=false) at tree-optimize.c:144
#15 0x08055ada in c_expand_body_1 (fndecl=0xb7bcad80, nested_p=<optimized out>) at c-decl.c:6174
#16 0x082157ff in cgraph_expand_function (node=<optimized out>) at cgraphunit.c:538
#17 0x08215b99 in cgraph_assemble_pending_functions () at cgraphunit.c:144
#18 cgraph_assemble_pending_functions () at cgraphunit.c:130
#19 cgraph_finalize_function (decl=0xb7bcad80, nested=false) at cgraphunit.c:225
#20 0x0805efc7 in finish_function () at c-decl.c:6131
#21 0x0804dbe7 in yyparse () at c-parse.y:385
#22 0x0804f668 in c_parse_file () at c-parse.y:3029
#23 0x0807cdc6 in c_common_parse_file (set_yydebug=0) at c-opts.c:1249
#24 0x081e9c4b in compile_file () at ./toplev.c:1822
#25 do_compile () at ./toplev.c:4656
#26 toplev_main (argc=2, argv=0xbffff624) at ./toplev.c:4696
#27 0x0804a8cb in main (argc=2, argv=0xbffff624) at main.c:35
(gdb) 

expand_float が呼び出され emit_library_call_value が呼び出されている.

自前の cc1 で試してみたところ expand_float は呼び出されているものの
emit_library_call_value が呼び出される前に expand_float から戻っている.

void
expand_float (rtx to, rtx from, int unsignedp)
{

	icode = can_float_p (fmode, imode, unsignedp);
	if (icode == CODE_FOR_nothing && unsignedp)

icode が CODE_FOR_nothing になればオリジナルの cc1 と同じ動作だが
icode が CODE_FOR_floatdisf2 に自前の cc1 はなるので expand_float から戻っている.

以下を削除することにした:

; float <- int8, uint8  or float <- int16, uint16
; not absolutely necessary
; If not, compiler generates like below:
;
; t := (sign)y  or (zero)y
; x := (float)t 

; float <- int64, uint64
(define_insn "floatdisf2"
  [(set (match_operand:SF 0 "nonimmediate_operand" "")
        (float:SF (match_operand:DI 1 "general_operand" "")))]
  ""
  "%0 := (float)%1")

この修正により期待する __floatsisf の呼び出しのコードが生成されている.

2022.03.01 17:45 現状 

#include <stdio.h>

float f(int a)
{
  return a;
}

int main()
{
  printf("hello world %f\n", f(5));
  return 0;
}

に対して f のコードはできているが f を呼び出した後のコードが以下のように
なっている:

	bsr	f
	(mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8]) := (double)d
	(mem:DF (pre_dec:HI (reg/f:HI 3 sp)) [2  S8 A8]) := (mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8])
	ldd	#.LC0
	bsr	printf

分かりずらいが

	[*_.frame+1] := (double)d
	push [*_.frame+1]

がまだできていない.
おそらく double <- float もランタイムライブラリを使用するはずなので, まずはそれを確認する.
オリジナルの cc1 では __extendsfdf2 を呼び出していることを確認した.

m68hc11.md から以下を削除

; double <- float
(define_insn "extendsfdf2"
  [(set (match_operand:DF 0 "nonimmediate_operand" "")
        (float_extend:DF (match_operand:SF 1 "general_operand" "")))]
  ""
  "%0 := (double)%1")

2022.03.02 11:10 確認したところ以下のようになっている:

	bsr	f
	x := d
	bsr	__extendsfdf2
	(mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8]) := d
	(mem:DF (pre_dec:HI (reg/f:HI 3 sp)) [2  S8 A8]) := (mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8])
	ldd	#.LC0
	bsr	printf


とここで以下に気付く.

rtx m68hc11_function_incoming_arg(cumulative_args_t pcum_v,
				  const function_arg_info& arg)
{
  auto use_reg = reinterpret_cast<CUMULATIVE_ARGS*>(pcum_v.p);
  auto mode = arg.mode;
  auto size = GET_MODE_SIZE(mode);
  if (size > 4)
    return nullptr;
  
  if (size == 4) {
    if (!*use_reg)
      return gen_rtx_REG(mode, X_REGNUM);  // X_REGNUM のままだった.
    return nullptr;
  }

  assert(size <= 2);

一旦 float <- int の変換はそのままにしてこっちを修正することにする.
上を D_REGNUM に修正したところいきなりレベルダウンしている.
ここはじっくり修正することにした.

const char* m68hc11_movsi(rtx x, rtx y)
{
...
  if (REG_P(x) && REGNO(x) == X_REGNUM && CONST_INT_P(y)) {
                              ^^^^^^^^
これを D_REGNUM に修正

  if (fp_rel(x, &offset) && REG_P(y) && REGNO(y) == X_REGNUM) {

これを D_REGNUM に修正

また 14th.jp でできていなかった

const char* m68hc11_movsi(rtx x, rtx y)
{
#if 0  
  if (x2d(x, y) || d2x(x, y))
    return "";
#endif  

を試してみた. この修正でレベルダウンしていないことを確認した.

再び float <- int に戻る. 現状

	bsr	f
	bsr	__extendsfdf2
	(mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8]) := d
	(mem:DF (pre_dec:HI (reg/f:HI 3 sp)) [2  S8 A8]) := (mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [3 %sfp+1 S8 A8])
	ldd	#.LC0

のようになっているので以下のように変更:

bool m68hc11_return_in_memory (const_tree type, const_tree fntype)
{
  (void)fntype;
  auto mode = TYPE_MODE(type);
  return mode == BLKmode || mode == DImode || mode == DFmode;
}

この結果以下のようになっている:

	bsr	__extendsfdf2
	(mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 9 [0x9])) [3 %sfp+9 S8 A8]) := (mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 1 [0x1])) [2  S8 A8])
	(mem:DF (pre_dec:HI (reg/f:HI 3 sp)) [2  S8 A8]) := (mem/c:DF (plus:HI (reg/f:HI 9 *_.frame)
        (const_int 9 [0x9])) [3 %sfp+9 S8 A8])
	ldd	#.LC0
	bsr	printf


分かりずらいが

	[*_.frame+9] := [*_.frame+1]
	push [*_.frame+9]

のような rtx_insn が生成されている.

現状 printf を呼び出す直前で

(m68hc11-elf-gdb) info register
PC=0x10f4  SP=0xfee3  FP=0xfeeb 
CCR=0x00   --------   u> != >= > 
D=0x2212 8722 X=0xc199 -15975 Y=0x9999 -26215
D1=0xcccc -13108 D2=0xcccc -13108 D3=0xcccc -13108 D4=0xcccc -13108 
(m68hc11-elf-gdb) p (char*)0x2212
$2 = 0x2212 "hello world %f\n"
(m68hc11-elf-gdb) x/9bx $sp
0xfee3:	0x00	0xc1	0x99	0x99	0x99	0x80	0x00	0x00
0xfeeb:	0x00
(m68hc11-elf-gdb) p *(double*)($sp+1)
$4 = -107374176
(m68hc11-elf-gdb) 

のようになっている. 5.0 積めていない.

(m68hc11-elf-gdb) x/8bx 0xfeeb+1 
0xfeec:	0xc1	0x99	0x99	0x99	0x80	0x00	0x00	0x00
(m68hc11-elf-gdb) 

だからランタイムライブラリ函数 __extendsfdf2 の結果が正しくない.

__extendsfdf2 を呼び出す直前を調べるべき.

	      bsr	__extendsfdf2

を呼び出すとき d レジスタに結果を格納するアドレスをセットしているが 5.0F をセットしていない.
ランタイムライブラリ函数を呼び出すときに d レジスタを結果を格納するアドレスとして
使用するのだから引数に対しては以下で

void m68hc11_function_arg_advance(cumulative_args_t pcum_v,
				  const function_arg_info &arg)
{
  if (size == 4) {
    if (!*use_reg)
      *use_reg = true;  間違い
    return;
  }


void INIT_CUMULATIVE_ARGS(CUMULATIVE_ARGS& use_reg, tree fntype, rtx libfun,
			  tree fndecl, int)
{
をライブラリ函数に対応させた.
現状

	bsr	f
	(mem:SF (pre_dec:HI (reg/f:HI 3 sp)) [0  S4 A8]) := d
	ldd	*_.frame
	addd	#1
	bsr	__extendsfdf2

のようなコードが生成されている.
2022.3.02 16:11 cc.c がパスしている. レベルダウンもなし.
