f の先頭アドレスでは

x = 0x1122, d = 0x3344

         +------------+ 0xff4
	 |            | <- sp  
	 +------------+ 0xff6
	 |   0x1060   |
	 +------------+ 0xff8
	 |   0x5566   |
	 +------------+ 0xffa
	 |   0x7788   |
	 +------------+ 0xffc


のようになっている. ここで 0x1060 は main 函数から f を呼び出した命令の
次のアドレスである:

    105d:	bd 10 6f    	jsr	0x106f <f>
    1060:	18 38       	puly

先頭の
	ldy	*_.frame
	pshy

では *_.frame をスタックにプッシュしている. _.frame はこのテストでは 0x10 番地
配置されていて 0x0ffb である. これは main 函数での _.frame の値. この 2 命令で

         +------------+ 0xff2
	 |            | <- sp
         +------------+ 0xff4
	 |   0x0ffb   |
	 +------------+ 0xff6
	 |   0x1060   |
	 +------------+ 0xff8
	 |   0x5566   |
	 +------------+ 0xffa
	 |   0x7788   |
	 +------------+ 0xffc

続く

	pshx
	pshx

で引数 a をスタックに保存する領域を確保している. たまたま x には 0x1122 が入っているが
この値はこの段階では関係がない.

         +------------+ 0xfee
	 |            | <- sp
         +------------+ 0xff0
	 |   ******   |
         +------------+ 0xff2
	 |   ******   |
         +------------+ 0xff4
	 |   0x0ffb   |
	 +------------+ 0xff6
	 |   0x1060   |
	 +------------+ 0xff8
	 |   0x5566   |
	 +------------+ 0xffa
	 |   0x7788   |
	 +------------+ 0xffc

続く

	sts	*_.frame

で *_.frame は 0xfef に更新される.
続く

	ldy	*_.frame
	std	3,y
	stx	1,y

で y に *_.frame の値がロードされ 0xff2 に d が, 0xff0 に x がストアされる.
つまり

         +------------+ 0xfee
	 |            | <- sp
         +------------+ 0xff0
	 |   0x1122   |
         +------------+ 0xff2
	 |   0x3344   |
         +------------+ 0xff4
	 |   0x0ffb   |
	 +------------+ 0xff6
	 |   0x1060   |
	 +------------+ 0xff8
	 |   0x5566   |
	 +------------+ 0xffa
	 |   0x7788   |
	 +------------+ 0xffc

のようになる. この段階で a は *_.frame + 1 に配置されていて,
b は *_.frame + 9 に配置されている.

続く

	ldy	*_.frame
	ldd	3,y
	ldx	1,y

で a の値を x, d レジスタにロードしている.

続く

	addd	11,y

で b の下位 16 ビットと a の下位 16 ビットとを加算している.
この結果 d は 0xaacc になる.

続く

	xgdx

で x と d とをスワップしている. この結果 x = 0xaacc, d = 0x1122
になる.

続く

	adcb	10,y

でキャリービット込みで a の上位 16 ビットの下位 8 ビットと b の対応する
8 ビットとの加算をしている. b レジスタは d レジスタの下位 8 ビット.
この結果 d = 0x1188 になる.

続く

	adca	9,y

でキャリービット込みで a の上位 16 ビットの上位 8 ビットと b の対応する
8 ビットとの加算をしている. a レジスタは d レジスタの上位 8 ビット.
この結果 d = 0x6688 になる.

続く

	xgdx

で x と d とをスワップしている. この結果 x = 0xaacc, d = 0x6688
になる.

続く

	puly
	puly

は 2 つの pshx に対応している.

続く

	puly
	sty	*_.frame

で *_.frame を f が呼び出される前の値に復元している.

