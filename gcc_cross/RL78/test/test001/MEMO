メモリを断片で確保するようにしてからアクセスエラーで引っかかっている.

_rl78_init の行番号情報がないが, crt0.S と同じファイルに函数の定義がある.


以下の函数の呼び出しの前後で fp の値が

  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);

0xff0e6 から 0xfcccc になってしまう. そしてこの後数行実行し 0xf0409
になり

     fp->_flags |= __SMBF;

を実行したとき 0xf0409 にアクセスしてエラーしている.

これの原因の回避策として以下の函数の引数の宣言で register FILE  *fp を
単に FILE* fp のように宣言すればよい.


int
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
  ...
}

__sfvwrite_r (struct _reent *ptr,
       register FILE *fp,
       register struct __suio *uio)
{
  ...
}

原因は調査中だがおそらく rl78-elf-gccc のバグでおそらく -O0 のときに再現すると予測される.

同様のバグはローカル変数に対してもある.

__sflush_r (struct _reent *ptr,
       register FILE * fp)
{
  register unsigned char *p;            // この register があるせいで正しく動作しない.
  register _READ_WRITE_BUFSIZE_TYPE n;  // この register があるせいで正しく動作しない.
  register _READ_WRITE_RETURN_TYPE t;   // この register があるせいで正しく動作しない.


現状このテストを pass させるためには

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.rl78-elf.new/sim/common/sim-load.c

の以下の部分が #if 1 にする必要がある.

#ifdef NEW_MEM_MAP
	      if (s->flags & SEC_DATA) {
		if (s->flags & SEC_READONLY) {
#if 0
		  // below is necessary for passing
		  // ~/lang/53_GNU_tool/gcc_cross/RL78/test/test001/
		  lma |= 0xf0000;
		  // But if above is add,
		  // ~/lang/53_GNU_tool/gcc_cross/RL78/tool/sample.elf
		  // will not work
#endif		  
		  sim_do_commandf(sd, "memory-region 0x%lx,0x%lx", lma, size);

さてどうしたものか.
