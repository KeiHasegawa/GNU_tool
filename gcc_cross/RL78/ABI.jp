RL78 の ABI

(*0) アドレス空間とメモリマップドレジスタ
(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long, long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*0) アドレス空間とメモリマップドレジスタ

     [0, 0x100000) の 1 MByte

         0x0ffff8 から 2 バイトは sp レジスタにマップされている.
	 0x0ffffa の 1 バイトは psw レジスタにマップされている.
	 0x0ffffc の 1 バイトは cs レジスタにマップされている.
	 0x0ffffd の 1 バイトは es レジスタにマップされている.
         0x0ffffe の 1 バイトは pmc レジスタにマップされている.

         0x0ffef8 の 1 バイトは x レジスタにマップされている.
         0x0ffef9 の 1 バイトは a レジスタにマップされている.
         0x0ffefa の 1 バイトは c レジスタにマップされている.
         0x0ffefb の 1 バイトは b レジスタにマップされている.
         0x0ffefc の 1 バイトは e レジスタにマップされている.
         0x0ffefd の 1 バイトは d レジスタにマップされている.
         0x0ffefe の 1 バイトは l レジスタにマップされている.
         0x0ffeff の 1 バイトは h レジスタにマップされている.

         これらのメモリマップドレジスタは各命令でオペランドとして指定される.
	 
	 これとは別にコンパイラの実装の都合で
         r8, ..., r31 を
	 0x0ffee0 から 0x0ffef7 として使用している. それぞれは順番に並んでいる
	 わけではない.
	 
(*1) 函数呼び出し

	call	!!func

	疑似コード

	sp -= 4
	memory[sp|0xf0000] = (call 命令の次のアドレス);
	pc = func

	但し 0xf0000 - 0xf1000 の領域はアクセスできないので, sp が 0x1000 以下
	だと期待通り動作しない.
	
	同様に sp が 0x8000 より大きいと 0xf8000 の領域をシミュレータがアクセス制限
	をかけているようで期待通り動作しない. というよりシミュレータのバグもしれない.

(*2) 函数復帰

	ret

	疑似コード

	pc = memory[sp|0xf0000]
	sp += 4

(*3) プロローグ

	subw	sp, #128

	上は 128 バイトの領域を使用する函数のプロローグ.


(*4) エピローグ

	addw	sp, #128
	ret

	上は 128 バイトの領域を使用する函数のエピローグ.
	sp を復元し, 呼び出し元に復帰する.

(*5) 通常の函数の引数と戻り値

        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 2
	...

	のようにスタックを使用する.
	函数の戻り値は x レジスタに値がセットされる.

(*6) long, long long を引数にとる函数, 返す函数

	sizeof(long) = 4
	sizeof(long long) = 8

	long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 4
	...

	のようにスタックを使用する.
	函数の戻り値は 2 バイトずつ r12, r14 を使用する. r12, r14 はメモリマップドレジス
	タでそれぞれのアドレスは以下:

	r12	=	0xffef4
	r14	=	0xffef6

	long long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 8
	...

	のようにスタックを使用する.
	函数の戻り値は 4 バイトずつ r8, r12 レジスタにセットされる. やはりメモリマップドレジ
	スタでそれぞれのアドレスは以下:

	r8	=	0xffef0
	r12	=	0xffef4

	別の言い方をすれば r8, r10, r12, r14 を 2 バイトずつ使用するとも言える.

(*7) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = sizeof(double) = 4
	sizeof(long double) = 8

	RL78 には FPU がないので浮動少数点演算はソフトウェアで行なう.

	float, double に対しては (*5) の規則が適用される.
	long double に対しては (*6) の規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すときスタックに構造体がコピーされて呼び出される.
	構造体を返す函数を呼び出すと結果がアドレス 0xffef0 にセットされる. このアドレス
	はメモリマップドレジスタ r8 のアドレスである.
