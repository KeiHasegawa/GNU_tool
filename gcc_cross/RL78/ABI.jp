RL78 の ABI

(*1) アドレス空間
(*2) メモリマップドレジスタと SFR
(*3) 函数呼び出し
(*4) 函数復帰
(*5) プロローグ
(*6) エピローグ
(*7) 通常の函数の引数と戻り値
(*8) long, long long を引数にとる函数, 返す函数
(*9) 浮動少数点数を引数にとる函数, 返す函数
(*10) 構造体を引数にとる函数, 構造体を返す函数

(*1) アドレス空間

     REN_r01us0015jj0220_rl78_LBR_20141120.pdf
     2.1 メモリ空間を参照

     [0, 0x100000) の 1 MByte

     +------------------+ 0x000000
     |                  |
     ~    code flash    ~
     |                  |
     +------------------+ 0x010000 (システム依存)
     |                  |
     ~      hole        ~
     |                  |
     +------------------+ 0x0f0000
     |                  |
     ~      2nd SFR     ~
     |                  |
     +------------------+ 0x0f0800
     |                  |
     ~      hole        ~
     |                  |
     +------------------+ 0x0f1000
     |                  |
     ~    data flash    ~
     |                  |
     +------------------+ 0x0f8000 (システム依存)
     |                  |
     ~      mirror      ~
     |                  |
     +------------------+ 0x0fef00 (システム依存)
     |                  |
     ~       RAM        ~
     |                  |
     +------------------+ 0x0ffee0
     ~   Memory mapped  ~
     |      register    |
     +------------------+ 0x0fff00
     |                  |
     ~       SFR        ~
     |                  |
     +------------------+ 0x100000

     mirror の部分
     [0xf8000, 0xfef00) をロードするのに
     [0x00000, 0x06f00) を代わりにロードしてもよい.

-----------------------------------------------------------------------
     RL78 のシミュレータは [0x0f0000, 0x100000) を mirror としているら
     しい.
     
     [0x0f0000, 0x100000) をロードするのに
     [0x000000, 0x010000) を代わりにロードしてもよい.
     
     例えば 0xe789 番地は 0xfe789 番地にミラーされているので, 以下の 2 命令で

	mov	es, #0xf
	mov	a, es:!0xe789

     アドレス 0xfe789 から 1 バイトロードするが, 以下の 1 命令で 

	mov	a, !0xe789

     アドレス 0xe789 から 1 バイトロードしても同じ結果になる. es レジ
     スタを使用して高いアドレスにアクセスすることができるが, mirror の
     領域であれば 1 命令でアクセスできる.
-----------------------------------------------------------------------

(*2) メモリマップドレジスタと SFR (Special Function Register)

         0x0ffef8 の 1 バイトは x レジスタにマップされている.
         0x0ffef9 の 1 バイトは a レジスタにマップされている.
         0x0ffefa の 1 バイトは c レジスタにマップされている.
         0x0ffefb の 1 バイトは b レジスタにマップされている.
         0x0ffefc の 1 バイトは e レジスタにマップされている.
         0x0ffefd の 1 バイトは d レジスタにマップされている.
         0x0ffefe の 1 バイトは l レジスタにマップされている.
         0x0ffeff の 1 バイトは h レジスタにマップされている.

         これらのメモリマップドレジスタは各命令でオペランドとして指定される.
	 (上は RL78-S1 コアに限った話で RL78-S2 コア, RL78-S3 コアなら
	 ばバンクがある)

	 これとは別にコンパイラの実装の都合で
         r8, ..., r31 を
	 0x0ffee0 から 0x0ffef7 として使用している. それぞれは順番に並んでいる
	 わけではない.

         0x0ffff8 から 2 バイトは sp レジスタにマップされている.
	 0x0ffffa の 1 バイトは psw レジスタにマップされている.
	 0x0ffffc の 1 バイトは cs レジスタにマップされている.
	 0x0ffffd の 1 バイトは es レジスタにマップされている.
         0x0ffffe の 1 バイトは pmc レジスタにマップされている.
	 
(*3) 函数呼び出し

	call	!!func

	疑似コード

	sp -= 4
	memory[sp|0xf0000] = (call 命令の次のアドレス);
	pc = func

	但し 0xf0000 - 0xf1000 の領域は特殊機能レジスタ(と使用不可)領
	域なので, sp が 0x1000 以下だと期待通り動作しない.
	
	同様に sp が 0x8000 より大きいと 0xf8000 の領域はミラー領域なので
	期待通り動作しない. シミュレータがアクセス制限をかけている.

(*4) 函数復帰

	ret

	疑似コード

	pc = memory[sp|0xf0000]
	sp += 4

(*5) プロローグ

	subw	sp, #128

	上は 128 バイトの領域を使用する函数のプロローグ.


(*6) エピローグ

	addw	sp, #128
	ret

	上は 128 バイトの領域を使用する函数のエピローグ.
	sp を復元し, 呼び出し元に復帰する.

(*7) 通常の函数の引数と戻り値

        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 2
	...

	のようにスタックを使用する.
	函数の戻り値は x レジスタに値がセットされる.

(*8) long, long long を引数にとる函数, 返す函数

	sizeof(long) = 4
	sizeof(long long) = 8

	long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 4
	...

	のようにスタックを使用する.
	函数の戻り値は 2 バイトずつ r12, r14 を使用する. r12, r14 はメモリマップドレジス
	タでそれぞれのアドレスは以下:

	r12	=	0xffef4
	r14	=	0xffef6

	long long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 8
	...

	のようにスタックを使用する.
	函数の戻り値は 4 バイトずつ r8, r12 レジスタにセットされる. やはりメモリマップドレジ
	スタでそれぞれのアドレスは以下:

	r8	=	0xffef0
	r12	=	0xffef4

	別の言い方をすれば r8, r10, r12, r14 を 2 バイトずつ使用するとも言える.

(*9) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = sizeof(double) = 4
	sizeof(long double) = 8

	RL78 には FPU がないので浮動少数点演算はソフトウェアで行なう.

	float, double に対しては (*6) の規則が適用される.
	long double に対しては (*8) の規則が適用される.

(*10) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すときスタックに構造体がコピーされて呼び出される.
	構造体を返す函数を呼び出すと結果がアドレス 0xffef0 にセットされる. このアドレス
	はメモリマップドレジスタ r8 のアドレスである.
