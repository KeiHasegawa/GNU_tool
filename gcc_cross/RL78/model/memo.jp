cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

以下開発メモ

(*1)
MSP430 のようにフレームポインタが RL78 にはないから

#define STACK_POINTER_REGNUM 32
#define FRAME_POINTER_REGNUM 32

のようにすると

	e := sp + 4
	e := [e] + [e+2]

のようなコードが生成される.

      [sp+??] := [sp+4] + [sp+6]

のようなコードが生成されて欲しいから試しに

constexpr int STACK_POINTER_REGNUM  = 32;
#define       FRAME_POINTER_REGNUM    33

のように分けてみたところ

	l := [fp+4] + [fp+6]
	x := l

のようになった.
また,

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "fp",  "dummy0",  "dummy1", "dummy2"			\
  }
#define FIXED_REGISTERS						\
  {								\
      0,     0,     0,     0,     0,     0,     1,     1, 	\

のように l と h をアロケーションの対象から除いたところ

  [fp] := [fp+4] + [fp+6]

のようになっている.


一旦 
constexpr int STACK_POINTER_REGNUM  = 32;
#define       FRAME_POINTER_REGNUM    32

のように元に戻した.
オリジナルの cc1 は

int f(int a, int b)
{
  return a + b;
}

に対して以下のような rtx_insn を出している.

 <materialize-all-clones> {heap 820k} f$1 = (rtx_insn *) 0xb78fb9a0
    1: NOTE_INSN_DELETED
$2 = void
$3 = (rtx_insn *) 0xb78fba20
    3: NOTE_INSN_BASIC_BLOCK 2
$4 = void
$5 = (rtx_insn *) 0xb78fbb40
   21: NOTE_INSN_PROLOGUE_END
$6 = void
$7 = (rtx_insn *) 0xb78fba00
    2: NOTE_INSN_FUNCTION_BEG
$8 = void
$9 = (rtx_insn *) 0xb78774a4
   19: x:HI=[sp:HI+0x6]
$10 = void
$11 = (rtx_insn *) 0xb78774c8
   20: l:HI=x:HI
      REG_DEAD x:HI
$12 = void
$13 = (rtx_insn *) 0xb7877480
   18: x:HI=[sp:HI+0x4]
$14 = void
$15 = (rtx_insn *) 0xb7877360
    5: x:HI=x:HI+l:HI
      REG_DEAD x:HI
$16 = void
$17 = (rtx_insn *) 0xb787745c
   17: r8:HI=x:HI
$18 = void
$19 = (rtx_insn *) 0xb7877414
   13: use r8:HI
$20 = void
$21 = (rtx_insn *) 0xb78fbb60
   22: NOTE_INSN_EPILOGUE_BEG
$22 = void
$23 = (rtx_insn *) 0xb78d5168
   23: return
$24 = void
$25 = (rtx_insn *) 0xb78774ec
   24: barrier
$26 = void
$27 = (rtx_insn *) 0xb78fbae0

これは現状自前の cc1 とはだいぶ異なっている. おそらく何かしかけがあるらしい.

以下をまず生成していることを確認した.

(gdb) p debug_insn_slim((rtx_insn*)$34)
    5: r43:HI=[r37:HI]+[r37:HI+0x2]

(gdb) p debug_rtx((rtx_insn*)$34)
(insn 5 0 0 (set (reg:HI 43 [ _3 ])
        (plus:HI (mem/c:HI (reg/f:HI 37 virtual-incoming-args) [1 a+0 S2 A16])
            (mem/c:HI (plus:HI (reg/f:HI 37 virtual-incoming-args)
                    (const_int 2 [0x2])) [1 b+0 S2 A16]))) "b.c":3:12 -1
     (nil))
$38 = void
(gdb) 


static rtx
expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,
		       rtx op0, rtx op1,
		       rtx target, int unsignedp, enum optab_methods methods,
		       rtx_insn *last)
{
...
  create_output_operand (&ops[0], target, tmp_mode);
  create_input_operand (&ops[1], xop0, mode0);
  create_input_operand (&ops[2], xop1, mode1);
  pat = maybe_gen_insn (icode, 3, ops); ここ
  
おそらく

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

constexpr int STACK_POINTER_REGNUM  = 32;
#define       FRAME_POINTER_REGNUM    32
#define       ARG_POINTER_REGNUM      33

#define ELIMINABLE_REGS { {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM} }

これがポイントらしい.

現状 hello world をコンパイルすると

_main:
	subw	sp, #2
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	movw	de, #0              これ
	movw	r8, de              これ 
	addw	sp, #2
	ret

のように de が選択される. ここは ax が選択される必要がある. 試しに

#define FIXED_REGISTERS						\
  {								\
      0,     0,     1,     1,     1,     1,     1,     1, 	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,       1,         1			\
  }

のようにしてみる. 2022.02.17 6:50 リビルド開始.

2022.02.17 7:47 確認してみたところ以下のようになった.

_main:
	subw	sp, #4
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	[sp+0] := 0
	[sp+0] := [sp+0]
	r8 := [sp+0]
	addw	sp, #4
	ret

これはこれで期待しない結果. 一旦元に戻した.
後で読み返して気付いたが最終的になぜ今の形になったかが不明. しかし以下の rtx_insn を
生成できている:

    5: e:HI=[sp:HI+0x4]+[sp:HI+0x6]

   12: r8:HI=e:HI

(*2)
現状 hello world 11 ができている.

-g オプション付きでコンパイルした hello world 11 を rl78-elf-gdb で実行すると
現状以下のようになる.

Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
5	  return a + b;
#0  f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
#1  0x00000198 in main () at a.c:10
0x00000198 in main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
Value returned is $1 = 11
hello world 11

現段階では

  RTX_FRAME_RELATED_P(insn) = true;

のような rtx_insn は生成していない.

上は分かりずらいが, f の引数 a と b を正しく表示できていないこと以外は実はできている.
つまり where も finish もできている.

.debug_info は

 <2><bd>: 省略番号: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 21 4 	(DW_OP_bregx: 33 (r33) 4)
 <2><cb>: 省略番号: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 21 6 	(DW_OP_bregx: 33 (r33) 6

のようになっている. つまりこれがエラーメッセージにも表われている 33 番のレジスタということ.

現状

constexpr int STACK_POINTER_REGNUM  = 32;
#define       FRAME_POINTER_REGNUM    32
#define       ARG_POINTER_REGNUM      33

のようにしている. この 33 が 32 になればおそらく期待通り動くと思ったが, それは
ローカル変数や中間変数が f にない場合でしか成立しない.

オリジナルの cc1 では以下のようになっている.

<2><c9>: 省略番号: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><d6>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 2 	(DW_OP_fbreg: 2)

オリジナルの cc1 では以下のように定義

#define FRAME_POINTER_REGNUM 		22
#define STACK_POINTER_REGNUM 	        32
#define ARG_POINTER_REGNUM 		33

あまりこれを参考にしないで, 独自路線でいくことにした.
現状

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000008 00000000 FDE cie=00000000 pc=000b017d..000b0185

0000001e 00000008 00000000 FDE cie=00000000 pc=00000000..00000000

のように 32 番がスタックポインタであるという情報しかなくて, 33 番のレジスタが
どのようになっているかが表現されていない.

と思ったが

オリジナルの cc1 は以下
00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4   これ
  DW_CFA_nop
  DW_CFA_nop

00000014 0000000c 00000000 FDE cie=00000000 pc=0000017d..00000186

しかしオリジナルの cc1 ではフレームポインタを一応形だけもっているからこうすることで
おそらくうまくいっている.

以下のようにしてみた:

void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_MINUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, 4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

これで

during RTL pass: dwarf2
a.c: In function ‘f’:
a.c:6:1: internal compiler error: in dwarf2out_frame_debug_expr, at dwarf2cfi.c:1758
    6 | }
      | ^
0x85dd00d dwarf2out_frame_debug_expr
	../.././gcc/dwarf2cfi.c:1758
0x85de105 dwarf2out_frame_debug

内部エラーが発生している. どうやら ap := sp - 4 をデバッグ情報として組み込むのはだめらしい.

以下のようにした:
void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_PLUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, -4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

これで生成された .debug_frame は以下

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000010 00000000 FDE cie=00000000 pc=000b017d..000b0181
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

00000026 00000010 00000000 FDE cie=00000000 pc=00270188..0027018c
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

一応期待したものになっているが, 以下のように症状は変わらず.

f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5

さてどうしたものか.

.debug_info を

 <2><bd>: 省略番号: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cb>: 省略番号: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6

のように sp 相対になるように修正する.
期待値を作成した d.S はこれでできている.

この部分を生成しているところを調べてみる.

(gdb) delete
(gdb) b final_1
(gdb) run
...


          compile_file ();

ここから戻るところで問題の箇所が生成されている.

      (*debug_hooks->finish) (main_input_filename);  ここだった


  output_comp_unit (comp_unit_die (), have_macinfo,
		    dwarf_split_debug_info ? checksum : NULL); ここ
		    

  output_die (die);  ここ
  

	  output_loc_sequence (AT_loc (a), -1);  ここ

      output_loc_operands (loc, for_eh_or_skip);  ここ

上の部分で

	.uleb128 0x21  ARG_POINTER_REGNUM
	.sleb128 4     オフセット

を出している.



(gdb) p loc->dw_loc_oprnd1.v.val_addr
$47 = (rtx) 0x21
(gdb) p loc->dw_loc_oprnd2.v.val_addr
$50 = (rtx) 0x4
(gdb)

これをセットしている瞬間を捕える.

static inline dw_loc_descr_ref
new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,
	       unsigned HOST_WIDE_INT oprnd2)
{
  dw_loc_descr_ref descr = ggc_cleared_alloc<dw_loc_descr_node> ();

  descr->dw_loc_opc = op;
  descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd1.val_entry = NULL;
  descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;
  descr->dw_loc_oprnd2.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd2.val_entry = NULL;
  descr->dw_loc_oprnd2.v.val_unsigned = oprnd2;

ここだった.


  regno = DWARF_FRAME_REGNUM (regno);  ここで 33 を 32 に変換すれば良さそう

  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);
    }

  result = new_reg_loc_descr (regno, offset);  ここから呼び出している.
  
以下を追加した:

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

int rl78_dwarf_frame_regnum(int regno)
{
  if (regno == ARG_POINTER_REGNUM)
    return STACK_POINTER_REGNUM;
  assert(regno == STACK_POINTER_REGNUM);
  return regno;
}

これで hello world 11 を -g でコンパイルしたものは rl78-elf-gdb で期待した動作に
なっている.

残念ながら現状では

#include <stdio.h>

int f(int a, int b)
{
  char c[128];
  return a + b;
}

int main()
{
  printf("hello world %d\n", f(5, 6));
  return 0;
}

のように f で 128 バイトのローカル変数を宣言すると, まずは実行結果が正しくない.
f の先頭アドレスで以下のようになっている.

(rl78-elf-gdb) x/4wh $sp
0xf7ff4:	0x019c	0xcc00	0x0005	0x0006
(rl78-elf-gdb) 


0xf7ff4	+---------------+ <- sp
	|    0x019c	|
0xf7ff6	+---------------+
	|    0xcc00	|
0xf7ff8	+---------------+
	|    0x0005	|
0xf7ffa	+---------------+
	|    0x0006	|
0xf7ffc	+---------------+

これは呼び出す側ができていないように見えると思ったがこれはこれで合っていた.
0x19c は f を呼び出した call 命令の次のアドレス.



_f:
	subw	sp, #128
	movw	ax, [sp+6]
	movw	de, ax
	movw	ax, [sp+4]

単純に sp+6 や sp+4 が間違い. ap 相対のコードを以下のように修正.

inline void load(int regno, int offset)
{
  fprintf(asm_out_file, "	movw	");
  print_reg(asm_out_file, regno, HImode);
  auto sp = reg_names[STACK_POINTER_REGNUM];
  offset += get_frame_size();                          これ
  fprintf(asm_out_file, ", [%s+%d]\n", sp, offset);
}

この修正で実行結果は正しい. つまり生成しているアセンブリは正しい.

同じ修正を変数 a や b のオフセットに対しても行なってみる.

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{
  unsigned int regno;
  dw_loc_descr_ref result;
  dw_fde_ref fde = cfun->fde;

  /* We only use "frame base" when we're sure we're talking about the
     post-prologue local stack frame.  We do this by *not* running
     register elimination until this point, and recognizing the special
     argument pointer and soft frame pointer rtx's.  */
  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

これは bfin, mn10300, moxie でもやった.


bool rl78_legitimate_address_p(machine_mode mode, rtx x, bool strict)
{
  (void)mode; (void)strict;
  if (MEM_P(x))
    return false;
  return true;
}
...
#undef TARGET_LRA_P
#define TARGET_LRA_P hook_bool_void_false

gcc_target targetm = TARGET_INITIALIZER;

この修正を入れたが

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

が呼び出されない.

以下を
#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

以下のように変更した.

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy0", "dummy1", "dummy2"			\
  }

2022.02.17 18:00 ビルド開始. 修正の意味は
HARD_REGISTER_NUM_P(33) が 1 に評価されるようにして, その結果

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

が呼び出されるようにするため.
修正して動作確認したが自分が思ったようには修正できていない.
そもそも

eliminate_regs

から INITIAL_ELIMINATION_OFFSET は呼び出されない.

一旦上の修正をやめる.

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

としているが

extern int rl78_dwarf_frame_regnum(int, poly_int64_pod&);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)

のようにしてみる.

ビルドしてみたところエラーになる.

In file included from ./tm.h:22,
                 from ../.././gcc/target.h:52,
                 from ../.././gcc/dwarf2cfi.c:23:
../.././gcc/dwarf2cfi.c: 関数 ‘rtx_def* expand_builtin_dwarf_sp_column()’ 内:
../.././gcc/config/rl78/rl78.h:140:59: エラー: ‘offset’ was not declared in this scope; did you mean ‘off_t’?
  140 | #define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)
      |                                                           ^~~~~~
../.././gcc/dwarf2cfi.c:240:31: 備考: in expansion of macro ‘DWARF_FRAME_REGNUM’
  240 |   unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);
      |                               ^~~~~~~~~~~~~~~~~~

このマクロの使用箇所で offset が定義されていなければエラーになるからしょうがない.
この修正はキャンセル.

試しに g.S に期待値となるコンパイル結果を作成してみたが

	.string	"a"
	.byte	0x1
	.byte	0x3
	.byte	0xb
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 132          これ
	.uleb128 0x6
	.string	"b"
	.byte	0x1
	.byte	0x3
	.byte	0x12
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 136          これ
	.uleb128 0x7

% ./z4
...
rl78-elf-objdump: 警告: .debug_info セクション内に壊れたユニット長 (0) が見つかりました
rl78-elf-objdump: 警告: .debug_info セクション内に壊れたユニット長 (0) が見つかりました
...

objdump でウォーニングが出ている. ユニット長を表わす何かも修正する必要があるらしい.

一旦 g.S を正しいものにすることを止めて, 期待値となるものを生成することにシフトしてみる.


  result = new_reg_loc_descr (regno, offset);

ここで停止して

(gdb) p offset.coeffs[0]
$17 = 4
(gdb) set offset.coeffs[0]=132              書き代える.
(gdb) c
...
(gdb) p offset.coeffs[0]
$18 = 6
(gdb) set offset.coeffs[0]=136              書き代える
(gdb) c

しかし期待した通りの生成結果になっていない. 何か勘違いしている.
コンパイルしているのは f.c だった. 改めて a.c をコンパイルして
a.s を g.S にリネームして

% ./z4
rl78-elf-as -o g.o g.S
rl78-elf-ld -o g.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/start.o g.o -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/sample.x
rl78-elf-objdump -x -d -g g.elf > g.objdump
rl78-elf-objdump -x -d -g g.elf
...
Breakpoint 1 at 0x18e: file a.c, line 11.

Breakpoint 1, main () at a.c:11
11	  printf("hello world %d\n", f(5, 6));
f (a=5, b=6) at a.c:6
6	  return a + b;
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]

%

期待通り動いていている.

問題は a と b は 128 加算するが c はそのままということ.
これは DW_TAG_formal_parameter か DW_TAG_variable かで区別する.

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 4 byte block: 92 20 84 1 	(DW_OP_bregx: 32 (r32) 132)
 <2><d0>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d1>   DW_AT_name        : b
    <d3>   DW_AT_decl_file   : 1
    <d4>   DW_AT_decl_line   : 3
    <d5>   DW_AT_decl_column : 18
    <d6>   DW_AT_type        : <0x7f>
    <da>   DW_AT_location    : 4 byte block: 92 20 86 1 	(DW_OP_bregx: 32 (r32) 134)
 <2><df>: 省略番号: 7 (DW_TAG_variable)
    <e0>   DW_AT_name        : c
    <e2>   DW_AT_decl_file   : 1
    <e3>   DW_AT_decl_line   : 5
    <e4>   DW_AT_decl_column : 8
    <e5>   DW_AT_type        : <0xee>
    <e9>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0)

改めてこのオフセットをどのように変更できるか調べてみる.
現状

      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));


(gdb) p ira_use_lra_p
$29 = true
(gdb)

であるからまずは lra_eliminate_regs で stack_pointer_rtx を返せないかどうか
調べてみる.

static class lra_elim_table *
get_elimination (rtx reg)
{
  int hard_regno;
  class lra_elim_table *ep;

  lra_assert (REG_P (reg));
  if ((hard_regno = REGNO (reg)) < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)
    return NULL;
  if ((ep = elimination_map[hard_regno]) != NULL)
    return ep->from_rtx != reg ? NULL : ep;
  poly_int64 offset = self_elim_offsets[hard_regno];
  if (known_eq (offset, 0))
    return NULL;              ここで返っている.


(gdb) p self_elim_offsets
$30 = {{coeffs = {0}} <repeats 36 times>}
(gdb) p elimination_map
$39 = {0x0 <repeats 36 times>}
(gdb) 

この配列のどちらかを変更することはできるだろうか.
elimination_map は難しい.
self_elim_offsets も難しい.

ira_use_lra_p を false にして lra_eliminate_regs で何とかできないか調べてみる.


	    if (ep->from_rtx == x && ep->can_eliminate)
	      return plus_constant (Pmode, ep->to_rtx, ep->previous_offset);

現状

ep->can_eliminate = false

だがこれを true にできればよい.

      ep->from = ep1->from;
      ep->to = ep1->to;
      ep->can_eliminate = ep->can_eliminate_previous
	= (targetm.can_eliminate (ep->from, ep->to)
	   && ! (ep->to == STACK_POINTER_REGNUM
		 && frame_pointer_needed
		 && (! SUPPORTS_STACK_ALIGNMENT
		     || ! stack_realign_fp)));


以下を追加した.

bool rl78_target_can_eliminate(int from, int to)
{
  assert(from == ARG_POINTER_REGNUM);
  assert(to == STACK_POINTER_REGNUM);
  frame_pointer_needed = false;            これも必要だがずるい.
  return true;
}

#undef TARGET_CAN_ELIMINATE
#define TARGET_CAN_ELIMINATE rl78_target_can_eliminate

これで can_eliminate = true にできている.
さらにオフセットの計算が正しくないので以下を追加

int rl78_frame_pointer_cfa_offset(tree);
#define FRAME_POINTER_CFA_OFFSET(FUN) rl78_frame_pointer_cfa_offset(FUN)

ビルド中 2022.02.18 10:24

上はやめて以下にした

int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)

この修正を入れたところ

int f(int a, int b)
{
  return a + b;
}

に対して, 前は a や b が ap 相対できていたのに sp 相対になっている.

現状はまだできていないが

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 91 84 1 	(DW_OP_fbreg: 132)
 <2><cf>: 省略番号: 6 (DW_TAG_formal_parameter)            ^^^^^^^^^^^
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 91 86 1 	(DW_OP_fbreg: 134)
 <2><dd>: 省略番号: 7 (DW_TAG_variable)                   ^^^^^^^^^^^^
    <de>   DW_AT_name        : c
    <e0>   DW_AT_decl_file   : 1
    <e1>   DW_AT_decl_line   : 5
    <e2>   DW_AT_decl_column : 8
    <e3>   DW_AT_type        : <0xec>
    <e7>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0


DW_OP_fbreg は間違いで, DW_OP_bregx : 32 が正しい.

現状 USE_LRA を define しているが袋工事に入った感じがする.

一旦
#define USE_LRA
を削除する.

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{

が呼び出された時点では reg = ap で offset = 4 なのだからここまでは期待した
動作であるし, この呼び出し前に offset = 132 のように変更するのは間違い.


  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

      if (elim != reg)
        {
 	  ...
	}
    }


  regno = REGNO (reg);


のようになっているから elim で stack_pointer_rtx が戻るのが少くとも必要.
と思ったが,


  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);  これ
    }


オリジナルの cc1

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4  これを試してみる.
  DW_CFA_nop
  DW_CFA_nop


以下を追加

#define INCOMING_FRAME_SP_OFFSET		4

フレームポインタないからこういうのはあまり好きではないが

変更前は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

変更後は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r36 at cfa-4

なのでここは予定通り.
ここは USE_LRA を削除しているから現状は以下

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cf>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6)

当初の予定とは違ったが, 一度 USE_LRA を define した. そして

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;  // もともとは -get_frame_size() にしていた
}

のように修正したところ, 期待通り rl78-elf-gdb が動作している.

2022.02.18 17:18

% tar cf rl78-elf.mine.tar gcc/config/rl78 gcc/common/config/rl78

のようにして一旦現状をバックアップしておいた.

2022.02.18 17:20

#ifdef USE_LRA
int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)
#endif

上を削除

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;
}

上を削除

そしてリビルド. 2022.02.18 18:24 正常動作を確認.
