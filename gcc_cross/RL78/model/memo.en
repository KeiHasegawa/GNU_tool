cc1 model

Refer to "AARCH64" => "cc1 model" => "Memo".
In similar way, cc1 model of RL78 can be built.

Development note:

(*1)
Becase RL78 compiler doesn't use frame pointer like MSP430 compiler, so I
declared like below:

#define STACK_POINTER_REGNUM 32
#define FRAME_POINTER_REGNUM 32

Then cc1 generated code like below:

	e := sp + 4
	e := [e] + [e+2]

I wanted to generate code like below:

      [sp+??] := [sp+4] + [sp+6]

So I tried below:

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    33

Then cc1 generated like below:

	l := [fp+4] + [fp+6]
	x := l

And more,

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "fp",  "dummy0",  "dummy1", "dummy2"			\
  }
#define FIXED_REGISTERS						\
  {								\
      0,     0,     0,     0,     0,     0,     1,     1, 	\

like above, `l' and `h' were removed from register allocation, then

  [fp] := [fp+4] + [fp+6]

was generated.

Once reverted like below:

#define STACK_POINTER_REGNUM   32
#define FRAME_POINTER_REGNUM   32

For the code:

int f(int a, int b)
{
  return a + b;
}

original cc1 generates rtx_insn like below: 

 <materialize-all-clones> {heap 820k} f$1 = (rtx_insn *) 0xb78fb9a0
    1: NOTE_INSN_DELETED
$2 = void
$3 = (rtx_insn *) 0xb78fba20
    3: NOTE_INSN_BASIC_BLOCK 2
$4 = void
$5 = (rtx_insn *) 0xb78fbb40
   21: NOTE_INSN_PROLOGUE_END
$6 = void
$7 = (rtx_insn *) 0xb78fba00
    2: NOTE_INSN_FUNCTION_BEG
$8 = void
$9 = (rtx_insn *) 0xb78774a4
   19: x:HI=[sp:HI+0x6]
$10 = void
$11 = (rtx_insn *) 0xb78774c8
   20: l:HI=x:HI
      REG_DEAD x:HI
$12 = void
$13 = (rtx_insn *) 0xb7877480
   18: x:HI=[sp:HI+0x4]
$14 = void
$15 = (rtx_insn *) 0xb7877360
    5: x:HI=x:HI+l:HI
      REG_DEAD x:HI
$16 = void
$17 = (rtx_insn *) 0xb787745c
   17: r8:HI=x:HI
$18 = void
$19 = (rtx_insn *) 0xb7877414
   13: use r8:HI
$20 = void
$21 = (rtx_insn *) 0xb78fbb60
   22: NOTE_INSN_EPILOGUE_BEG
$22 = void
$23 = (rtx_insn *) 0xb78d5168
   23: return
$24 = void
$25 = (rtx_insn *) 0xb78774ec
   24: barrier
$26 = void
$27 = (rtx_insn *) 0xb78fbae0

These rtx_insn* insns are very different from that of my `cc1'.
I guess that some mechanism works well. At first, I confirmed below rtx_insn
was generated:

(gdb) p debug_insn_slim((rtx_insn*)$34)
    5: r43:HI=[r37:HI]+[r37:HI+0x2]

(gdb) p debug_rtx((rtx_insn*)$34)
(insn 5 0 0 (set (reg:HI 43 [ _3 ])
        (plus:HI (mem/c:HI (reg/f:HI 37 virtual-incoming-args) [1 a+0 S2 A16])
            (mem/c:HI (plus:HI (reg/f:HI 37 virtual-incoming-args)
                    (const_int 2 [0x2])) [1 b+0 S2 A16]))) "b.c":3:12 -1
     (nil))
$38 = void
(gdb) 


static rtx
expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,
		       rtx op0, rtx op1,
		       rtx target, int unsignedp, enum optab_methods methods,
		       rtx_insn *last)
{
...
  create_output_operand (&ops[0], target, tmp_mode);
  create_input_operand (&ops[1], xop0, mode0);
  create_input_operand (&ops[2], xop1, mode1);
  pat = maybe_gen_insn (icode, 3, ops); //// ! This one
  
Maybe,

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    32
#define ARG_POINTER_REGNUM      33

#define ELIMINABLE_REGS { {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM} }

Aboves are the point.

At this point, for hello world program, my `cc1' generates like below:

_main:
	subw	sp, #2
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	movw	de, #0              ; ! This one
	movw	r8, de              ; ! This one
	addw	sp, #2
	ret

gcc common part chose `de' register. I wish `ax' is chosen. Then I tried:

#define FIXED_REGISTERS						\
  {								\
      0,     0,     1,     1,     1,     1,     1,     1, 	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,       1,         1			\
  }

2022.02.17 6:50 Rebuild started.

2022.02.17 7:47 I confirmed that:

_main:
	subw	sp, #4
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	[sp+0] := 0
	[sp+0] := [sp+0]
	r8 := [sp+0]
	addw	sp, #4
	ret

This is not the resutl as I expected. Once reverted this fix.

Later, I read this file but I could not understand how I reached to
the current resutl. Any way now my `cc1' could generate below rtx_insn:

    5: e:HI=[sp:HI+0x4]+[sp:HI+0x6]

   12: r8:HI=e:HI
   
(*2)
At this point, hello world 11 program worked well.

Compiling hello world 11 program with -g option and it was executed
under control of rl78-elf-gdb, the result became like below:

Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
5	  return a + b;
#0  f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
#1  0x00000198 in main () at a.c:10
0x00000198 in main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
Value returned is $1 = 11
hello world 11

At this point, my `cc1' did not generate any rtx_insn* insn like:

  RTX_FRAME_RELATED_P(insn) = true;

Above result was difficult to understand, but rl78-elf-gdb could not
display `a' and `b' correctly, but everything except it was OK.
i.e. `where' command and `finish' command worked welll.

.debug_info dump result was:

 <2><bd>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 21 4 	(DW_OP_bregx: 33 (r33) 4)
 <2><cb>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 21 6 	(DW_OP_bregx: 33 (r33) 6

And this 33'th register appeared in above error messages.

At this point, declared like below:

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    32
#define ARG_POINTER_REGNUM      33

Once I thoght if this `33' was changed to `32', rl78-elf-gdb worked well,
But it was just correct for the case where no local variable or no mediam
variable.

Original `cc1' .debug_info dump result was:

<2><c9>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><d6>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 2 	(DW_OP_fbreg: 2)

And at original `cc1', declared like below:

#define FRAME_POINTER_REGNUM 		22
#define STACK_POINTER_REGNUM 	        32
#define ARG_POINTER_REGNUM 		33

I thought I should have gone my way.

At this point, .debug_frame dump result was:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000008 00000000 FDE cie=00000000 pc=000b017d..000b0185

0000001e 00000008 00000000 FDE cie=00000000 pc=00000000..00000000

Above just said that 32'th register was stack pointer and nothing about
33'th register.

On the other hand, original `cc1' .debug_info dump result was:

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4   # This one
  DW_CFA_nop
  DW_CFA_nop

00000014 0000000c 00000000 FDE cie=00000000 pc=0000017d..00000186

しかしオリジナルの cc1 ではフレームポインタを一応形だけもっているからこうすることで
おそらくうまくいっている.

I thought original `cc1' just formally has frame pointer and this
worked well for that reason.

I tried like below:

void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_MINUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, 4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

This caused an internal error like below:

during RTL pass: dwarf2
a.c: In function ‘f’:
a.c:6:1: internal compiler error: in dwarf2out_frame_debug_expr, at dwarf2cfi.c:1758
    6 | }
      | ^
0x85dd00d dwarf2out_frame_debug_expr
	../.././gcc/dwarf2cfi.c:1758
0x85de105 dwarf2out_frame_debug

I guessed that it was out of rule to generate rtx_insn like ap := sp - 4.

Then I tried liek below:
void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_PLUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, -4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

Then .debug_frame dump result became like below:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000010 00000000 FDE cie=00000000 pc=000b017d..000b0181
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

00000026 00000010 00000000 FDE cie=00000000 pc=00270188..0027018c
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

Above was as I expected, but rl78-elf-gdb made the same error like below:

f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5

I thought that I should have changed `.debug_info' like below:

 <2><bd>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cb>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6

where, `a' and `b' are located at sp relative position.
I created the assembler source which realized above .debug_info, and confirmed
the program was executed as I expected under control of rl78-elf-gdb.

この部分を生成しているところを調べてみる.
Then I investigated the part which generated these:

(gdb) delete
(gdb) b final_1
(gdb) run
...


          compile_file ();

When returning form above, `cc1' generated them.

      (*debug_hooks->finish) (main_input_filename);  // This part


  output_comp_unit (comp_unit_die (), have_macinfo,
		    dwarf_split_debug_info ? checksum : NULL); // This part
		    

  output_die (die);  // This part

	  output_loc_sequence (AT_loc (a), -1);  // This part

      output_loc_operands (loc, for_eh_or_skip);  // This part

At above part, generated below:

	.uleb128 0x21  ARG_POINTER_REGNUM
	.sleb128 4     ; offset


(gdb) p loc->dw_loc_oprnd1.v.val_addr
$47 = (rtx) 0x21
(gdb) p loc->dw_loc_oprnd2.v.val_addr
$50 = (rtx) 0x4
(gdb)

I caught the timing setting these:

static inline dw_loc_descr_ref
new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,
	       unsigned HOST_WIDE_INT oprnd2)
{
  dw_loc_descr_ref descr = ggc_cleared_alloc<dw_loc_descr_node> ();

  descr->dw_loc_opc = op;
  descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd1.val_entry = NULL;
  descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;
  descr->dw_loc_oprnd2.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd2.val_entry = NULL;
  descr->dw_loc_oprnd2.v.val_unsigned = oprnd2;

and I confrimed above code set them.

  regno = DWARF_FRAME_REGNUM (regno);  // Here, to convert `33' to `32' works well

  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);
    }

  result = new_reg_loc_descr (regno, offset);  // From here, calling above.
  
Then I declared like below:

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

int rl78_dwarf_frame_regnum(int regno)
{
  if (regno == ARG_POINTER_REGNUM)
    return STACK_POINTER_REGNUM;
  assert(regno == STACK_POINTER_REGNUM);
  return regno;
}

Now, hello world 11 program compiled with -g option was executed
under control of rl78-elf-gdb suitably.

(*3)
残念ながら現状では

#include <stdio.h>

int f(int a, int b)
{
  char c[128];
  return a + b;
}

int main()
{
  printf("hello world %d\n", f(5, 6));
  return 0;
}

のように f で 128 バイトのローカル変数を宣言すると, まずは実行結果が正しくない.
f の先頭アドレスで以下のようになっている.

(rl78-elf-gdb) x/4wh $sp
0xf7ff4:	0x019c	0xcc00	0x0005	0x0006
(rl78-elf-gdb) 


0xf7ff4	+---------------+ <- sp
	|    0x019c	|
0xf7ff6	+---------------+
	|    0xcc00	|
0xf7ff8	+---------------+
	|    0x0005	|
0xf7ffa	+---------------+
	|    0x0006	|
0xf7ffc	+---------------+

これは呼び出す側ができていないように見えると思ったがこれはこれで合っていた.
0x19c は f を呼び出した call 命令の次のアドレス.



_f:
	subw	sp, #128
	movw	ax, [sp+6]
	movw	de, ax
	movw	ax, [sp+4]

単純に sp+6 や sp+4 が間違い. ap 相対のコードを以下のように修正.

inline void load(int regno, int offset)
{
  fprintf(asm_out_file, "	movw	");
  print_reg(asm_out_file, regno, HImode);
  auto sp = reg_names[STACK_POINTER_REGNUM];
  offset += get_frame_size();                          これ
  fprintf(asm_out_file, ", [%s+%d]\n", sp, offset);
}

この修正で実行結果は正しい. つまり生成しているアセンブリは正しい.

同じ修正を変数 a や b のオフセットに対しても行なってみる.

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{
  unsigned int regno;
  dw_loc_descr_ref result;
  dw_fde_ref fde = cfun->fde;

  /* We only use "frame base" when we're sure we're talking about the
     post-prologue local stack frame.  We do this by *not* running
     register elimination until this point, and recognizing the special
     argument pointer and soft frame pointer rtx's.  */
  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

これは bfin, mn10300, moxie でもやった.


bool rl78_legitimate_address_p(machine_mode mode, rtx x, bool strict)
{
  (void)mode; (void)strict;
  if (MEM_P(x))
    return false;
  return true;
}
...
#undef TARGET_LRA_P
#define TARGET_LRA_P hook_bool_void_false

gcc_target targetm = TARGET_INITIALIZER;

この修正を入れたが

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

が呼び出されない.

以下を
#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

以下のように変更した.

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy0", "dummy1", "dummy2"			\
  }

2022.02.17 18:00 ビルド開始. 修正の意味は
HARD_REGISTER_NUM_P(33) が 1 に評価されるようにして, その結果

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

が呼び出されるようにするため.
修正して動作確認したが自分が思ったようには修正できていない.
そもそも

eliminate_regs

から INITIAL_ELIMINATION_OFFSET は呼び出されない.

一旦上の修正をやめる.

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

としているが

extern int rl78_dwarf_frame_regnum(int, poly_int64_pod&);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)

のようにしてみる.

ビルドしてみたところエラーになる.

In file included from ./tm.h:22,
                 from ../.././gcc/target.h:52,
                 from ../.././gcc/dwarf2cfi.c:23:
../.././gcc/dwarf2cfi.c: 関数 ‘rtx_def* expand_builtin_dwarf_sp_column()’ 内:
../.././gcc/config/rl78/rl78.h:140:59: エラー: ‘offset’ was not declared in this scope; did you mean ‘off_t’?
  140 | #define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)
      |                                                           ^~~~~~
../.././gcc/dwarf2cfi.c:240:31: 備考: in expansion of macro ‘DWARF_FRAME_REGNUM’
  240 |   unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);
      |                               ^~~~~~~~~~~~~~~~~~

このマクロの使用箇所で offset が定義されていなければエラーになるからしょうがない.
この修正はキャンセル.

試しに g.S に期待値となるコンパイル結果を作成してみたが

	.string	"a"
	.byte	0x1
	.byte	0x3
	.byte	0xb
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 132          これ
	.uleb128 0x6
	.string	"b"
	.byte	0x1
	.byte	0x3
	.byte	0x12
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 136          これ
	.uleb128 0x7

% ./z4
...
rl78-elf-objdump: 警告: .debug_info セクション内に壊れたユニット長 (0) が見つかりました
rl78-elf-objdump: 警告: .debug_info セクション内に壊れたユニット長 (0) が見つかりました
...

objdump でウォーニングが出ている. ユニット長を表わす何かも修正する必要があるらしい.

一旦 g.S を正しいものにすることを止めて, 期待値となるものを生成することにシフトしてみる.


  result = new_reg_loc_descr (regno, offset);

ここで停止して

(gdb) p offset.coeffs[0]
$17 = 4
(gdb) set offset.coeffs[0]=132              書き代える.
(gdb) c
...
(gdb) p offset.coeffs[0]
$18 = 6
(gdb) set offset.coeffs[0]=136              書き代える
(gdb) c

しかし期待した通りの生成結果になっていない. 何か勘違いしている.
コンパイルしているのは f.c だった. 改めて a.c をコンパイルして
a.s を g.S にリネームして

% ./z4
rl78-elf-as -o g.o g.S
rl78-elf-ld -o g.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/start.o g.o -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/sample.x
rl78-elf-objdump -x -d -g g.elf > g.objdump
rl78-elf-objdump -x -d -g g.elf
...
Breakpoint 1 at 0x18e: file a.c, line 11.

Breakpoint 1, main () at a.c:11
11	  printf("hello world %d\n", f(5, 6));
f (a=5, b=6) at a.c:6
6	  return a + b;
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]

%

期待通り動いていている.

問題は a と b は 128 加算するが c はそのままということ.
これは DW_TAG_formal_parameter か DW_TAG_variable かで区別する.

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 4 byte block: 92 20 84 1 	(DW_OP_bregx: 32 (r32) 132)
 <2><d0>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d1>   DW_AT_name        : b
    <d3>   DW_AT_decl_file   : 1
    <d4>   DW_AT_decl_line   : 3
    <d5>   DW_AT_decl_column : 18
    <d6>   DW_AT_type        : <0x7f>
    <da>   DW_AT_location    : 4 byte block: 92 20 86 1 	(DW_OP_bregx: 32 (r32) 134)
 <2><df>: 省略番号: 7 (DW_TAG_variable)
    <e0>   DW_AT_name        : c
    <e2>   DW_AT_decl_file   : 1
    <e3>   DW_AT_decl_line   : 5
    <e4>   DW_AT_decl_column : 8
    <e5>   DW_AT_type        : <0xee>
    <e9>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0)

改めてこのオフセットをどのように変更できるか調べてみる.
現状

      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));


(gdb) p ira_use_lra_p
$29 = true
(gdb)

であるからまずは lra_eliminate_regs で stack_pointer_rtx を返せないかどうか
調べてみる.

static class lra_elim_table *
get_elimination (rtx reg)
{
  int hard_regno;
  class lra_elim_table *ep;

  lra_assert (REG_P (reg));
  if ((hard_regno = REGNO (reg)) < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)
    return NULL;
  if ((ep = elimination_map[hard_regno]) != NULL)
    return ep->from_rtx != reg ? NULL : ep;
  poly_int64 offset = self_elim_offsets[hard_regno];
  if (known_eq (offset, 0))
    return NULL;              ここで返っている.


(gdb) p self_elim_offsets
$30 = {{coeffs = {0}} <repeats 36 times>}
(gdb) p elimination_map
$39 = {0x0 <repeats 36 times>}
(gdb) 

この配列のどちらかを変更することはできるだろうか.
elimination_map は難しい.
self_elim_offsets も難しい.

ira_use_lra_p を false にして lra_eliminate_regs で何とかできないか調べてみる.


	    if (ep->from_rtx == x && ep->can_eliminate)
	      return plus_constant (Pmode, ep->to_rtx, ep->previous_offset);

現状

ep->can_eliminate = false

だがこれを true にできればよい.

      ep->from = ep1->from;
      ep->to = ep1->to;
      ep->can_eliminate = ep->can_eliminate_previous
	= (targetm.can_eliminate (ep->from, ep->to)
	   && ! (ep->to == STACK_POINTER_REGNUM
		 && frame_pointer_needed
		 && (! SUPPORTS_STACK_ALIGNMENT
		     || ! stack_realign_fp)));


以下を追加した.

bool rl78_target_can_eliminate(int from, int to)
{
  assert(from == ARG_POINTER_REGNUM);
  assert(to == STACK_POINTER_REGNUM);
  frame_pointer_needed = false;            これも必要だがずるい.
  return true;
}

#undef TARGET_CAN_ELIMINATE
#define TARGET_CAN_ELIMINATE rl78_target_can_eliminate

これで can_eliminate = true にできている.
さらにオフセットの計算が正しくないので以下を追加

int rl78_frame_pointer_cfa_offset(tree);
#define FRAME_POINTER_CFA_OFFSET(FUN) rl78_frame_pointer_cfa_offset(FUN)

ビルド中 2022.02.18 10:24

上はやめて以下にした

int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)

この修正を入れたところ

int f(int a, int b)
{
  return a + b;
}

に対して, 前は a や b が ap 相対できていたのに sp 相対になっている.

現状はまだできていないが

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 91 84 1 	(DW_OP_fbreg: 132)
 <2><cf>: 省略番号: 6 (DW_TAG_formal_parameter)            ^^^^^^^^^^^
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 91 86 1 	(DW_OP_fbreg: 134)
 <2><dd>: 省略番号: 7 (DW_TAG_variable)                   ^^^^^^^^^^^^
    <de>   DW_AT_name        : c
    <e0>   DW_AT_decl_file   : 1
    <e1>   DW_AT_decl_line   : 5
    <e2>   DW_AT_decl_column : 8
    <e3>   DW_AT_type        : <0xec>
    <e7>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0


DW_OP_fbreg は間違いで, DW_OP_bregx : 32 が正しい.

現状 USE_LRA を define しているが袋工事に入った感じがする.

一旦
#define USE_LRA
を削除する.

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{

が呼び出された時点では reg = ap で offset = 4 なのだからここまでは期待した
動作であるし, この呼び出し前に offset = 132 のように変更するのは間違い.


  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

      if (elim != reg)
        {
 	  ...
	}
    }


  regno = REGNO (reg);


のようになっているから elim で stack_pointer_rtx が戻るのが少くとも必要.
と思ったが,


  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);  これ
    }


オリジナルの cc1

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4  これを試してみる.
  DW_CFA_nop
  DW_CFA_nop


以下を追加

#define INCOMING_FRAME_SP_OFFSET		4

フレームポインタないからこういうのはあまり好きではないが

変更前は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

変更後は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r36 at cfa-4

なのでここは予定通り.
ここは USE_LRA を削除しているから現状は以下

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cf>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6)

当初の予定とは違ったが, 一度 USE_LRA を define した. そして

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;  // もともとは -get_frame_size() にしていた
}

のように修正したところ, 期待通り rl78-elf-gdb が動作している.

2022.02.18 17:18

% tar cf rl78-elf.mine.tar gcc/config/rl78 gcc/common/config/rl78

のようにして一旦現状をバックアップしておいた.

2022.02.18 17:20

#ifdef USE_LRA
int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)
#endif

上を削除

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;
}

上を削除

そしてリビルド. 2022.02.18 18:24 正常動作を確認.


