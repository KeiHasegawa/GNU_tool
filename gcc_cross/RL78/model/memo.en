cc1 model

Refer to "AARCH64" => "cc1 model" => "Memo".
In similar way, cc1 model of RL78 can be built.

Development note:

(*1)
Becase RL78 compiler doesn't use frame pointer like MSP430 compiler, so I
declared like below:

#define STACK_POINTER_REGNUM 32
#define FRAME_POINTER_REGNUM 32

Then cc1 generated code like below:

	e := sp + 4
	e := [e] + [e+2]

I wanted to generate code like below:

      [sp+??] := [sp+4] + [sp+6]

So I tried below:

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    33

Then cc1 generated like below:

	l := [fp+4] + [fp+6]
	x := l

And more,

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "fp",  "dummy0",  "dummy1", "dummy2"			\
  }
#define FIXED_REGISTERS						\
  {								\
      0,     0,     0,     0,     0,     0,     1,     1, 	\

like above, `l' and `h' were removed from register allocation, then

  [fp] := [fp+4] + [fp+6]

was generated.

Once reverted like below:

#define STACK_POINTER_REGNUM   32
#define FRAME_POINTER_REGNUM   32

For the code:

int f(int a, int b)
{
  return a + b;
}

original cc1 generates rtx_insn like below: 

 <materialize-all-clones> {heap 820k} f$1 = (rtx_insn *) 0xb78fb9a0
    1: NOTE_INSN_DELETED
$2 = void
$3 = (rtx_insn *) 0xb78fba20
    3: NOTE_INSN_BASIC_BLOCK 2
$4 = void
$5 = (rtx_insn *) 0xb78fbb40
   21: NOTE_INSN_PROLOGUE_END
$6 = void
$7 = (rtx_insn *) 0xb78fba00
    2: NOTE_INSN_FUNCTION_BEG
$8 = void
$9 = (rtx_insn *) 0xb78774a4
   19: x:HI=[sp:HI+0x6]
$10 = void
$11 = (rtx_insn *) 0xb78774c8
   20: l:HI=x:HI
      REG_DEAD x:HI
$12 = void
$13 = (rtx_insn *) 0xb7877480
   18: x:HI=[sp:HI+0x4]
$14 = void
$15 = (rtx_insn *) 0xb7877360
    5: x:HI=x:HI+l:HI
      REG_DEAD x:HI
$16 = void
$17 = (rtx_insn *) 0xb787745c
   17: r8:HI=x:HI
$18 = void
$19 = (rtx_insn *) 0xb7877414
   13: use r8:HI
$20 = void
$21 = (rtx_insn *) 0xb78fbb60
   22: NOTE_INSN_EPILOGUE_BEG
$22 = void
$23 = (rtx_insn *) 0xb78d5168
   23: return
$24 = void
$25 = (rtx_insn *) 0xb78774ec
   24: barrier
$26 = void
$27 = (rtx_insn *) 0xb78fbae0

These rtx_insn* insns are very different from that of my `cc1'.
I guess that some mechanism works well. At first, I confirmed below rtx_insn
was generated:

(gdb) p debug_insn_slim((rtx_insn*)$34)
    5: r43:HI=[r37:HI]+[r37:HI+0x2]

(gdb) p debug_rtx((rtx_insn*)$34)
(insn 5 0 0 (set (reg:HI 43 [ _3 ])
        (plus:HI (mem/c:HI (reg/f:HI 37 virtual-incoming-args) [1 a+0 S2 A16])
            (mem/c:HI (plus:HI (reg/f:HI 37 virtual-incoming-args)
                    (const_int 2 [0x2])) [1 b+0 S2 A16]))) "b.c":3:12 -1
     (nil))
$38 = void
(gdb) 


static rtx
expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,
		       rtx op0, rtx op1,
		       rtx target, int unsignedp, enum optab_methods methods,
		       rtx_insn *last)
{
...
  create_output_operand (&ops[0], target, tmp_mode);
  create_input_operand (&ops[1], xop0, mode0);
  create_input_operand (&ops[2], xop1, mode1);
  pat = maybe_gen_insn (icode, 3, ops); //// ! This one
  
Maybe,

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    32
#define ARG_POINTER_REGNUM      33

#define ELIMINABLE_REGS { {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM} }

Aboves are the point.

At this point, for hello world program, my `cc1' generates like below:

_main:
	subw	sp, #2
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	movw	de, #0              ; ! This one
	movw	r8, de              ; ! This one
	addw	sp, #2
	ret

gcc common part chose `de' register. I wish `ax' is chosen. Then I tried:

#define FIXED_REGISTERS						\
  {								\
      0,     0,     1,     1,     1,     1,     1,     1, 	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,     1,     1,     1,     1,     1,     1,	\
      1,     1,       1,         1			\
  }

2022.02.17 6:50 Rebuild started.

2022.02.17 7:47 I confirmed that:

_main:
	subw	sp, #4
	movw	ax, #.LC0
	movw	[sp], ax
	call	!!%code(_puts)
	[sp+0] := 0
	[sp+0] := [sp+0]
	r8 := [sp+0]
	addw	sp, #4
	ret

This is not the resutl as I expected. Once reverted this fix.

Later, I read this file but I could not understand how I reached to
the current resutl. Any way now my `cc1' could generate below rtx_insn:

    5: e:HI=[sp:HI+0x4]+[sp:HI+0x6]

   12: r8:HI=e:HI
   
(*2)
At this point, hello world 11 program worked well.

Compiling hello world 11 program with -g option and it was executed
under control of rl78-elf-gdb, the result became like below:

Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
5	  return a + b;
#0  f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5
#1  0x00000198 in main () at a.c:10
0x00000198 in main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
Value returned is $1 = 11
hello world 11

At this point, my `cc1' did not generate any rtx_insn* insn like:

  RTX_FRAME_RELATED_P(insn) = true;

Above result was difficult to understand, but rl78-elf-gdb could not
display `a' and `b' correctly, but everything except it was OK.
i.e. `where' command and `finish' command worked welll.

.debug_info dump result was:

 <2><bd>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 21 4 	(DW_OP_bregx: 33 (r33) 4)
 <2><cb>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 21 6 	(DW_OP_bregx: 33 (r33) 6

And this 33'th register appeared in above error messages.

At this point, declared like below:

#define STACK_POINTER_REGNUM    32
#define FRAME_POINTER_REGNUM    32
#define ARG_POINTER_REGNUM      33

Once I thoght if this `33' was changed to `32', rl78-elf-gdb worked well,
But it was just correct for the case where no local variable or no mediam
variable.

Original `cc1' .debug_info dump result was:

<2><c9>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <ca>   DW_AT_name        : a
    <cc>   DW_AT_decl_file   : 1
    <cd>   DW_AT_decl_line   : 3
    <ce>   DW_AT_decl_column : 11
    <cf>   DW_AT_type        : <0x83>
    <d3>   DW_AT_location    : 2 byte block: 91 0 	(DW_OP_fbreg: 0)
 <2><d6>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <d7>   DW_AT_name        : b
    <d9>   DW_AT_decl_file   : 1
    <da>   DW_AT_decl_line   : 3
    <db>   DW_AT_decl_column : 18
    <dc>   DW_AT_type        : <0x83>
    <e0>   DW_AT_location    : 2 byte block: 91 2 	(DW_OP_fbreg: 2)

And at original `cc1', declared like below:

#define FRAME_POINTER_REGNUM 		22
#define STACK_POINTER_REGNUM 	        32
#define ARG_POINTER_REGNUM 		33

I thought I should have gone my way.

At this point, .debug_frame dump result was:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000008 00000000 FDE cie=00000000 pc=000b017d..000b0185

0000001e 00000008 00000000 FDE cie=00000000 pc=00000000..00000000

Above just said that 32'th register was stack pointer and nothing about
33'th register.

On the other hand, original `cc1' .debug_info dump result was:

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4   # This one
  DW_CFA_nop
  DW_CFA_nop

00000014 0000000c 00000000 FDE cie=00000000 pc=0000017d..00000186

I thought original `cc1' just formally has frame pointer and this
worked well for that reason.

I tried like below:

void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_MINUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, 4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

This caused an internal error like below:

during RTL pass: dwarf2
a.c: In function ‘f’:
a.c:6:1: internal compiler error: in dwarf2out_frame_debug_expr, at dwarf2cfi.c:1758
    6 | }
      | ^
0x85dd00d dwarf2out_frame_debug_expr
	../.././gcc/dwarf2cfi.c:1758
0x85de105 dwarf2out_frame_debug

I guessed that it was out of rule to generate rtx_insn like ap := sp - 4.

Then I tried liek below:
void rl78_expand_prologue()
{
  auto ap = gen_rtx_REG(Pmode, ARG_POINTER_REGNUM);
  auto sp = stack_pointer_rtx;
  auto minus4 = gen_rtx_PLUS(Pmode, sp, gen_rtx_CONST_INT(Pmode, -4));
  auto insn = emit_move_insn(ap, minus4);
  RTX_FRAME_RELATED_P(insn) = true;

Then .debug_frame dump result became like below:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

00000012 00000010 00000000 FDE cie=00000000 pc=000b017d..000b0181
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

00000026 00000010 00000000 FDE cie=00000000 pc=00270188..0027018c
  DW_CFA_nop
  DW_CFA_def_cfa: r33 ofs 4

Above was as I expected, but rl78-elf-gdb made the same error like below:

f (a=<error reading variable: Unable to access DWARF register number 33>, 
    b=<error reading variable: Unable to access DWARF register number 33>)
    at a.c:5

I thought that I should have changed `.debug_info' like below:

 <2><bd>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <be>   DW_AT_name        : a
    <c0>   DW_AT_decl_file   : 1
    <c1>   DW_AT_decl_line   : 3
    <c2>   DW_AT_decl_column : 11
    <c3>   DW_AT_type        : <0x7f>
    <c7>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cb>: Abbrev Number: 6 (DW_TAG_formal_parameter)
    <cc>   DW_AT_name        : b
    <ce>   DW_AT_decl_file   : 1
    <cf>   DW_AT_decl_line   : 3
    <d0>   DW_AT_decl_column : 18
    <d1>   DW_AT_type        : <0x7f>
    <d5>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6

where, `a' and `b' are located at sp relative position.
I created the assembler source which realized above .debug_info, and confirmed
the program was executed as I expected under control of rl78-elf-gdb.

Then I investigated the part which generated these:

(gdb) delete
(gdb) b final_1
(gdb) run
...


          compile_file ();

When returning form above, `cc1' generated them.

      (*debug_hooks->finish) (main_input_filename);  // This part


  output_comp_unit (comp_unit_die (), have_macinfo,
		    dwarf_split_debug_info ? checksum : NULL); // This part
		    

  output_die (die);  // This part

	  output_loc_sequence (AT_loc (a), -1);  // This part

      output_loc_operands (loc, for_eh_or_skip);  // This part

At above part, generated below:

	.uleb128 0x21  ARG_POINTER_REGNUM
	.sleb128 4     ; offset


(gdb) p loc->dw_loc_oprnd1.v.val_addr
$47 = (rtx) 0x21
(gdb) p loc->dw_loc_oprnd2.v.val_addr
$50 = (rtx) 0x4
(gdb)

I caught the timing setting these:

static inline dw_loc_descr_ref
new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,
	       unsigned HOST_WIDE_INT oprnd2)
{
  dw_loc_descr_ref descr = ggc_cleared_alloc<dw_loc_descr_node> ();

  descr->dw_loc_opc = op;
  descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd1.val_entry = NULL;
  descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;
  descr->dw_loc_oprnd2.val_class = dw_val_class_unsigned_const;
  descr->dw_loc_oprnd2.val_entry = NULL;
  descr->dw_loc_oprnd2.v.val_unsigned = oprnd2;

and I confrimed above code set them.

  regno = DWARF_FRAME_REGNUM (regno);  // Here, to convert `33' to `32' works well

  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);
    }

  result = new_reg_loc_descr (regno, offset);  // From here, calling above.
  
Then I declared like below:

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

int rl78_dwarf_frame_regnum(int regno)
{
  if (regno == ARG_POINTER_REGNUM)
    return STACK_POINTER_REGNUM;
  assert(regno == STACK_POINTER_REGNUM);
  return regno;
}

Now, hello world 11 program compiled with -g option was executed
under control of rl78-elf-gdb suitably.

(*3)
Unfortunately, at this point, for below program

#include <stdio.h>

int f(int a, int b)
{
  char c[128];
  return a + b;
}

int main()
{
  printf("hello world %d\n", f(5, 6));
  return 0;
}

which uses 128 bytes local area at `f', the execution result was wrong.

At the start address of `f':

(rl78-elf-gdb) x/4wh $sp
0xf7ff4:	0x019c	0xcc00	0x0005	0x0006
(rl78-elf-gdb) 


0xf7ff4	+---------------+ <- sp
	|    0x019c	|
0xf7ff6	+---------------+
	|    0xcc00	|
0xf7ff8	+---------------+
	|    0x0005	|
0xf7ffa	+---------------+
	|    0x0006	|
0xf7ffc	+---------------+

where, 0x19c is the return address of `f'.

_f:
	subw	sp, #128
	movw	ax, [sp+6]
	movw	de, ax
	movw	ax, [sp+4]

Simply, at above assembler source, `sp+6' and `sp+4' were wrong.
Then I tired to fix the `ap' relative code like below:

inline void load(int regno, int offset)
{
  fprintf(asm_out_file, "	movw	");
  print_reg(asm_out_file, regno, HImode);
  auto sp = reg_names[STACK_POINTER_REGNUM];
  offset += get_frame_size();                          // This one
  fprintf(asm_out_file, ", [%s+%d]\n", sp, offset);
}

This fix caused the correct execution. i.e. The generated assembler program
was correct.

I tried to apply the same fix for parameter `a' and `b':

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{
  unsigned int regno;
  dw_loc_descr_ref result;
  dw_fde_ref fde = cfun->fde;

  /* We only use "frame base" when we're sure we're talking about the
     post-prologue local stack frame.  We do this by *not* running
     register elimination until this point, and recognizing the special
     argument pointer and soft frame pointer rtx's.  */
  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

This kind of work was done for `bfin', `mn10300', and `moxie' compiler.

bool rl78_legitimate_address_p(machine_mode mode, rtx x, bool strict)
{
  (void)mode; (void)strict;
  if (MEM_P(x))
    return false;
  return true;
}
...
#undef TARGET_LRA_P
#define TARGET_LRA_P hook_bool_void_false

gcc_target targetm = TARGET_INITIALIZER;

This fix was applied but the next function wasn't called unexpectedly:

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

Then I fixed

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy1", "dummy2"				\
  }

like below:

#define REGISTER_NAMES						\
  {								\
    "x",   "a",   "c",   "b",   "e",   "d",   "l",   "h", 	\
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",	\
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",	\
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",	\
    "sp",  "ap",  "dummy0", "dummy1", "dummy2"			\
  }

Above fix was meant that `HARD_REGISTER_NUM_P(33)' was evaluated as `1' and
as this result, 

void INITIAL_ELIMINATION_OFFSET(int from, int to, poly_int64_pod& offset)

became to be called.

I confirmed that the result was not as I expected.
At the first place

eliminate_regs

did not call `INITIAL_ELIMINATION_OFFSET'.

Once I cancelled above fix.

At this point, `DWARF_FRAME_REGNUM' was declared like below:

extern int rl78_dwarf_frame_regnum(int);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X)

I tried to fix like below:

extern int rl78_dwarf_frame_regnum(int, poly_int64_pod&);
#define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)

But it caused compile error:

In file included from ./tm.h:22,
                 from ../.././gcc/target.h:52,
                 from ../.././gcc/dwarf2cfi.c:23:
../.././gcc/dwarf2cfi.c: In function ‘rtx_def* expand_builtin_dwarf_sp_column()’ :
../.././gcc/config/rl78/rl78.h:140:59: Error: ‘offset’ was not declared in this scope; did you mean ‘off_t’?
  140 | #define DWARF_FRAME_REGNUM(X)  rl78_dwarf_frame_regnum(X, offset)
      |                                                           ^~~~~~
../.././gcc/dwarf2cfi.c:240:31: note: in expansion of macro ‘DWARF_FRAME_REGNUM’
  240 |   unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);
      |                               ^~~~~~~~~~~~~~~~~~

At the code which uses this macro, if `offset' is not declared, compile
error will be occured, so there is no way. Once I cancelled this fix.

I tried to make `g.S' which was expected result.

	.string	"a"
	.byte	0x1
	.byte	0x3
	.byte	0xb
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 132          ; This one
	.uleb128 0x6
	.string	"b"
	.byte	0x1
	.byte	0x3
	.byte	0x12
	.4byte	0x59
	.uleb128 0x3
	.byte	0x92
	.uleb128 0x20
	.sleb128 136          ; This one
	.uleb128 0x7

% ./z4
...
rl78-elf-objdump: Warning: Corrupt unit length (0x0) found in section .debug_info
rl78-elf-objdump: Warning: Corrupt unit length (0x0) found in section .debug_info
...

rl78-elf-objdump generated above warning. I had to fix something called unit
length.

Once I decided to stop making g.S correct, tried to generate correct one.

  result = new_reg_loc_descr (regno, offset);

Stop above code and

(gdb) p offset.coeffs[0]
$17 = 4
(gdb) set offset.coeffs[0]=132              # modify
(gdb) c
...
(gdb) p offset.coeffs[0]
$18 = 6
(gdb) set offset.coeffs[0]=136              # modify
(gdb) c

% ./z4
rl78-elf-as -o g.o g.S
rl78-elf-ld -o g.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/start.o g.o -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/RL78/tool/sample.x
rl78-elf-objdump -x -d -g g.elf > g.objdump
rl78-elf-objdump -x -d -g g.elf
...
Breakpoint 1 at 0x18e: file a.c, line 11.

Breakpoint 1, main () at a.c:11
11	  printf("hello world %d\n", f(5, 6));
f (a=5, b=6) at a.c:6
6	  return a + b;
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]

%

OK. It worked well as I expected.

The problem was that the offset of `a' and `b' were added 128 but that of
`c' was not.
This could be done by `DW_TAG_formal_parameter' and `DW_TAG_variable'

 <2><c1>: Abbrev number: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 4 byte block: 92 20 84 1 	(DW_OP_bregx: 32 (r32) 132)
 <2><d0>: Abbrev number: 6 (DW_TAG_formal_parameter)
    <d1>   DW_AT_name        : b
    <d3>   DW_AT_decl_file   : 1
    <d4>   DW_AT_decl_line   : 3
    <d5>   DW_AT_decl_column : 18
    <d6>   DW_AT_type        : <0x7f>
    <da>   DW_AT_location    : 4 byte block: 92 20 86 1 	(DW_OP_bregx: 32 (r32) 134)
 <2><df>: Abbrev number: 7 (DW_TAG_variable)
    <e0>   DW_AT_name        : c
    <e2>   DW_AT_decl_file   : 1
    <e3>   DW_AT_decl_line   : 5
    <e4>   DW_AT_decl_column : 8
    <e5>   DW_AT_type        : <0xee>
    <e9>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0)

Again I tried to investigate how this offset was modified. At this point,

      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));


(gdb) p ira_use_lra_p
$29 = true
(gdb)

So first, I tried to investigate how `lra_eliminate_regs' could return
`stack_pointer_rtx'.

static class lra_elim_table *
get_elimination (rtx reg)
{
  int hard_regno;
  class lra_elim_table *ep;

  lra_assert (REG_P (reg));
  if ((hard_regno = REGNO (reg)) < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)
    return NULL;
  if ((ep = elimination_map[hard_regno]) != NULL)
    return ep->from_rtx != reg ? NULL : ep;
  poly_int64 offset = self_elim_offsets[hard_regno];
  if (known_eq (offset, 0))
    return NULL;              // Return here


(gdb) p self_elim_offsets
$30 = {{coeffs = {0}} <repeats 36 times>}
(gdb) p elimination_map
$39 = {0x0 <repeats 36 times>}
(gdb) 

I wondered it was possible to modify one of two arrays.
To modify `elimination_map' was difficult.
To modify `self_elim_offsets' was also difficult.

I tried to investigate if `lra_eliminate_regs' worked well by making
`ira_use_lra_p' false.

	    if (ep->from_rtx == x && ep->can_eliminate)
	      return plus_constant (Pmode, ep->to_rtx, ep->previous_offset);

Then at this point

ep->can_eliminate = false

but it's OK if making it true.

      ep->from = ep1->from;
      ep->to = ep1->to;
      ep->can_eliminate = ep->can_eliminate_previous
	= (targetm.can_eliminate (ep->from, ep->to)
	   && ! (ep->to == STACK_POINTER_REGNUM
		 && frame_pointer_needed
		 && (! SUPPORTS_STACK_ALIGNMENT
		     || ! stack_realign_fp)));


Then I tried like below:

bool rl78_target_can_eliminate(int from, int to)
{
  assert(from == ARG_POINTER_REGNUM);
  assert(to == STACK_POINTER_REGNUM);
  frame_pointer_needed = false;           // This was also required.
                                          // And not so good.
  return true;
}

#undef TARGET_CAN_ELIMINATE
#define TARGET_CAN_ELIMINATE rl78_target_can_eliminate

Then I could make `can_eliminate' true. And more, added below for
calculation of offset:

int rl78_frame_pointer_cfa_offset(tree);
#define FRAME_POINTER_CFA_OFFSET(FUN) rl78_frame_pointer_cfa_offset(FUN)

2022.02.18 10:24 build started

I cancelled above fix and fixed like below:

int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)

Then for the code

int f(int a, int b)
{
  return a + b;
}

`a' and `b' became to be `sp' relative not to be `ap' relative.

At this point, .debug_info section was still incorrect:

 <2><c1>: Abbrev number: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 91 84 1 	(DW_OP_fbreg: 132)
 <2><cf>: Abbrev number: 6 (DW_TAG_formal_parameter)     ^^^^^^^^^^^
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 91 86 1 	(DW_OP_fbreg: 134)
 <2><dd>: Abbrev number: 7 (DW_TAG_variable)             ^^^^^^^^^^^^
    <de>   DW_AT_name        : c
    <e0>   DW_AT_decl_file   : 1
    <e1>   DW_AT_decl_line   : 5
    <e2>   DW_AT_decl_column : 8
    <e3>   DW_AT_type        : <0xec>
    <e7>   DW_AT_location    : 3 byte block: 92 20 0 	(DW_OP_bregx: 32 (r32) 0


`DW_OP_fbreg' was wrong, `DW_OP_bregx : 32' was correct.

現状 USE_LRA を define しているが袋工事に入った感じがする.

一旦
#define USE_LRA
を削除する.

static dw_loc_descr_ref
based_loc_descr (rtx reg, poly_int64 offset,
		 enum var_init_status initialized)
{

が呼び出された時点では reg = ap で offset = 4 なのだからここまでは期待した
動作であるし, この呼び出し前に offset = 132 のように変更するのは間違い.


  if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)
    {
      rtx elim = (ira_use_lra_p
		  ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)
		  : eliminate_regs (reg, VOIDmode, NULL_RTX));

      if (elim != reg)
        {
 	  ...
	}
    }


  regno = REGNO (reg);


のようになっているから elim で stack_pointer_rtx が戻るのが少くとも必要.
と思ったが,


  HOST_WIDE_INT const_offset;
  if (!optimize && fde
      && (fde->drap_reg == regno || fde->vdrap_reg == regno)
      && offset.is_constant (&const_offset))
    {
      /* Use cfa+offset to represent the location of arguments passed
	 on the stack when drap is used to align stack.
	 Only do this when not optimizing, for optimized code var-tracking
	 is supposed to track where the arguments live and the register
	 used as vdrap or drap in some spot might be used for something
	 else in other part of the routine.  */
      return new_loc_descr (DW_OP_fbreg, const_offset, 0);  これ
    }


オリジナルの cc1

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 37

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r37 at cfa-4  これを試してみる.
  DW_CFA_nop
  DW_CFA_nop


以下を追加

#define INCOMING_FRAME_SP_OFFSET		4

フレームポインタないからこういうのはあまり好きではないが

変更前は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 0
  DW_CFA_offset: r36 at cfa+0

変更後は

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -1
  Return address column: 36

  DW_CFA_def_cfa: r32 ofs 4
  DW_CFA_offset: r36 at cfa-4

なのでここは予定通り.
ここは USE_LRA を削除しているから現状は以下

 <2><c1>: 省略番号: 6 (DW_TAG_formal_parameter)
    <c2>   DW_AT_name        : a
    <c4>   DW_AT_decl_file   : 1
    <c5>   DW_AT_decl_line   : 3
    <c6>   DW_AT_decl_column : 11
    <c7>   DW_AT_type        : <0x7f>
    <cb>   DW_AT_location    : 3 byte block: 92 20 4 	(DW_OP_bregx: 32 (r32) 4)
 <2><cf>: 省略番号: 6 (DW_TAG_formal_parameter)
    <d0>   DW_AT_name        : b
    <d2>   DW_AT_decl_file   : 1
    <d3>   DW_AT_decl_line   : 3
    <d4>   DW_AT_decl_column : 18
    <d5>   DW_AT_type        : <0x7f>
    <d9>   DW_AT_location    : 3 byte block: 92 20 6 	(DW_OP_bregx: 32 (r32) 6)

当初の予定とは違ったが, 一度 USE_LRA を define した. そして

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;  // もともとは -get_frame_size() にしていた
}

のように修正したところ, 期待通り rl78-elf-gdb が動作している.

2022.02.18 17:18

% tar cf rl78-elf.mine.tar gcc/config/rl78 gcc/common/config/rl78

のようにして一旦現状をバックアップしておいた.

2022.02.18 17:20

#ifdef USE_LRA
int rl78_arg_pointer_cfa_offset(tree);
#define ARG_POINTER_CFA_OFFSET(FUN) rl78_arg_pointer_cfa_offset(FUN)
#endif

上を削除

int rl78_arg_pointer_cfa_offset(tree)
{
  return 0;
}

上を削除

そしてリビルド. 2022.02.18 18:24 正常動作を確認.


