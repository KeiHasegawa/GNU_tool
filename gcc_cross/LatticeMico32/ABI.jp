LatticeMico32 の ABI

(*0) レジスタの別名
(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数


(*0) レジスタの別名

	gp : r26
     	fp : r27
     	sp : r28
     	ra : r29

(*1) 函数呼び出し

	calli    func

	疑似コード
	
	ra = (calli 命令の次のアドレス)
	pc = func


(*2) 函数復帰

	b        ra

(*3) プロローグ

	addi     sp, sp, -140
	sw       (sp+8), fp
	sw       (sp+4), ra
	or       fp, sp, r0
	addi     fp, fp, 140

	+------------------+ <- sp_{new}
	|                  |
	+------------------+ +4
	|     ra_{old}     |
	+------------------+ +8
	|     fp_{old}     |
	+------------------+ +12
	|                  |
	|                  |
	|    local area    |
	|                  |
	|                  |
	+------------------+ <- sp_{old}, fp_{new}

        上は 128 バイトのローカルエリアを使用する函数のプロローグである.

(*4) エピローグ


	lw       fp, (sp+8)
	lw       ra, (sp+4)
	addi     sp, sp, 140
	b        ra

	上は 128 バイトのローカルエリアを使用する函数のエピローグである.
	fp, ra, sp が復元され呼び出し元に復帰する.

(*5) 通常の函数の引数と戻り値

        第 1 引数 : r1
	...
        第 8 引数 : r8
	第 9 引数 : 4 バイト開けてスタックを使用


	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
	      int a8, int a9);

        f(10, 11, 12, 13, 14, 15, 16, 17, 18, 19);

	に対して f の先頭アドレスでは

	r1 = 10, r2 = 11, ..., r8 = 17


	+------------------+ <- sp
	|                  |
	+------------------+ +4
	|       18         |
	+------------------+ +8
	|       19         |
	+------------------+ +12
	|     ra_{old}     |
	+------------------+ +16

	ra_{old} は f を呼び出した函数の戻りアドレス.

	のようになっている.
	函数の戻り値は r1 にセットされる.
	
(*6) long long を引数にとる函数, 返す函数


	sizeof(long long) = 8

	long long の引数に対してレジスタが 2 つ使用され残りはスタックを使用する. 但し
	r8 レジスタとスタックをまたいで使用することはなく, その場合はスタックを使用する.
	例えば

	long long
	f(int a0, long long a1, long long a2, long long a3, long long a4);

	f(10, 11LL, 12LL, 0x123456789abcdef0LL, 0x1122334455667788LL);

	に対して f の先頭アドレスでは

	r1 = 10, r2 = 0, r3 = 11, r4 = 0, r5 = 12,
	r6 = 0x12345678, r7 = 0x9abcdef0
	

	+------------------+ <- sp
	|                  |
	+------------------+ +4
	|    0x11223344    |
	+------------------+ +8
	|    0x55667788    |
	+------------------+ +12
	|     ra_{old}     |
	+------------------+ +16

	ra_{old} は f を呼び出した函数の戻りアドレス.

	のようになっている.
	函数の戻り値は r1 と r2 にセットされる.

(*7) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

	LatticeMico32 には FPU がないのでソフトウェアで浮動少数点数演算を行なう.
	float に対しては (*5) の規則が, double, long double に対しては
	(*6) の規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すとき, 引数に使用されるレジスタ r1, ..., r8
	がまだ全て使用されておらず, 構造体が残りのレジスタで収まるのであればレジスタ
	が使用される. だから第一引数の構造体が 32 バイト以下であればレジスタで
	渡される.

	残りのレジスタで収まらないのであればレジスタは使用せずスタックにコピーを作成
	する. これ以降の引数に対しては型に関係なくレジスタは使用されない.
	
	例えば

	struct S { int i[9]; };
	void f(struct S s, int a0, int a1, int a2);

	struct S s = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	f(s, 10, 11, 12);

	に対して f の先頭アドレスでは

	+------------------+ <- sp
	|                  |
	+------------------+ +4
	|         1        |
	+------------------+ +8
	|         2        |
	+------------------+ +12
	|                  |
	       .......
	|                  |
	+------------------+
	|         9        |
	+------------------+ +40
	|        10        |
	+------------------+ +44
	|        11        |
	+------------------+ +48
	|        12        |
	+------------------+ +52
	|     ra_{old}     |
	+------------------+ +56

	ra_{old} は f を呼び出した函数の戻りアドレス.

        のようになっている.

	構造体を返す函数を呼び出すとき r1 レジスタに戻り値を格納するアドレスがセットされる.
