テストツール

オペコード   機能
----------+----------
halt      | exit(1)
0x5959    | printf
0x595a    | puts
0x595b    | putchar

現状の問題点

o double, long double の変数を正しく表示できていない.
o スタックのアドレスが 64 KB に限定されて動作している.
o よもやコンパイラの問題ではないと思うのだが

  char a[] = "hasegawa kei";

  として &a[0] を表示したときに以下のように化けている:

\314ase\314awa\314kei
  

そしてテストツールとは別にアセンブラレベルで sample.elf をデバッグしているが main  
のブレークポイントが機能していない.

  => main のブレークポイントが機能しない理由は

main:
	.word 0           ★
	subl2 $20,%sp
...

     C 言語レベルでは vax-elf-gdb がこの部分を調整してくれていたが, アセンブラレベル
     ではこの調整はプログラマが自分で行なう必要がある.


まずは double を正しく表示できない原因を調査する.

函数に引数 1.0 を渡すコードは以下 

	movd $0d1.0e+0,-(%sp)

(vax-elf-gdb) x/8bx $sp
0xffd8:	0x80	0x40	0x00	0x00	0x00	0x00	0x00	0x00  ★
(vax-elf-gdb) p *(double*)($sp)
$3 = 1          ★
(vax-elf-gdb)

見慣れないダンプの結果であるが vax-elf-gdb では 1 と表示できている.

リトルエンディアンであれば以下のような並びになっているはず:

        0x00	0x00	0x00	0x00	0x00	0x00	0xf0	0x3f

VAX はビッグエンディアンなので

        0x3f	0xf0	0x00	0x00	0x00	0x00	0x00	0x00

が期待値(?)だが実際はこれとは違っている. つまり通常の IEE754 の浮動小数点数フォーマット
とは異なるものということ.

double d = 1.0;

に対して vax-elf-gcc は以下のコードを生成している:

d:
	.long	16512
	.long	0

16512 = 0x4080 なのでやはり自分の知っている 1.0 のビット表現ではない.
