(*1) arm-elf-gcc gcc-4.6.0 インストール
(*2) そのまま -O2 ビルドした場合に発生するエラー
(*3) gcc-4.6.0 をネイティブコンパイラとしてインストールできるか確認した結果 => OK
(*4) gcc-4.5.4 と gcc-4.6.0 とのターゲット依存部分の差分

(*1) arm-elf-gcc gcc-4.6.0 インストール

% bunzip2 -c ../gcc-4.6.0.tar.bz2 | tar xf -
% mv gcc-4.6.0 gcc-4.6.0.arm-elf
% cd gcc-4.6.0.arm-elf
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=arm-elf --with-newlib
% patch -p1 < ../gcc-4.5.4.arm-elf.diff
% cat ../erase_O2
#! /bin/csh -f

sed -e 's/O2/O0/g' $argv[1] > $argv[1].$$
mv $argv[1].$$ $argv[1]
chmod +x $argv[1]
% chmod +x ../erase_O2
% find . -name 'Makefile.*' -exec ../erase_O2 {} \;
% find . -name 'configure' -exec ../erase_O2 {} \;
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=arm-elf --with-newlib
% make all-gcc
% make maybe-configure-target-libgcc
% make maybe-all-target-libgcc
% make install-gcc
% make maybe-install-target-libgcc

エラー回避のポイントは cc1 を -O2 ではなくて -O0 でビルドすること.

(*2) そのまま -O2 ビルドした場合に発生するエラー

...
gcc -c   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    gtype-desc.c -o gtype-desc.o
...
gtype-desc.c:8829:18: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 8829 |     sizeof (x_rtl[0]),
 ...
%

のようにエラーになってしまう. gtype-desc.c は生成されるファイルで, その生成方法は
分かりにくいが

build/gengtype -r gtype.state

のようにして生成する.

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/gcc/gengtype.c

    gtype_desc_c = create_file ("GCC", "gtype-desc.c");
    for (ifp = ifiles; *ifp; ifp++)
      oprintf (gtype_desc_c, "#include \"%s\"\n", *ifp);


gentype.c を -O2 ビルドしてしまうとこのように build/gentype が意図しない動作になってしまう.
しかし残念ながらこの


(*3) gcc-4.6.0 をネイティブコンパイラとしてインストールできるか確認した結果 => OK

% bunzip2 -c gcc-4.6.0.tar.bz | tar xf -
% cd gcc-4.6.0
% ./configure
% make
一部 .info ファイルの生成でエラーするが, この部分を

doc/%.info:
	touch $@

のようにすることで回避は可能. 結果は OK.

gtype-desc.c

でコンパイルエラーは発生しない.

(*4) gcc-4.5.4 と gcc-4.6.0 とのターゲット依存部分の差分

diff -r /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-{4.5.4,4.6.0}.arm-elf/gcc/config/arm > a

とすればかなりの差分が出ていることが確認できる.

             diff 合計
aarch64       N/A
arm         14623
avr           754
bfin          462
cr16          N/A
cris          479
frv          1660
ft32          N/A
h8300         514
iq2000        493
lm32          230
m32c         1167
m32r          812
mcore         411
microblaze    N/a 
mips         2638
mn10300      8589
moxie         225
msp430        N/A
or1k          N/A
ppc           N/A
pru           N/A
rl78          N/A
rx            951
sh           1682
v850         4716

この結果からすると 4.5.4 と 4.6.0 との間で何らかの対応が必要だったことが分かる.
lm32 の差分が最も少ない.

% pwd
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf
% cd gcc/config
% ls -d arm*
arm/  arm.4.5.4/
% mv arm arm.org
% ln -s arm.4.5.4 arm
% ls -d arm*
arm@  arm.4.5.4/  arm.org/

これでビルドしてみたところ以下のエラーが発生:

gcc -c   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -DGENERATOR_FILE -I. -Ibuild -I../.././gcc -I../.././gcc/build -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    \
	-o build/genflags.o ../.././gcc/genflags.c
In file included from ./tm.h:22,
                 from ../.././gcc/genflags.c:27:
../.././gcc/config/arm/arm.h:452:9: エラー: 汚染された 'CAN_DEBUG_WITHOUT_FP' 使おうとしています
  452 | #define CAN_DEBUG_WITHOUT_FP


arm.h から

#pragma GCC poison

の対象になっているマクロを削除した.

さらにビルドを続行したところ以下のエラーが発生:


gcc -c  -DIN_GCC_FRONTEND -DIN_GCC_FRONTEND -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber   \
	../.././gcc/config/arm/arm-c.c
...	
../.././gcc/config/arm/arm-c.c:26:10: 致命的エラー: c-common.h: そのようなファイルやディレクトリはありません
   26 | #include "c-common.h"
      |          ^~~~~~~~~~~~
コンパイルを停止しました。

gcc-4.6.0.arm-elf/gcc/config/arm.4.5.4/arm-c.c

を以下のように修正

#include "c-family/c-common.h"

さらにビルドを続行したところ以下のエラーが発生:

gcc -c   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    insn-attrtab.c -o insn-attrtab.o
...
In file included from tm.h:14,
                 from insn-attrtab.c:7:
options.h:225:36: エラー: token "." is not valid in preprocessor expressions
  225 | #define target_flags global_options.x_target_flags
      |                                    ^
options.h:3453:24: 備考: in expansion of macro ‘target_flags’
 3453 | #define TARGET_THUMB ((target_flags & MASK_THUMB) != 0)
      |                        ^~~~~~~~~~~~
../.././gcc/config/arm/arm.h:199:44: 備考: in expansion of macro ‘TARGET_THUMB’
  199 | #define TARGET_ARM                      (! TARGET_THUMB)
      |                                            ^~~~~~~~~~~~
../.././gcc/config/arm/arm.h:826:4: 備考: in expansion of macro ‘TARGET_ARM’
  826 |   (TARGET_ARM     \
      |    ^~~~~~~~~~
../.././gcc/rtl.h:2031:4: 備考: in expansion of macro ‘HARD_FRAME_POINTER_REGNUM’
 2031 |   (HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM)
      |    ^~~~~~~~~~~~~~~~~~~~~~~~~
../.././gcc/rtl.h:2052:5: 備考: in expansion of macro ‘HARD_FRAME_POINTER_IS_FRAME_POINTER’
 2052 | #if HARD_FRAME_POINTER_IS_FRAME_POINTER
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
...

これは見なれないエラーだが

#if HARD_FRAME_POINTER_IS_FRAME_POINTER

の部分にマクロ展開されているものが C の構造体の変数のメンバ参照になっているから
このようなエラーになっている.

gcc-4.6.0.arm-elf/gcc/config/arm.org/arm.h

を参考にすれば

#define HARD_FRAME_POINTER_IS_FRAME_POINTER 0
#define HARD_FRAME_POINTER_IS_ARG_POINTER 0

を

gcc-4.6.0.arm-elf/gcc/config/arm.4.5.4/arm.h

に追加するのが正しい.
さらにビルドを続行:

gcc -c   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    gtype-desc.c -o gtype-desc.o
...
gtype-desc.c: トップレベル:
gtype-desc.c:8817:18: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 8817 |     sizeof (x_rtl[0]),
      |                  ^
gtype-desc.c:8936:36: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 8936 |     sizeof (default_target_libfuncs[0]),
      |                                    ^
gtype-desc.c:9020:31: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 9020 |     sizeof (default_target_rtl[0]),
      |                               ^
gtype-desc.c:9041:31: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 9041 |     sizeof (default_target_rtl[0]),
      |                               ^
gtype-desc.c:9048:31: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 9048 |     sizeof (default_target_rtl[0]),
      |                               ^
gtype-desc.c:9055:31: エラー: 添字が付けられた値が、配列、ポインタまたはベクトルではありません
 9055 |     sizeof (default_target_rtl[0]),
      |                               ^


これは...前のバージョンに戻したのだが arm.org と同じエラーが出ている.

おそらく以下が期待値:
  {
    &x_rtl.eh.call_site_record[0],
    1 * (2),
+   sizeof (x_rtl.eh.call_site_record[0]),
    &gt_ggc_mx_VEC_call_site_record_gc,
    &gt_pch_nx_VEC_call_site_record_gc
  },
...
  {
    &default_target_libfuncs.x_libfunc_table[0],
    1 * (LTI_MAX),
+   sizeof (default_target_libfuncs.x_libfunc_table[0]),
    &gt_ggc_mx_rtx_def,
    &gt_pch_nx_rtx_def
  },
...
  {
    &default_target_rtl.x_global_rtl[0],
    1 * (GR_MAX),
+   sizeof (default_target_rtl.x_global_rtl[0]),
    &gt_ggc_mx_rtx_def,
    &gt_pch_nx_rtx_def
  },
...
  {
    &default_target_rtl.x_initial_regno_reg_rtx[0],
    1 * (FIRST_PSEUDO_REGISTER),
+   sizeof (default_target_rtl.x_initial_regno_reg_rtx[0]),
    &gt_ggc_mx_rtx_def,
    &gt_pch_nx_rtx_def
  },
...
  {
    &default_target_rtl.x_static_reg_base_value[0],
    1 * (FIRST_PSEUDO_REGISTER),
+   sizeof (default_target_rtl.x_static_reg_base_value[0]),
    &gt_ggc_mx_rtx_def,
    &gt_pch_nx_rtx_def
  },

gengtype.o を以下のように -O2 なしでビルドしたところ期待通り動作している.

gcc -c   -g3 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -DGENERATOR_FILE -I. -Ibuild -I../.././gcc -I../.././gcc/build -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    -o build/gengtype.o ../.././gcc/gengtype.c  || exit 1

gcc   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -DGENERATOR_FILE  -o build/gengtype \
    build/gengtype.o build/errors.o build/gengtype-lex.o build/gengtype-parse.o build/gengtype-state.o build/version.o ../../build-i686-pc-linux-gnu/libiberty/libiberty.a || exit 1
    

上のように修正してさらにビルドを続行:

gcc -c   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H -I. -I. -I../.././gcc -I../.././gcc/. -I../.././gcc/../include -I../.././gcc/../libcpp/include  -I../.././gcc/../libdecnumber -I../.././gcc/../libdecnumber/dpd -I../libdecnumber    \
	../.././gcc/config/arm/arm.c -o arm.o

#include "c-pragma.h"

インクルードできなくてエラー. 以下のように修正

#include "c-family/c-pragma.h"

さらにビルドを続行すると以下のエラー:


gcc   -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-format-attribute -pedantic -Wno-long-long -Wno-variadic-macros -Wno-overlength-strings -Wold-style-definition -Wc++-compat   -DHAVE_CONFIG_H  -o cc1 c-lang.o c-family/stub-objc.o attribs.o c-errors.o c-decl.o c-typeck.o c-convert.o c-aux-info.o c-objc-common.o c-parser.o tree-mudflap.o c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o c-family/c-format.o c-family/c-gimplify.o c-family/c-lex.o c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o c-family/c-semantics.o c-family/c-ada-spec.o arm-c.o \
  cc1-checksum.o main.o  libbackend.a ../libcpp/libcpp.a ../libdecnumber/libdecnumber.a ../libcpp/libcpp.a   ../libiberty/libiberty.a ../libdecnumber/libdecnumber.a    -lmpc -lmpfr -lgmp -rdynamic -ldl  -L../zlib -lz
/usr/local/lib/gcc/i686-pc-linux-gnu/10.2.0/../../../../i686-pc-linux-gnu/bin/ld: libbackend.a(arm.o): in function `thumb_pushpop':
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/../.././gcc/config/arm/arm.c:18568: undefined reference to `arm_except_unwind_info'
...

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/gcc/config/arm.4.5.4/arm.c に以下を追加

static enum unwind_info_type
arm_except_unwind_info (struct gcc_options *opts)
{
...

のように修正すれば make all-gcc が正常終了する.

make maybe-configure-target-libgcc

エラーになる.

configure:3028:  /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/sys-include    -V >&5
xgcc: error: unrecognized option '-V'
xgcc: fatal error: no input files
compilation terminated.
configure:3039: $? = 1

-V オプションが受け付けられないらしい.

しかし

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/gcc-4.6.0/i686-pc-linux-gnu/libgcc/config.log

でもやはり同じ結果. これが原因でエラーしているわけではないらしい.

% /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/sys-include    -c -g -O2  a.c
a.c:1:0: internal compiler error: セグメンテーション違反です
完全なバグ報告を送って下さい。
適切ならばプリプロセス後のソースをつけてください。
<http://gcc.gnu.org/bugs.html> を見れば方法が書いてあります。
%

そもそもできていないらしい. configure でエラーしているから, 少なくとも gcc-4.6.0 で
エラー回避したほうがむしろできていたように思える.

gdb から cc1 を実行してみた:


(gdb) run a.c
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/cc1 a.c

Program received signal SIGSEGV, Segmentation fault.
0x082d4c39 in init_reg_modes_target () at ../.././gcc/reginfo.c:572
(gdb)

以下の部分を実行して不正メモリアクセスが発生している:

      hard_regno_nregs[i][j] = HARD_REGNO_NREGS(i, (enum machine_mode)j);

この部分をプリプロセスした結果は以下.

      ((&default_target_regs)->x_hard_regno_nregs)[i][j] = ((((! ((global_options.x_target_flags & (1 << 14)) != 0)) || arm_arch_thumb2) && i >= 16 && i != 25 && i != 26) && !(((i) >= 63) && ((i) <= (((arm_fpu_desc->model == ARM_FP_MODEL_VFP) && arm_fpu_desc->regs == VFP_REG_D32) ? 126 : 94))) ? 1 : (((((unsigned short) mode_size[(enum machine_mode)j])) + 4 - 1) / 4));

HARD_REGNO_NREGS の定義は以下:

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/gcc/config/arm/arm.h
932: #define HARD_REGNO_NREGS(REGNO, MODE)  	\


arm_fpu_desc が 0 で arm_fpu_desc->regs を参照して不正メモリアクセスエラーしているという
こと.

この変数は gcc-4.5.4 では arm_override_options で以下のようにセットされていた:

Hardware watchpoint 2: arm_fpu_desc

Old value = (const struct arm_fpu_desc *) 0x0
New value = (const struct arm_fpu_desc *) 0x86cb518 <all_fpus+24>
arm_override_options () at ../.././gcc/config/arm/arm.c:1650
(gdb) where
#0  arm_override_options () at ../.././gcc/config/arm/arm.c:1650
#1  0x08320e25 in process_options () at ../.././gcc/toplev.c:1814
#2  do_compile () at ../.././gcc/toplev.c:2401
#3  toplev_main (argc=<optimized out>, argv=<optimized out>) at ../.././gcc/toplev.c:2459
#4  0x080c3d0b in main (argc=2, argv=0xbffff5e4) at ../.././gcc/main.c:35
(gdb)

gcc-4.6.0 では単純に arm_override_options が呼び出されていない.

呼び出す方法が変更されたらしい.

gcc-4.5.4 では


#define OVERRIDE_OPTIONS  arm_override_options ()
...
#ifdef OVERRIDE_OPTIONS
  OVERRIDE_OPTIONS;
#endif

gcc-4.6.0 では

  /* Some machines may reject certain combinations of options.  */
  targetm.target_option.override ();

これは C++ のメンバ函数呼び出しではなくて C のメンバ函数呼び出し.


gcc-4.6.0 を通常通りビルドしたもので試すと

  targetm.target_option.override は main 函数が呼び出された時点で既に

  arm_option_override

になっている. これは arm.c で初期化指定子で指定されている.

struct gcc_target targetm = TARGET_INITIALIZER;

そして TARGET_INITIALIZER は target-hooks-def.h で定義されていて, このファイルは
自動生成されるファイル.

これのカラクリは

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/gcc/config/arm.4.5.4/arm.c

に

static void arm_option_override (void);
...
#undef  TARGET_OPTION_OVERRIDE
#define TARGET_OPTION_OVERRIDE arm_option_override
...
static void
arm_option_override (void)
{
...
}

とすることで回避できる. これで

targetm.target_option.override ();

の呼び出しが arm_option_override の呼び出しになる. これで改めて cc1 をビルドする.
そして libgcc をビルドすると, gcc-4.6.0 と同じように _negdi2.o のビルドでエラーする.

ということは...

gcc-4.5.4 のときの _negdi2.o のビルドと gcc-4.6.0 + arm.4.5.4 とのビルドとを
比較すればよいということになる.

gcc-4.5.4 の cc1 を gdb から動作して, _negdi2.o のビルドで正常終了している.

gcc-4.6.0 は函数 record_object_conflict でエラーしているが, そもそも
gcc-4.5.4 ではこの函数は定義されていない.

しかし build_conflict_bit_table はどちらのバージョンでも定義されている.
そしてこの函数は gcc-4.5.4 では 1 回だけ呼び出されている.

問題の箇所は以下:

gcc-4.5.4:
	      if (ira_reg_classes_intersect_p
		  [cover_class][ALLOCNO_COVER_CLASS (live_a)]
		  /* Don't set up conflict for the allocno with itself.  */
		  && num != (int) j)
		{
		  SET_ALLOCNO_SET_BIT (conflicts[num],
				       ALLOCNO_CONFLICT_ID (live_a),
				       ALLOCNO_MIN (allocno),
				       ALLOCNO_MAX (allocno));
		  SET_ALLOCNO_SET_BIT (conflicts[j], id,
				       ALLOCNO_MIN (live_a),
				       ALLOCNO_MAX (live_a));
		}


gcc-4.6.0:
	      if (ira_reg_classes_intersect_p[cover_class][live_cover_class]
		  /* Don't set up conflict for the allocno with itself.  */
		  && live_a != allocno)
		{
		  record_object_conflict (obj, live_obj);
		}


struct ira_object という構造体が大幅に変更されているので簡単に 4.5.4 のものに
戻すのが難しい.

ところでこのループの先頭に来た時点で

gcc-4.5.4 : ira_max_point = 23 -> 11
gcc-4.6.0 : ira_max_point = 19 -> 8

のように少し違っている. そういうものなのか.

typedef int DItype __attribute__ ((mode (DI)));

typedef unsigned int USItype __attribute__ ((mode (SI)));

typedef int SItype __attribute__ ((mode (SI)));

struct DWstruct {SItype low, high;};

typedef union
{
  struct DWstruct s;
  DItype ll;
} DWunion;

DItype
__negdi2 (DItype u)
{
  const DWunion uu = {.ll = u};
  const DWunion w = { {.low = -uu.s.low,
         .high = -uu.s.high - ((USItype) -uu.s.low > 0) } };

  return w.ll;
}

上のソースで再現する. 単純にオプションなしで実行すれば
gcc-4.6.0 + arm.4.5.4 で正常終了する. しかし

run -g -O2 a.c

のように -g -O2 を指定すればバグが再現する. そもそも問題の箇所は -O2 を指定しないと
来ない.
ということは, ... 最適化のオプションの部分が関係している可能性はある.


以下は他のバージョンでインストールを試してみた結果.

gcc-3.4.4 はすでにビルドとインストールができている.

gcc-3.4.6 : OK

gcc-4.0.0 : NG => OK 

エラーの症状:

make[1]: *** 'regex.o' に必要なターゲット '../include/ansidecl.h' を make するルールがありません.  中止.

=> Makefile に誤りがある

INCDIR=../../include

とすれば回避できている.

さらにビルドを実行するとエラーするが

cp install-sh build-i686-pc-linux-gnu
cp config.sub build-i686-pc-linux-gnu

とすれば回避できている.

2021.10.01 18:00 gcc-4.0.0 でビルド & インストール完了.

gcc-4.9.4 : NG

エラーの症状
*** Configuration arm-unknown-elf not supported

gcc-4.0.1 : NG => OK

エラーの症状

./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=arm-elf --with-newlib
...
configure: error: Building in the source directory is not supported in this release. See http://gcc.gnu.org/install/configure.html for more details.
exit 1

mkdir build
cd build
../configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=arm-elf --with-newlib

とすれば回避できている.

エラーの症状(その2)

../../gcc/toplev.c:547:1: エラー: ‘floor_log2’ が再定義されました

   => gcc-4.0.0 と同じ対処を行なう.
   /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.0.1.arm-elf/gcc/toplev.c
   から floor_log2 と exact_log2 の定義をコンパイルアウトする.
         => これだとエラーするようである.
   /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.0.1.arm-elf/gcc/toplev.h から floor_log2 と exact_log2 の定義をコンパイルアウトする.
         => これでもエラーする.
	 => 一度, *.o を削除してビルドすれば OK

gcc-4.2.0 : OK

gcc-4.2.4 : OK

gcc-4.3.0 : NG => OK

         一番の原因は 4.2.4 までの方法だと libgcc.a がビルドされていない.
	 回避策はあるが, まだ確立していない.

gcc-4.4.0 : NG => OK

	 gcc-4.2.4 までの方法と同じ方法で

	 make all-gcc

	 まで行なう.

	 libgcc/Makefile.in

	 を 03_newer_batch と同じ修正を行なう.

make maybe-configure-target-libgcc
make maybe-all-target-libgcc
make install-gcc
make maybe-install-target-libgcc

gcc-4.5.0 : NG  => OK

	  gcc-4.4.0 の方法と

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.5.0.arm-elf/gcc/cp/cfns.gperf

から以下のように isalpha をコメントアウトすることで成功する.

#isalpha

gcc-4.6.0 :

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/gtype-desc.c

で

sizeof ( xxxx[0])

でエラーになるが回避できている. gypte-desc.c はおそらく md ファイルから生成されている.

しかし gcc-4.5.0 では発生していなかった
libgcc のビルドで以下のエラーが発生している.

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/xgcc -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/bin/ -B/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/lib/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/sys-include    -g -O2 -mthumb -O2  -g -O2 -DIN_GCC -DCROSS_DIRECTORY_STRUCTURE  -W -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition  -isystem ./include  -fno-inline -Wno-missing-prototypes -g  -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED -fno-stack-protector -Dinhibit_libc  -I. -I. -I../../../host-i686-pc-linux-gnu/gcc -I../../.././libgcc -I../../.././libgcc/. -I../../.././libgcc/../gcc -I../../.././libgcc/../include  -DHAVE_CC_TLS  -o _negdi2.o -MT _negdi2.o -MD -MP -MF _negdi2.dep -DL_negdi2 -c ../../.././libgcc/../gcc/libgcc2.c \


../../.././libgcc/../gcc/libgcc2.c: In function ‘__negdi2’:
../../.././libgcc/../gcc/libgcc2.c:72:1: internal compiler error: セグメンテーション違反です
完全なバグ報告を送って下さい。
適切ならばプリプロセス後のソースをつけてください。
<http://gcc.gnu.org/bugs.html> を見れば方法が書いてあります。
make[3]: *** [Makefile:377: _negdi2.o] エラー 1
make[3]: ディレクトリ '/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/arm-elf/thumb/libgcc' から出ます
make[2]: *** [Makefile:1007: multi-do] エラー 1
make[2]: ディレクトリ '/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/arm-elf/libgcc' から出ます
make[1]: *** [Makefile:110: all-multi] エラー 2
make[1]: ディレクトリ '/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/arm-elf/libgcc' から出ます
make: *** [Makefile:13045: all-target-libgcc] エラー 2

gdb から cc1 を実行してバグを再現できている.

M-x gdb
gdb --annotate=3 cc1

(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/arm-elf/thumb/libgcc
Working directory /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/arm-elf/thumb/libgcc.
(gdb) run  -quiet -I . -I . -I ../../../host-i686-pc-linux-gnu/gcc -I ../../.././libgcc -I ../../.././libgcc/. -I ../../.././libgcc/../gcc -I ../../.././libgcc/../include -imultilib thumb -iprefix /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/../lib/gcc/arm-elf/4.6.0/ -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/host-i686-pc-linux-gnu/gcc/include-fixed -MD _negdi2.d -MF _negdi2.dep -MP -MT _negdi2.o -D__USES_INITFINI__ -D IN_GCC -D CROSS_DIRECTORY_STRUCTURE -D IN_LIBGCC2 -D __GCC_FLOAT_NOT_NEEDED -D inhibit_libc -D HAVE_CC_TLS -D L_negdi2 -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/include -isystem /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/arm-elf/sys-include -isystem ./include ../../.././libgcc/../gcc/libgcc2.c -quiet -dumpbase libgcc2.c -mthumb -auxbase-strip _negdi2.o -g -g -g -O2 -O2 -O2 -Wextra -Wall -Wwrite-strings -Wcast-qual -Wstrict-prototypes -Wold-style-definition -Wno-missing-prototypes -fno-inline -fno-stack-protector -o /tmp/ccj6Pyug.s

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.6.0.arm-elf/gcc/ira-conflicts.c

を以下のように修正してみたが, 別のところでメモリアクセス違反が発生している.

#if 0
  SET_MINMAX_SET_BIT (conflicts[id1], id2, OBJECT_MIN (obj1),
		      OBJECT_MAX (obj1));
  SET_MINMAX_SET_BIT (conflicts[id2], id1, OBJECT_MIN (obj2),
		      OBJECT_MAX (obj2));
#else
  if (id2 >= OBJECT_MIN (obj1))
    SET_MINMAX_SET_BIT (conflicts[id1], id2, OBJECT_MIN (obj1),
			OBJECT_MAX (obj1));
  if (id1 >= OBJECT_MIN (obj2))
    SET_MINMAX_SET_BIT (conflicts[id2], id1, OBJECT_MIN (obj2),
			OBJECT_MAX (obj2));
#endif  

diff /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-4.{5,6}.0.arm-elf/gcc/config/arm/arm.md

としてみたところかなりの差分が出ている.

gcc-4.5.4 : OK

	  gcc-4.5.0 と同じやり方で正常に動作している.


gcc-4.7.0 : NG

checking if mkdir takes one argument... no
*** Configuration arm-unknown-elf is obsolete.
*** Specify --enable-obsolete to build it anyway.
*** Support will be REMOVED in the next major release of GCC,
*** unless a maintainer comes forward.
make: *** [Makefile:3801: configure-gcc] エラー 1
exit 1

make を実行したとき configure-gcc で上のようなエラーになる.
