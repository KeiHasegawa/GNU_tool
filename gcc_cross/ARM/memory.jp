ARM シミュレータのメモリ

メモリアクセスに対して最後には以下の函数が呼び出される:

static ARMword
GetWord (ARMul_State * state, ARMword address, int check)
{
...
static void
PutWord (ARMul_State * state, ARMword address, ARMword data, int check)
{
...

そしてメモリがまだ確保されていなければ自動的にメモリを割り当てる:

  if (pageptr == NULL)
    {
      pageptr = (ARMword *) malloc (PAGESIZE);

      if (pageptr == NULL)
	{
	  perror ("ARMulator can't allocate VM page");
	  exit (12);
	}

      *(pagetable + page) = pageptr;
    }

  return *(pageptr + offset);
}

このページにある memory.diff の修正を適用することで, 上をやめてプログラムのロード時
に .text, .rodata, .data, .bss にメモリを割り当てる. シミュレータのユーザは
ターゲットプログラムが使用するスタックの領域をメモリ割り当てする必要がある.

このパッチを適用してコンパイラのテストを実施してみると, .rodata の領域のサイズを少し超えて
読み出しアクセスする問題が発生してしまう. おそらく
コンパイラを作成した人は意図して行なっているとは思われるが, この仕様は良くないように思える.

#ifdef NEW_MEM_MAP
 	      if (s->flags & SEC_CODE)
 		set_code_area(lma, size);
	      else if (s->flags & SEC_READONLY)    // この対処 
		size = (size + 3) & (~0 << 2);     // は本来必要ない
	      sim_do_commandf(sd, "memory-region 0x%lx,0x%lx", lma, size);
#endif  // NEW_MEM_MAP


上の対処を入れても文字列を読み出すのに範囲を超えて読み出しアクセスしている.

