*** gdb-10.2.tmp/sim/mips/engine.c	2021-11-21 14:25:52.000000000 +0900
--- gdb-10.2.mips-elf/sim/mips/engine.c	2021-11-19 17:04:02.000000000 +0900
***************
*** 66,73 ****
    void *function_or_table;
  } idecode_table_entry;
  
  
! INLINE_ENGINE\
  (void) engine_run
  (SIM_DESC sd,
   int next_cpu_nr,
--- 66,245 ----
    void *function_or_table;
  } idecode_table_entry;
  
+ #include <assert.h>
+ #include <stdlib.h>
  
! static const char*
! first_string(SIM_DESC sd, sim_cpu* cpu, instruction_address cia)
! {
!   uint32_t r4 = cpu->registers[4];
!   static char buf[1024];
!   for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i ) {
!     char c = do_load(sd, cia, 0, AccessLength_BYTE, r4+i, 0);
!     buf[i] = c;
!     if (c == '\0')
!       return &buf[0]; // ok
!   }
!   assert(0 && "not enough buffer");
!   return &buf[0];
! }
! 
! enum arg_class { NONE, WORD, DW, DF, LDF, STR };
! 
! static const char* get_part(const char* fmt, enum arg_class* how)
! {
!   for ( ; *fmt ; ++fmt) {
!     char c = *fmt;
!     if (c == 'd' || c == 'i' || c == 'x' || c == 'u') {
!       if (*how == NONE)
! 	*how = WORD;
!       return ++fmt;
!     }
!     if (c == 'c') {
!       *how = WORD;
!       return ++fmt;
!     }
!     if (c == 'f') {
!       char prev = *(fmt-1);
!       *how = prev == 'L' ? LDF : DF;
!       return ++fmt;
!     }
!     if (c == 's') {
!       *how = STR;
!       return ++fmt;
!     }
!     if (c == 'l') {
!       if (*how == NONE)
! 	*how = WORD;
!       else
! 	*how = DW;
!     }
!   }
!   assert(0 && "unexpected");
!   return fmt;
! }
! 
! static unsigned int
! arg32(SIM_DESC sd, sim_cpu* cpu, instruction_address cia, int nth)
! {
!   assert(nth);
!   if (nth < 4)
!     return cpu->registers[nth+4];
!   int sp = cpu->registers[29];
!   int addr = sp + 4*nth;
!   return do_load(sd, cia, 0, AccessLength_WORD, addr, 0);
! }
! 
! static uint64_t
! arg64(SIM_DESC sd, sim_cpu* cpu, instruction_address cia, int nth)
! {
!   assert(nth);
!   assert(!(nth & 1));
!   if (nth < 3) {
!     uint64_t a = cpu->registers[nth+4];
!     uint32_t b = cpu->registers[nth+5];
!     return (a << 32) | b;
!   }
!   int sp = cpu->registers[29];  
!   int addr = sp + 4*nth;
!   uint64_t a = do_load(sd, cia, 0, AccessLength_WORD, addr, 0);
!   uint32_t b = do_load(sd, cia, 0, AccessLength_WORD, addr+4, 0);
!   return (a << 32) | b;  
! }
! 
! static const char* handle(SIM_DESC sd, sim_cpu* cpu, instruction_address cia,
! 			  const char* fmt, int* nth, int* ret)
! {
!   char c = *fmt;
!   if (c != '%') {
!     putchar(c);
!     ++*ret;
!     return fmt+1;
!   }
!   const char* beg = fmt;
!   c = *++fmt;
!   if (c == '%') {
!     putchar(c);
!     ++*ret;
!     return fmt+1;
!   }
!   enum arg_class how = NONE;
!   const char* end = get_part(fmt, &how);
!   char part_fmt[256];
!   int n = end - beg;
!   assert(n + 1 < sizeof part_fmt/sizeof part_fmt[0]);
!   strncpy(&part_fmt[0], beg, n);
!   part_fmt[n] = '\0';
!   if (how == WORD) {
!     int arg = arg32(sd, cpu, cia, (*nth)++);
!     *ret += printf(part_fmt, arg);
!     return end;
!   }
!   if (how == DW) {
!     if (*nth & 1)
!       ++*nth;
!     uint64_t arg = arg64(sd, cpu, cia, *nth);
!     *nth += 2;
!     *ret += printf(part_fmt, arg);
!     return end;
!   }
!   if (how == DF || how == LDF) {
!     if (*nth & 1)
!       ++*nth;
!     union {
!       uint64_t i;
!       double d;
!     } u = { arg64(sd, cpu, cia, *nth) };
!     *nth += 2;
!     if (how == DF)
!       *ret += printf(part_fmt, u.d);
!     else
!       *ret += printf(part_fmt, (long double)u.d);
!     return end;
!   }
!   if (how == STR) {
!     uint32_t addr = arg32(sd, cpu, cia, (*nth)++);
!     char buf[256];
!     for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i) {
!       char c = do_load(sd, cia, 0, AccessLength_BYTE, addr+i, 0);
!       buf[i] = c;
!       if (c == '\0') {
! 	*ret += printf(part_fmt, &buf[0]);  // ok
! 	return end;
!       }
!     }
!     assert(0 && "not enough buffer");
!     return end;
!   }
!   asm("int3");
!   return end;
! }
! 
! static void do_printf(SIM_DESC sd, sim_cpu* cpu, instruction_address cia)
! {
!   const char* fmt = first_string(sd, cpu, cia);
!   int nargc = 1;
!   int ret = 0;
!   while (*fmt)
!     fmt = handle(sd, cpu, cia, fmt, &nargc, &ret);
!   cpu->registers[3] = ret;
! }
! 
! static void do_puts(SIM_DESC sd, sim_cpu* cpu, instruction_address cia)
! {
!   const char* arg = first_string(sd, cpu, cia);
!   int ret = puts(arg);
!   cpu->registers[3] = ret;  
! }
! 
! static void do_putchar(SIM_DESC sd, sim_cpu* cpu, instruction_address cia)
! {
!   uint32_t r4 = cpu->registers[4];
!   int ret = putchar(r4);
!   cpu->registers[3] = ret;  
! }
! 
! INLINE_ENGINE					\
  (void) engine_run
  (SIM_DESC sd,
   int next_cpu_nr,
***************
*** 101,106 ****
--- 273,287 ----
        instruction_address nia;
  
        instruction_word instruction_0 = IMEM32 (cia);
+       switch (instruction_0) {
+       case 0x7fffbee0: exit(0);
+       case 0x7fffbee1:
+ 	do_printf(sd, CPU, cia); cia += 4; instruction_0 = IMEM32(cia); break;
+       case 0x7fffbee2:
+ 	do_puts(sd, CPU, cia); cia += 4; instruction_0 = IMEM32(cia); break;
+       case 0x7fffbee3:
+ 	do_putchar(sd, CPU, cia); cia += 4; instruction_0 = IMEM32(cia); break;
+       }
  
  #if defined (ENGINE_ISSUE_PREFIX_HOOK)
        ENGINE_ISSUE_PREFIX_HOOK();
