pru-elf-gdb でブレークポイントがずれる件の調査

M-x gdb
gdb --annotate=3 ./gdb
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/test_pru.003
(gdb) run -q -x x test003.elf

で再現している.

単純に nop だけを配置した場合は問題ないが

	.text
start:
	nop
	ldi32	sp, stack
	call	%label(my_func)
end:
	nop
	
my_func:
	ret
	

のようなソースで再現している.

start は 0x100 番地に配置されていて
(pru-elf-gdb) b start
(pru-elf-gdb) run

に対して

0x100 番地を偽の命令

  static unsigned char break_inst[] = { 0xee, 0xdb, 0xba, 0x26 };

で変更するのが期待する動作. おそらくここはできていて


  sim_engine_halt(...);

で停止する. そしてデバッガから問い合わせがあったとき「ブレークポイントで停止した」
と回答するのが期待値.

今回の現象は 0x100 で停止したのにあたかも 0x104 で停止したかのようになっていること.
また単純な nop 命令では再現しないということ.

一応, 逆アセンブルの結果を確認した:

00000100 <start>:
 100:	12e0e0e0 	nop
 104:	241000e2 	ldi	sp, 4096
 108:	230044c3 	call	110 <my_func>

0000010c <end>:
 10c:	12e0e0e0 	nop

00000110 <my_func>:
 110:	20c30000 	ret

	ldi32	sp, stack

はもしかするとシンボル stack によって 1 命令だったり, 2 命令だったりするものなのかもしれない.

ライン情報は以下のようになっていた:

 Line Number Statements:
  [0x0000002a]  拡張命令コード 2: 設定アドレス 0x100
  [0x00000031]  Special opcode 7: advance Address by 0 to 0x100 and Line by 2 to 3
  [0x00000032]  行を 1 進め 4 とします
  [0x00000034]  PC を固定サイズ 0 分進め 0x100 とします
  [0x00000037]  コピー (view 1)
  [0x00000038]  行を 1 進め 5 とします
  [0x0000003a]  PC を固定サイズ 4 分進め 0x104 とします
  [0x0000003d]  コピー (view 2)
  [0x0000003e]  行を 2 進め 7 とします
  [0x00000040]  PC を固定サイズ 4 分進め 0x108 とします
  [0x00000043]  コピー (view 3)
  [0x00000044]  行を 5 進め 12 とします
  [0x00000046]  PC を固定サイズ 4 分進め 0x10c とします
  [0x00000049]  コピー (view 4)
  [0x0000004a]  PC を固定サイズ 4 分進め 0x110 とします
  [0x0000004d]  拡張命令コード 1: 列の終り

.debug_line セクションの内容:

CU: test003.S:
File name                            Line number    Starting address    View    Stmt
test003.S                                      3               0x100               x
test003.S                                      4               0x100       1       x
test003.S                                      5               0x104       2       x
test003.S                                      7               0x108       3       x
test003.S                                     12               0x10c       4       x
test003.S                                      -               0x110


「PC を固定サイズ 0 分進め 0x100 とします」は少し気にはなるができてはいるし, nop のみの
単純な場合は期待したように動作しているから今回のバグとは無関係かもしれない.

ひとまず gdb とシミュレータとのやりとりを確認する.

(gdb) b sim_engine_halt
(gdb) run
...
Thread 1 "gdb" hit Breakpoint 1, sim_engine_halt (sd=0x8bf9e80, last_cpu=0x8bfa248, next_cpu=0x0, cia=256, reason=sim_stopped, sigrc=66) at ./../common/sim-engine.c:62
(gdb)

cia = 256 = 0x100

なのでここはできている.

(gdb) b sim_stop_reason
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 2, sim_stop_reason (sd=0x8bf9e80, reason=0xbfffeeb4, sigrc=0xbfffeeb8) at ./../common/sim-reason.c:31
(gdb) n
(gdb) 
(gdb) 
(gdb) n
(gdb) p *reason
$1 = sim_stopped
(gdb) p *sigrc
$2 = 5
(gdb)

というわけでここは期待した動作.

(gdb) b sim_fetch_register
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 3, sim_fetch_register (sd=0x8bf9e80, rn=32, buf=0x8c03b40 "", length=4) at ./../common/sim-reg.c:32
(gdb)

rn = 32 は PC のレジスタ番号でこれを gdb が問い合わせることは期待した動作.

ここでシミュレータのソースが -O2 ビルドされていることに気付いたので -g3 -O0
ビルドした. そして上の動作確認を以下のようにして確認した:

(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x083e0f50 in sim_engine_halt at ./../common/sim-engine.c:62
	breakpoint already hit 1 time
2       breakpoint     keep y   0x083d7300 in sim_stop_reason at ./../common/sim-reason.c:31
	breakpoint already hit 1 time
3       breakpoint     keep y   0x083d7380 in sim_fetch_register at ./../common/sim-reg.c:32
	breakpoint already hit 1 time
(gdb) disa 3 
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
`/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb' has changed; re-reading symbols.
warning: File "/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb-gdb.gdb" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
warning: File "/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb -q -x x test003.elf
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/libthread_db.so.1".
warning: File "/usr/local/lib/libstdc++.so.6.0.28-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
[Detaching after vfork from child process 26012]
[New Thread 0xb7704b70 (LWP 26013)]
[New Thread 0xb6dffb70 (LWP 26014)]
Reading symbols from test003.elf...
Connected to the simulator.
Loading section .text, size 0x14 lma 0x100
Start address 0x100
Transfer rate: 160 bits in <1 sec.
Breakpoint 1 at 0x100: file test003.S, line 4.

Thread 1 "gdb" hit Breakpoint 1, sim_engine_halt (sd=0x8bf9e80, last_cpu=0x8bfa248, next_cpu=0x0, cia=256, reason=sim_stopped, sigrc=66) at ./../common/sim-engine.c:62
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 2, sim_stop_reason (sd=0x8bf9e80, reason=0xbfffeeb4, sigrc=0xbfffeeb8) at ./../common/sim-reason.c:30
(gdb) enable 3
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 3, sim_fetch_register (sd=0x8bf9e80, rn=32, buf=0x8c03b40 "", length=4) at ./../common/sim-reg.c:32
(gdb) n
(gdb) 
(gdb) s
pru_fetch_register (cpu=0x8bfa248, rn=32, memory=0x8c03b40 "", length=4) at interp.c:683
(gdb) n
(gdb) 
(gdb) 
(gdb) n
(gdb) p/x ival
$3 = 0x100
(gdb) n
(gdb) c
Continuing.

Breakpoint 1, start () at test003.S:4
4		ldi32	sp, stack
(pru-elf-gdb)

シミュレータは期待した動作をしているが, それではなぜ ft32-elf-gdb が 4 行目を
表示しているのか調査する.

(gdb) disa 3
(gdb) run
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb -q -x x test003.elf
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/libthread_db.so.1".
warning: File "/usr/local/lib/libstdc++.so.6.0.28-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
[Detaching after vfork from child process 26251]
[New Thread 0xb7704b70 (LWP 26252)]
[New Thread 0xb6f03b70 (LWP 26253)]
Reading symbols from test003.elf...
pre-prompt-for-continue
--Type <RET> for more, q to quit, c to continue without paging---elf/sim/common/sim-engine.c:62:1786:beg:0x83e3088
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 2, sim_stop_reason (sd=0x8bf9e80, reason=0xbfffeeb4, sigrc=0xbfffeeb8) at ./../common/sim-reason.c:30
(gdb) enable 3
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 3, sim_fetch_register (sd=0x8bf9e80, rn=32, buf=0x8c03b40 "", length=4) at ./../common/sim-reg.c:32
(gdb) fin
Run till exit from #0  sim_fetch_register (sd=0x8bf9e80, rn=32, buf=0x8c03b40 "", length=4) at ./../common/sim-reg.c:32
0x082e6dc7 in gdbsim_target::fetch_registers (this=0x8a712ec <gdbsim_ops>, regcache=0x8bc0bd8, regno=32) at remote-sim.c:474
Value returned is $4 = 4
(gdb) b write

(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 4, write () at ../sysdeps/unix/syscall-template.S:82
82	../sysdeps/unix/syscall-template.S: そのようなファイルやディレクトリはありません.
(gdb) where
#0  write () at ../sysdeps/unix/syscall-template.S:82
#1  0xb7af9fe4 in _IO_new_file_write (f=0xb7bfe4c0 <_IO_2_1_stdout_>, data=0xb63fd000, n=1) at fileops.c:1268
#2  0xb7afb8d0 in new_do_write (to_do=<optimized out>, data=<optimized out>, fp=<optimized out>) at fileops.c:522
#3  _IO_new_do_write (fp=0xb7bfe4c0 <_IO_2_1_stdout_>, data=0xb63fd000 "\nreakpoint 1 at 0x100: file test003.S, line 4.\n", to_do=1) at fileops.c:495
#4  0xb7afaa72 in _IO_new_file_overflow (f=0xb7bfe4c0 <_IO_2_1_stdout_>, ch=-1212160832) at fileops.c:873
#5  0xb7af9c32 in _IO_new_file_xsputn (f=0xb7bfe4c0 <_IO_2_1_stdout_>, data=0xb7bfe4c0 <_IO_2_1_stdout_>, n=1) at fileops.c:1350
#6  0xb7aef580 in *__GI__IO_fputs (str=0x8702b8a "\n", fp=0xb7bfe4c0 <_IO_2_1_stdout_>) at iofputs.c:42
#7  0x083ae6bf in fputs_maybe_filtered (linebuffer=<optimized out>, stream=0x8bc0ba8, filter=<optimized out>) at utils.c:1828
--Type <RET> for more, q to quit, c to continue without paging--c
#8  0x080c0116 in maybe_print_thread_hit_breakpoint (uiout=0x8bbdb50) at breakpoint.c:4499
#9  bkpt_print_it (bs=0x8c0ba90) at breakpoint.c:12488
#10 0x080c36a1 in print_bp_stop_message (bs=0x8c0ba90) at breakpoint.c:4553
#11 bpstat_print (bs=0x8c0ba90, kind=1) at breakpoint.c:4648
#12 0x082328af in print_stop_location (ws=<synthetic pointer>) at infrun.c:8069
#13 print_stop_event (uiout=0x8bbdb50, displays=true) at infrun.c:8129
#14 0x08396e26 in tui_on_normal_stop (bs=0x8c0ba90, print_frame=1) at tui/tui-interp.c:98
#15 0x08234613 in std::function<void (bpstats*, int)>::operator()(bpstats*, int) const (__args#1=1, __args#0=<optimized out>, this=0x8aecc40) at /usr/local/include/c++/10.2.0/bits/std_function.h:622
#16 gdb::observers::observable<bpstats*, int>::notify (args#1=<optimized out>, args#0=0x8c0ba90, this=<optimized out>) at ./../gdbsupport/observable.h:106
#17 normal_stop () at infrun.c:8407
#18 0x0823d456 in fetch_inferior_event () at infrun.c:3967
#19 0x080a733c in check_async_event_handlers () at async-event.c:295
#20 0x0848d67b in gdb_do_one_event () at event-loop.cc:194
#21 0x0837ef6c in wait_sync_command_done () at top.c:526
#22 maybe_wait_sync_command_done (was_sync=<optimized out>) at top.c:543
#23 0x08380ca1 in execute_command (p=<optimized out>, from_tty=<optimized out>) at top.c:670
#24 0x081e9cac in command_handler (command=0x8bd7a68 "run") at event-top.c:588
#25 0x0837f82c in read_command_file (stream=0x8bd71f8) at top.c:447
#26 0x08101811 in script_from_file (stream=0x8bd71f8, file=0xbffff84f "x") at cli/cli-script.c:1622
#27 0x080f80a4 in source_script_from_stream (file_to_open=0xbffff84f "x", file=0xbffff84f "x", stream=0x8bd71f8) at cli/cli-cmds.c:700
#28 source_script_with_search (file=0xbffff84f "x", file@entry=<error reading variable: value has been optimized out>, from_tty=<error reading variable: value has been optimized out>, search_path=<error reading variable: value has been optimized out>) at cli/cli-cmds.c:736
#29 0x0825e26a in catch_command_errors (command=<optimized out>, arg=<optimized out>, from_tty=<optimized out>) at main.c:457
#30 0x0825ff50 in captured_main_1 (context=<optimized out>) at main.c:1214
#31 0x0826034d in captured_main (data=0xbffff554) at main.c:1243
#32 gdb_main (args=0xbffff554) at main.c:1268
#33 0x0806f7ac in main (argc=5, argv=0xbffff624) at gdb.c:32
(gdb) 

ここでやはり pru-elf-gdb が -O2 ビルドされているっぽい. -g3 -O0 でビルド
breakpoint.o のみビルドし直すことにした.

ls breakpoint.o
breakpoint.o
> mv breakpoint.o breakpoint.o.org
> make -n breakpoint.o
echo "  CXX    breakpoint.o"; g++ -x c++  -g3 -O0   -I. -I. -I./config -DLOCALEDIR="\"/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/share/locale\"" -DHAVE_CONFIG_H -I./../include/opcode -I./../readline/readline/.. -I./../zlib -I../bfd -I./../bfd -I./../include -I../libdecnumber -I./../libdecnumber  -I./../gnulib/import -I../gnulib/import -I./.. -I..  -DTUI=1    -I/usr/local/include/python3.8 -I/usr/local/include/python3.8   -I./.. -pthread  -Wall -Wpointer-arith -Wno-unused -Wunused-value -Wunused-variable -Wunused-function -Wno-switch -Wno-char-subscripts -Wempty-body -Wunused-but-set-parameter -Wunused-but-set-variable -Wno-sign-compare -Wno-error=maybe-uninitialized -Wno-mismatched-tags -Wsuggest-override -Wimplicit-fallthrough=3 -Wduplicated-cond -Wshadow=local -Wdeprecated-copy -Wdeprecated-copy-dtor -Wredundant-move -Wmissing-declarations -Wstrict-null-sentinel -Wformat -Wformat-nonliteral  -c -o breakpoint.o -MT breakpoint.o -MMD -MP -MF ./.deps/breakpoint.Tpo breakpoint.c
mv ./.deps/breakpoint.Tpo ./.deps/breakpoint.Po
> make



ここらしい.

  annotate_breakpoint (b->number);
  maybe_print_thread_hit_breakpoint (uiout);

ここにたどり着いた.

print_stop_location (struct target_waitstatus *ws)
{
  int bpstat_ret;
  enum print_what source_flag;
  int do_frame_printing = 1;
  struct thread_info *tp = inferior_thread ();

  bpstat_ret = bpstat_print (tp->control.stop_bpstat, ws->kind);
  switch (bpstat_ret)

infrun.c も -g3 -O0 ビルドしなおした.

(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) b print_stop_location

(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
`/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb' has changed; re-reading symbols.
warning: File "/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb-gdb.gdb" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
warning: File "/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gdb-10.2.pru-elf/gdb/gdb -q -x x test003.elf
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/libthread_db.so.1".
warning: File "/usr/local/lib/libstdc++.so.6.0.28-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
[Detaching after vfork from child process 28985]
[New Thread 0xb7704b70 (LWP 28986)]
[New Thread 0xb6dffb70 (LWP 28987)]
Reading symbols from test003.elf...
Connected to the simulator.
Loading section .text, size 0x14 lma 0x100
Start address 0x100
Transfer rate: 160 bits in <1 sec.
Breakpoint 1 at 0x100: file test003.S, line 4.

Thread 1 "gdb" hit Breakpoint 6, print_stop_location (ws=0xbfffeeb4) at infrun.c:8066
(gdb) fin
Run till exit from #0  print_stop_location (ws=0xbfffeeb4) at infrun.c:8066

Breakpoint 1, start () at test003.S:4
4		ldi32	sp, stack
0x08253d93 in print_stop_event (uiout=0x8bf6b50, displays=true) at infrun.c:8129
(gdb) 

これは明白になった. まずはこの print_stop_location を調べるべき.
と思ったが,

Breakpoint 1 at 0x100: file test003.S, line 4.

ということ. つまり 0x100 はすでに 4 行目に対応していた. 期待値は 3 行目.
改めて確認したら

.debug_line セクションの内容:

CU: test003.S:
File name                            Line number    Starting address    View    Stmt
test003.S                                      3               0x100               x
test003.S                                      4               0x100       1       x
test003.S                                      5               0x104       2       x
test003.S                                      7               0x108       3       x
test003.S                                     12               0x10c       4       x
test003.S                                      -               0x110

3 行目も 4 行目もアドレス 0x100 おそらく 4 行目の情報を上書きしてアドレス 0x100 は
4 行目に対応したというところだろうか.

いずれにしてもこれはリンカの出力に問題がある. もしかするとアセンブラかもしれないので
確認した:

% pru-elf-objdump -x -d --dwarf=rawline --dwarf=decodedline  test003.o > test003.o.objdump
...
File name                            Line number    Starting address    View    Stmt
test003.S                                      3                   0               x
test003.S                                      4                 0x4       1       x
test003.S                                      5                 0xc       2       x
test003.S                                      7                0x10       3       x
test003.S                                     12                0x14       4       x
test003.S                                      -                0x18

アセンブラはできているように思える. だからこれはリンカの問題なのか.
以下も試してみた.

	.text
start:
	nop
	ldi	sp, stack
	call	%label(my_func)
end:
	nop
	
my_func:
	ret

これだと問題は発生しない.