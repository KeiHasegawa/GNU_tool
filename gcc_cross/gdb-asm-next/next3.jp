PRU の gdb で next コマンドを条件付きで動作するようにしてみた.

以下のようなアセンブラのプログラムで

	.text
start:
	ldi32	sp, stack
	call	%label(func1)
	call	%label(func2)
end:
	nop
	
func1:
	sub	r2, r2, 134
	sbbo	r3.b2, r2, 128, 6
	add	r4, r2, 134
	sub	r2, r4, 6
	lbbo	r3.b2, r2, 0, 6
	add	r2, r2, 6
	ret


func2:
	sub	r2, r2, 4
	sbbo	r4.b0, r2, 0, 4
	add	r4, r2, 4
	ldi	r1, 256
	sub	r2, r2, r1
	nop
	sub	r2, r4, 4
	lbbo	r4.b0, r2, 0, 4
	add	r2, r2, 4
	ret

2 命令目と 3 命令目の call で next コマンドを実行してそれぞれ次の行まで
実行するというものである.

当初これが期待通り動作するためには

  o r3 レジスタがスタックにセーブされているのならば, そのアドレス
  o r3 レジスタがスタックにセーブされていないのならば, されていないということ

の 2 つを正しく判断できる必要があるかと思っていたが実際は違っていた.

0. フレーム ID を取得
1. next コマンド
2. single step
3. 2 の完了後フレーム ID を取得
4. 0 と 3 とが異なるので 1 を実行した call 命令の戻りアドレスに内部ブレークポイントをセット
5. 命令数制限なしで実行
6. 4 のブーレクポイントにヒット

という流れになっているからだった. だから実際は func1 や func2 の最初の 1 命令だけ
実行しただけでは r3 がスタックに保存されることはないから, gdb 共通部分から
戻りアドレスの問い合わせがあったときに r3 レジスタの値を返しておけば next はできることに
なる.

勿論不完全だがこの時点での pru-tdep.c を pru-tdep.c.002 としてこのページにアップロード
しておく.
