共通ソースファイルから参照されるターゲット固有部の宣言

(*) REGISTER_NAMES

参照箇所の 1 つ gcc/reginfo.c

static const char *const initial_reg_names[] = REGISTER_NAMES;

    生成されるアセンブラに出現するレジスタの名前の列をマクロで指定する.
    レジスタ番号 n のレジスタ名が n 番目の要素になるようにする.
    例えばターゲットプロセッサが r0, r1, ..., r15 という名前の GPR があり,
    これらだけがアセンブラに出現するレジスタで, r14 をフレームポインタ
    r15 をスタックポインタとする場合

#define REGISTER_NAMES { "r0", "r1", "r2", "r3", "r4", "r5", "r6", \
    "r7", "r8", "r9", "r10", "r11", "r12", "r13, "fp", "sp" }

#define FRAME_POINTER_REGNUM 14
#define STACK_POINTER_REGNUM 15

    のように宣言する. "fp" はフレームポインタの名前としてアセンブラ出力に使用され
    "sp" はスタックポインタの名前としてアセンブラ出力に使用される.

(*) STACK_POINTER_REGNUM

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_STACK_POINTER_REGNUM__",
				     STACK_POINTER_REGNUM);

    スタックポインタのレジスタ番号と等しくなるようにする. constexpr による宣言でも OK.

(*) FRAME_POINTER_REGNUM

参照箇所の 1 つ gcc/rtl.h

#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM

    フレームポインタのレジスタ番号と等しくなるようにする.
    プリプロセッサのディレクティブで参照されるためマクロでなくてはならない.

(*) ARG_POINTER_REGNUM

    函数を呼び出すときに引数を渡すための最初のレジスタ番号と等しくなるようにする.
    レジスタを使用しないのであれば FRAME_POINTER_REGNUM と等しくなるようにする.
    プリプロセッサで参照されるためマクロでなくてはならない.

(*) FIRST_PSEUDO_REGISTER

参照箇所の 1 つ gcc/hard-reg-set.h

          return (*regno < FIRST_PSEUDO_REGISTER);

    初期化指定子 REGISTER_NAMES, FIXED_REGISTERS, CALL_USED_REGISTERS の要素数
    と等しくする. constexpr による宣言でも OK.

(*) FIXED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_fixed_regs[] = FIXED_REGISTERS;

    レジスタ番号 n のレジスタが函数呼び出しの前後で変わらないのであれば 1 そうでなければ 0
    となるようにマクロ指定する. REGISTER_NAMES と要素数が等しくなければならない.

(*) CALL_USED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_call_used_regs[] = CALL_USED_REGISTERS;

    レジスタ番号 n のレジスタが函数呼び出しの間で変更されうるのであれば 1 そうでなければ 0
    をマクロ指定する. REGISTER_NAMES と要素数が等しくなければならない.

(*) REGNO_REG_CLASS

参照箇所の 1 つ gcc/calls.c

      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))

      extern reg_class REGNO_REG_CLASS(int); の宣言を追加するとよい.

      レジスタ番号から次に述べる enum reg_class への変換を行なう.

(*) enum reg_class

参照箇所の 1 つ gcc/hard-reg-set.h

  enum reg_class x_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];

    レジスタアロケーションアルゴリズムで参照される. FIRST_PSEUDO_REGISTER 未満のどの
    レジスタ番号に対しても対応する reg_class のメンバが存在する. そのように宣言する.

    reg_class のメンバには以下が含まれている必要がある:

    o NO_REGS
        参照箇所の 1 つ tm-preds.h(生成されるファイル)

  return NO_REGS;

    o GENERAL_REGS
        参照箇所の 1 つ insn-preds.c(生成されるファイル)

    case CONSTRAINT_r: return GENERAL_REGS;

    o LIM_REG_CLASSES
        参照箇所の 1 つ gcc/ira.c

      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;

      enum reg_class の最後のメンバにする必要がある.

    o ALL_REGS
        参照箇所の 1 つ gcc/ira.c

    setup_reg_classes (i, GENERAL_REGS, ALL_REGS, GENERAL_REGS);

(*) N_REG_CLASSES

参照箇所の 1 つ gcc/hard-reg-set.h

  HARD_REG_SET x_reg_class_contents[N_REG_CLASSES];

    enum reg_class のメンバ LIM_REG_CLASSES と等しくする. constexpr に
    よる宣言も OK.

(*) REG_CLASS_CONTENTS

参照箇所の 1 つ gcc/reginfo.c

static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]
  = REG_CLASS_CONTENTS;

      ビットマップを指定する. 執筆中.

(*) BASE_REG_CLASS

参照箇所の 1 つ gcc/addresses.h

  return BASE_REG_CLASS;
      
      調査中. enum reg_class のいずれかに等しくなるようにする.

(*) UNITS_PER_WORD

参照箇所の 1 つ gcc/defaults.h

#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)

    いわゆるワードサイズと等しくする. 32 ビットプロセッサならば通常は 4.

(*) CUMULATIVE_ARGS

参照箇所の 1 つ gcc/emit-rtl.h

  CUMULATIVE_ARGS info;

    次に述べる INIT_CUMULATIVE_ARGS に必要な構造体を宣言する.

(*) INIT_CUMULATIVE_ARGS

参照箇所の 1 つ gcc/calls.c

  INIT_CUMULATIVE_ARGS (args_so_far_v, funtype, NULL_RTX, fndecl, n_named_args);

      調査中. 以下の宣言を追加するとよい:
      
extern void INIT_CUMULATIVE_ARGS(const CUMULATIVE_ARGS&, tree, rtx, tree, int);

(*) MOVE_MAX

参照箇所の 1 つ gcc/defaults.h

#define MOVE_MAX_PIECES   MOVE_MAX

    ロード/ストア命令で指定できる最大バイト数と等しくする. 32 ビットプロセッサ
    で 8 バイトのロード/ストアがないのであれば 4 を指定する.

(*) STRICT_ALIGNMENT

参照箇所の 1 つ gcc/c/c-typeck.c

      if ((STRICT_ALIGNMENT || warn_cast_align == 2)

      ロード/ストアをワード境界をまたいで発行できないのならば 1 を指定する.

(*) BITS_BIG_ENDIAN

参照箇所の 1 つ gcc/combine.c

	      if (BITS_BIG_ENDIAN)

      調査中.

(*) BYTES_BIG_ENDIAN

参照箇所の 1 つ gcc/c/c-typeck.c

	      if (BYTES_BIG_ENDIAN)

      調査中.

(*) WORDS_BIG_ENDIAN

参照箇所の 1 つ gcc/c-family/c-pragma.c

  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)

      調査中.


(*) FUNCTION_BOUNDARY

参照箇所の 1 つ gcc/c-family/c-common.c

	  value = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);

      調査中.

(*) TRAMPOLINE_SIZE

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_TRAMPOLINE_SIZE__",
				     TRAMPOLINE_SIZE);
			     
      調査中.


(*) TARGET_CPU_CPP_BUILTINS

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

  TARGET_CPU_CPP_BUILTINS ();

      固有のプリディファインをセットする. 函数として宣言を追加しても良いのだが

#define TARGET_CPU_CPP_BUILTINS() builtin_define_std("hasegawa")

      のようにすればよい. builtin_define_std や builtin_define は libbackend.a
      の外で定義されるため.

(*) BIGGEST_ALIGNMENT

参照箇所の 1 つ gcc/defaults.h

#define ATTRIBUTE_ALIGNED_VALUE BIGGEST_ALIGNMENT

      調査中.

(*) ATTRIBUTE_ALIGNED_VALUE

参照箇所の 1 つ gcc/c-family/c-attribs.c

    align_expr = size_int (ATTRIBUTE_ALIGNED_VALUE / BITS_PER_UNIT);

      調査中.

(*) Pmode

参照箇所の 1 つ gcc/optabs.h

  create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);

      ポインタの加算, 減算が 4 バイトの加算, 減算ならば Pmode を SImode に
      に define する. 8 バイトの加算, 減算ならば DImode に, 2 バイトの加算,
      減算ならば HImode に define する.

(*) MAX_REGS_PER_ADDRESS

参照箇所の 1 つ gcc/reload.h

#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))

      調査中.

(*) FUNCTION_ARG_REGNO_P

参照箇所の 1 つ gcc/alias.c

    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))

      調査中. 以下の宣言をしておく:

      extern bool FUNCTION_ARG_REGNO_P(int regno);

      regno が函数を呼び出すときに引数を渡すのに使用されるかどうかを判定する.

(*) ELIMINABLE_REGS

参照箇所の 1 つ gcc/builtins.c

      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;
      
      調査中.

(*) STACK_BOUNDARY

参照箇所の 1 つ gcc/defaults.h

#define MAX_STACK_ALIGNMENT STACK_BOUNDARY
      
      調査中.

(*) PARM_BOUNDARY

参照箇所の 1 つ gcc/builtins.c

  set_mem_align (dest, PARM_BOUNDARY);
      
      調査中.

(*) FUNCTION_MODE

参照箇所の 1 つ gcc/builtins.c

    function = memory_address (FUNCTION_MODE, function);
      
      調査中.

(*) REGNO_OK_FOR_BASE_P

参照箇所の 1 つ gcc/addresses.h

  return REGNO_OK_FOR_BASE_P (regno);

      調査中. extern bool REGNO_OK_FOR_BASE_P(int); の宣言を追加するとよい.

(*) SLOW_BYTE_ACCESS

参照箇所の 1 つ gcc/dojump.c

      if (! SLOW_BYTE_ACCESS

      調査中.

(*) ASM_OUTPUT_ALIGN

参照箇所の 1 つ gcc/dwarf2out.c

		ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));

      extern void ASM_OUTPUT_ALIGN(FILE*, int); の宣言を追加して, その
      定義を以下のようにすればよい:

void ASM_OUTPUT_ALIGN(FILE* fp, int n)
{
  fprintf(fp, "	.align	%d\n", n);
}

      もしくはマクロにしてもよい.

(*) FIRST_PARM_OFFSET

参照箇所の 1 つ gcc/defaults.h

  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)

      調査中. extern int FIRST_PARM_OFFSET(tree); の宣言を追加するとよい.

(*) CASE_VECTOR_MODE

参照箇所の 1 つ gcc/expr.c

			       gen_int_mode (GET_MODE_SIZE (CASE_VECTOR_MODE),
					     Pmode));

      調査中. Pmode や SImode と同じ scalar_int_mode 型として宣言する
      必要がある.

(*) ASM_APP_ON

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_ON, asm_out_file);

      プログラムにインラインアセンブラが出現したときに始まりのマークとしてこの文字列が生成
      ファイルに書き込まれる.

(*) ASM_APP_OFF

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_OFF, asm_out_file);

      ASM_APP_ON と対で生成ファイルに書き込まれる. インラインアセンブラの終りのマークとし
      てこの文字列が生成ファイルに書き込まれる.

(*) FUNCTION_PROFILER

参照箇所の 1 つ gcc/final.c

  FUNCTION_PROFILER (file, current_function_funcdef_no);

      プロファイルオプションを指定されたときに参照される. プロファイルのための特別な
      コードを生成する. extern void FUNCTION_PROFILER(FILE*, int); の
      宣言を追加するとよい.

(*) REGNO_OK_FOR_INDEX_P

参照箇所の 1 つ gcc/ira-costs.c

  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);

      調査中.

(*) INDEX_REG_CLASS

参照箇所の 1 つ gcc/ira-costs.c

    rclass = INDEX_REG_CLASS;

      調査中.

(*) INITIAL_ELIMINATION_OFFSET

参照箇所の 1 つ gcc/lra-eliminations.c

      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->offset);

      調査中.

(*) DEFAULT_SIGNED_CHAR

参照箇所の 1 つ gcc/opts.c

  opts->x_flag_signed_char = DEFAULT_SIGNED_CHAR;

      char が signed char と同じ範囲の値を取るか, あるいは unsigned char と同じ範囲の
      値を取るかを指定する. constexpr による宣言も OK.
