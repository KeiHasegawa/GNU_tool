共通ソースファイルから参照されるターゲット固有部の宣言

(*) REGISTER_NAMES

参照箇所の 1 つ gcc/reginfo.c

static const char *const initial_reg_names[] = REGISTER_NAMES;

    レジスタ番号 n のレジスタ名が n 番目の要素になるようにする.
    例えばターゲットプロセッサが r0, r1, ..., r15 という名前の GPR があり,
    r14 をフレームポインタ r15 をスタックポインタとする場合

#define REGISTER_NAMES { "r0", "r1", "r2", "r3", "r4", "r5", "r6", \
    "r7", "r8", "r9", "r10", "r11", "r12", "r13, "fp", "sp", "dummy" }

#define FRAME_POINTER_REGNUM 14  // 後述
#define STACK_POINTER_REGNUM 15  // 後述

    のように宣言する. "fp" や "sp" はそれぞれ 14, 15 番のレジスタの名前として
    gcc 全体のコードから参照される. 最後の "dummy" はこの場合必要だが, 簡単な理由を説明
    すると以下のマクロ

#define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)

    で HARD_REGISTER_NUM_P(15) を 1 に評価するためである. 最後の要素に対して 0 に
    評価されて問題ないならば上のような "dummy" は必要ない.
    また上記は後述する UNITS_PER_WORD が 4 の場合には正しいが

    o AVR のように UNIT_PER_WORDS が 1 で Pmode (後述)のサイズが 2 ならば dummy
      の数をもう一つ増やす必要がある.
 
(*) STACK_POINTER_REGNUM

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_STACK_POINTER_REGNUM__",
				     STACK_POINTER_REGNUM);

    スタックポインタのレジスタ番号と等しくなるようにする. constexpr による宣言でも OK.

(*) FRAME_POINTER_REGNUM

参照箇所の 1 つ gcc/rtl.h

#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM

    フレームポインタのレジスタ番号と等しくなるようにする.
    プリプロセッサのディレクティブで参照されるためマクロでなくてはならない.

(*) ARG_POINTER_REGNUM

    函数が呼び出されたときに引数があるスタックの相対位置を示すレジスタを指定する.
    普通は FRAME_POINTER_REGNUM と等しくなるようにする. FIRST_PARM_OFFSET
    も参照.
    プリプロセッサのディレクティブで参照されるためマクロでなくてはならない.

    int f(int a, int b)
    {
      ...
    }

    のような f に対して f のプロローグの部分で a や b をスタックに保存するときに
    例えば ARM や AARCH64 のように, フレームポインタの相対 0, 4 に保存して問題なければ
    FRAME_POINTER_REGNUM と同じレジスタ番号, すなわちフレームポンタのレジスタ番号
    を指定する.

    Blackfin のように, そうではないスタックフレームを採用するコンパイラであれば仮想のレジスタ
    を宣言する:

#define REGISTER_NAMES { "r0", "r1", "r2", "r3", "r4", "r5", "r6", \
    "r7", "r8", "r9", "r10", "r11", "r12", "r13, "fp", "sp", "ap" }

#define FRAME_POINTER_REGNUM 14
#define STACK_POINTER_REGNUM 15
#define ARG_POINTER_REGNUM   16

    この仮想のレジスタ ap は HARD_REGISTER_NUM_P(16) が 0 になっても問題がないので
    最後のダミーの要素は上のように必要ないし, あっても問題ない.
    ap がどこを指すかを函数 INITIAL_ELIMINATION_OFFSET で指定する. このため
    マクロ ELIMINABLE_REGS (後述)を以下のように修正する必要がある:

#define ELIMINABLE_REGS				\
{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},	\
 { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},	\
 { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}	\

(*) FIRST_PSEUDO_REGISTER

参照箇所の 1 つ gcc/hard-reg-set.h

          return (*regno < FIRST_PSEUDO_REGISTER);

    初期化指定子 REGISTER_NAMES, FIXED_REGISTERS, CALL_USED_REGISTERS の要素数
    と等しくする. constexpr による宣言でも OK.

(*) FIXED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_fixed_regs[] = FIXED_REGISTERS;

    レジスタ番号 n のレジスタをレジスタアロケーションアロゴリズムで使用できないならば 1
    そうでなければ 0 となるようにマクロを指定する. REGISTER_NAMES と要素数が等しくな
    ければならない.

(*) CALL_USED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_call_used_regs[] = CALL_USED_REGISTERS;

    レジスタ番号 n のレジスタが函数呼び出しの間で変更されうるのであれば 1 そうでなければ 0
    をマクロ指定する. REGISTER_NAMES と要素数が等しくなければならない.

(*) REGNO_REG_CLASS

参照箇所の 1 つ gcc/calls.c

      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))

      extern reg_class REGNO_REG_CLASS(int regno); の宣言を追加するとよい.

      レジスタ番号から次に述べる enum reg_class への変換を行なう.

(*) enum reg_class

参照箇所の 1 つ gcc/hard-reg-set.h

  enum reg_class x_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];

    レジスタアロケーションアルゴリズムで参照される. FIRST_PSEUDO_REGISTER 未満のどの
    レジスタ番号に対しても対応する reg_class のメンバが存在する. そのように宣言する.

    reg_class のメンバには以下が含まれている必要がある:

    o NO_REGS
        参照箇所の 1 つ tm-preds.h(生成されるファイル)

  return NO_REGS;

    o GENERAL_REGS
        参照箇所の 1 つ insn-preds.c(生成されるファイル)

    case CONSTRAINT_r: return GENERAL_REGS;

    o LIM_REG_CLASSES
        参照箇所の 1 つ gcc/ira.c

      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;

      enum reg_class の最後のメンバにする必要がある.

    o ALL_REGS
        参照箇所の 1 つ gcc/ira.c

    setup_reg_classes (i, GENERAL_REGS, ALL_REGS, GENERAL_REGS);

(*) N_REG_CLASSES

参照箇所の 1 つ gcc/hard-reg-set.h

  HARD_REG_SET x_reg_class_contents[N_REG_CLASSES];

    enum reg_class のメンバ LIM_REG_CLASSES と等しくする. constexpr に
    よる宣言も OK.

(*) REG_CLASS_CONTENTS

参照箇所の 1 つ gcc/reginfo.c

static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]
  = REG_CLASS_CONTENTS;

      以下のようにビットマップを指定する.

#define REGISTER_NAMES      { "sp", "fp", "a", "b" }

enum reg_class {
  NO_REGS, SP_REGS, FP_REGS, A_REGS, B_REGS,
  GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES
};

#define REG_CLASS_CONTENTS \
/* NO_REGS */		{{ 0x00000000 }, \
/* SP_REGS */		 { 0x00000001 }, \
/* FP_REGS */		 { 0x00000002 }, \
/* A_REGS */		 { 0x00000004 }, \
/* B_REGS */		 { 0x00000008 }, \
/* GENERAL_REGS */	 { 0x0000000c }, \
/* ALL_REGS */           { 0x0000000f }}

(*) BASE_REG_CLASS

参照箇所の 1 つ gcc/addresses.h

  return BASE_REG_CLASS;
      
      調査中. enum reg_class のいずれかに等しくなるようにする. constexpr に
      よる宣言も OK.

(*) UNITS_PER_WORD

参照箇所の 1 つ gcc/defaults.h

#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)

    いわゆるワードサイズと等しくする. 32 ビットプロセッサならば通常は 4. constexpr に
    よる宣言も OK.
    この値を 4 以外にする場合は他の部分も調整が必要になる.
     UINT16_TYPE, UINT32_TYPE, UINT64_TYPE のセクションを参照.

    1 : avr, pru, rl78
    2 : cr16, h8300(*1), m32c, m68hc11
    8 : aarch64, mips(*2), ppc(*2)

    (*1) オプションに依存するがオプションなしで 2
    (*2) オプションに依存するがオプションなしで 4


(*) CUMULATIVE_ARGS

参照箇所の 1 つ gcc/emit-rtl.h

  CUMULATIVE_ARGS info;

    次に述べる INIT_CUMULATIVE_ARGS に必要な型を宣言する. 大抵は

(*) INIT_CUMULATIVE_ARGS

参照箇所の 1 つ gcc/calls.c

  INIT_CUMULATIVE_ARGS (args_so_far_v, funtype, NULL_RTX, fndecl, n_named_args);

      以下の宣言を追加する:
      
      extern void INIT_CUMULATIVE_ARGS(CUMULATIVE_ARGS& cum,
                                       tree fntype, rtx,
                                       tree fundecl, int);

      函数のフレームサイズはその函数で宣言されたローカル変数や中間変数から計算される.
      この分とは別に, この函数はターゲットコードの函数がとる引数をスタックに保存する
      ためにフレームサイズを変更する仕組みで使用される.

      例えば, 最初の 4 つの引数を GPR の r0, r1, r2, r3 で渡すような ABI を
      採用しているコンパイラに対して

      int f(int a, int b, int c, int d, int e)
      {
        ...
      }

      のような函数に対しては, 最初の 4 つの引数に対して sizeof(int) * 4 分フレーム
      サイズを変更する必要がある(かもしれない).
      この計算を行なうために第 1 引数の cum の初期化を INIT_CUMULATIVE_ARGS で行なう.
      各引数に対して

      TARGET_FUNCTION_ARG_ADVANCE

      のマクロで定義される函数が順に呼び出されるので INIT_CUMULATIVE_ARGS で初期化した
      値を順次更新していく.

      TARGET_FUNCTION_INCOMING_ARG

      のマクロで定義される函数も順次呼び出されるので上で計算した値をもとにどのレジスタを
      使用するのかを返すようにする. 上の f ならば

      引数 a に対して r0 レジスタ, 引数 b に対して r1 レジスタ, 引数 c に対して
      r2 レジスタ, 引数 d に対して r3 レジスタ, 引数 e に対してはレジスタを使用しない

      ということを示すようにする.

(*) MOVE_MAX

参照箇所の 1 つ gcc/defaults.h

#define MOVE_MAX_PIECES   MOVE_MAX

    ロード/ストア命令で指定できる最大バイト数と等しくする. 32 ビットプロセッサ
    で 8 バイトのロード/ストアがないのであれば 4 を指定する. constexpr に
    よる宣言も OK.

(*) STRICT_ALIGNMENT

参照箇所の 1 つ gcc/c/c-typeck.c

      if ((STRICT_ALIGNMENT || warn_cast_align == 2)

      ロード/ストアをワード境界をまたいで発行できないのならば 1 を指定する.
      constexpr による宣言も OK.

(*) BITS_BIG_ENDIAN

参照箇所の 1 つ gcc/combine.c

	      if (BITS_BIG_ENDIAN)

      通常は 0 に define する. 符号ビットが最下位ビットならば 1 に define する.
      constexpr による宣言も OK.

(*) BYTES_BIG_ENDIAN

参照箇所の 1 つ gcc/c/c-typeck.c

	      if (BYTES_BIG_ENDIAN)

      ビッグエンディアンならば 1 に define する. constexpr による宣言も OK.

(*) WORDS_BIG_ENDIAN

参照箇所の 1 つ gcc/c-family/c-pragma.c

  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)

      マルチワードの並びがビッグエンディアンならば 1 に define する. すなわち 
      0x123456789abcef0LL がメモリに配置されているとき以下のようになっている.

      +------------+ +0
      | 0x12345678 |
      +------------+ +4
      | 0x9abcdef0 |
      +------------+ +8

      constexpr による宣言も OK.

(*) FUNCTION_BOUNDARY

参照箇所の 1 つ gcc/c-family/c-common.c

	  value = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);

      調査中. constexpr による宣言も OK.

(*) TRAMPOLINE_SIZE

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_TRAMPOLINE_SIZE__",
				     TRAMPOLINE_SIZE);
			     
      調査中. constexpr による宣言も OK.

(*) TARGET_CPU_CPP_BUILTINS

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

  TARGET_CPU_CPP_BUILTINS ();

      固有のプリディファインをセットする. 函数として宣言を追加しても良いのだが

#define TARGET_CPU_CPP_BUILTINS() builtin_define_std("hasegawa")

      のようにすればよい. builtin_define_std や builtin_define は libbackend.a
      の外で定義されるため.

(*) BIGGEST_ALIGNMENT

参照箇所の 1 つ gcc/defaults.h

#define ATTRIBUTE_ALIGNED_VALUE BIGGEST_ALIGNMENT

      調査中. constexpr による宣言も OK.

(*) ATTRIBUTE_ALIGNED_VALUE

参照箇所の 1 つ gcc/c-family/c-attribs.c

    align_expr = size_int (ATTRIBUTE_ALIGNED_VALUE / BITS_PER_UNIT);

      調査中. constexpr による宣言も OK.

(*) Pmode

参照箇所の 1 つ gcc/optabs.h

  create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);

      ポインタが 4 バイトならば Pmode を SImode に define する. 8 バイトならば
      DImode に, 2 バイトのならば HImode に define する. constexpr による宣言
      も OK.

(*) MAX_REGS_PER_ADDRESS

参照箇所の 1 つ gcc/reload.h

#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))

      調査中. constexpr による宣言も OK.

(*) FUNCTION_ARG_REGNO_P

参照箇所の 1 つ gcc/alias.c

    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))

      以下の宣言をしておく:

      extern bool FUNCTION_ARG_REGNO_P(int regno);

      regno が函数を呼び出すときに引数を渡すのに使用されるならば true をそうでなければ
      false を返す.

(*) STACK_BOUNDARY

参照箇所の 1 つ gcc/defaults.h

#define MAX_STACK_ALIGNMENT STACK_BOUNDARY
      
      調査中. constexpr による宣言も OK.

(*) PARM_BOUNDARY

参照箇所の 1 つ gcc/builtins.c

  set_mem_align (dest, PARM_BOUNDARY);
      
      調査中. constexpr による宣言も OK.

(*) FUNCTION_MODE

参照箇所の 1 つ gcc/builtins.c

    function = memory_address (FUNCTION_MODE, function);
      
      調査中. 大抵は QImode に define している. constexpr による宣言も OK.

(*) REGNO_OK_FOR_BASE_P

参照箇所の 1 つ gcc/addresses.h

  return REGNO_OK_FOR_BASE_P (regno);

      調査中. extern bool REGNO_OK_FOR_BASE_P(int regno); の宣言を追加するとよい.

(*) SLOW_BYTE_ACCESS

参照箇所の 1 つ gcc/dojump.c

      if (! SLOW_BYTE_ACCESS

      調査中. constexpr による宣言も OK.

(*) ASM_OUTPUT_ALIGN

参照箇所の 1 つ gcc/dwarf2out.c

		ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));

      extern void ASM_OUTPUT_ALIGN(FILE*, int); の宣言を追加して, その
      定義を以下のようにすればよい:

void ASM_OUTPUT_ALIGN(FILE* fp, int n)
{
  fprintf(fp, "	.align	%d\n", n);
}

      もしくはマクロにしてもよい.

(*) FIRST_PARM_OFFSET

参照箇所の 1 つ gcc/defaults.h

  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)

参照箇所の 1 つ gcc/function.c

  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);

      extern int FIRST_PARM_OFFSET(tree func); の宣言を追加するとよい.
      もしくはマクロにしてもよい.  

      函数の引数で, スタックを使用して渡す最初の引数があるスタックのアドレスを
      ARG_POINTER_REGNUM で定義したレジスタが指すようにこの函数でオフセットを指定する.

      例えば, 函数呼び出しで引数は全てスタックを使用して渡す ABI のコンパイラで
      スタックフレームが以下のようになっているとする. そして ARG_POINTER_REGNUM
      を FRAME_POINTER_REGNUM と等しくなるように宣言しているとする.

      +----------------+ <- sp_{new}
      |                | 
      |                | 
      ~   local area   ~ 
      |                | 
      |                | 
   +0 +----------------+ <- fp_{new}
      |    fp_{old}    | 
   +4 +----------------+ <- sp_{old}
      | return address | 
   +8 +----------------+
      |  1st argument  |
      +----------------+
      |  2nd argument  |
      +----------------+

      この場合は FIRST_PARM_OFFSET の戻り値は 8 になる. 函数が構造体を返す場合
      等必ずしも最初の引数がオフセット 8 にならない場合は, 実装によっては
      FIRST_PARM_OFFSET の引数の tree func に応じて返す値を調整する必要がある
      かもしれない.

(*) CASE_VECTOR_MODE

参照箇所の 1 つ gcc/expr.c

			       gen_int_mode (GET_MODE_SIZE (CASE_VECTOR_MODE),
					     Pmode));

      調査中. 大抵は Pmode に define されている. constexpr による宣言も OK.

(*) ASM_APP_ON

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_ON, asm_out_file);

      プログラムにインラインアセンブラが出現したときに始まりのマークとしてこの文字列が生成
      ファイルに書き込まれる. constexpr による宣言も OK.

(*) ASM_APP_OFF

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_OFF, asm_out_file);

      ASM_APP_ON と対で生成ファイルに書き込まれる. インラインアセンブラの終りのマークとし
      てこの文字列が生成ファイルに書き込まれる. constexpr による宣言も OK.

(*) FUNCTION_PROFILER

参照箇所の 1 つ gcc/final.c

  FUNCTION_PROFILER (file, current_function_funcdef_no);

      プロファイルオプションを指定されたときに参照される. プロファイルのための特別な
      コードを生成する. extern void FUNCTION_PROFILER(FILE*, int); の
      宣言を追加するとよい.

(*) REGNO_OK_FOR_INDEX_P

参照箇所の 1 つ gcc/ira-costs.c

  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);

      調査中.

(*) INDEX_REG_CLASS

参照箇所の 1 つ gcc/ira-costs.c

    rclass = INDEX_REG_CLASS;

      調査中.


(*) ELIMINABLE_REGS

参照箇所の 1 つ gcc/builtins.c

      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;
      
      ARG_POINTER_REGNUM も参照. ARG_POINTER_REGNUM が FRAME_POINTER_REGNUM
      と等しいのならば 

(*) INITIAL_ELIMINATION_OFFSET

参照箇所の 1 つ gcc/lra-eliminations.c

      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->offset);

      調査中.

(*) DEFAULT_SIGNED_CHAR

参照箇所の 1 つ gcc/opts.c

  opts->x_flag_signed_char = DEFAULT_SIGNED_CHAR;

      char が signed char と同じ範囲の値を取るか, あるいは unsigned char と同じ範囲の
      値を取るかを指定する. constexpr による宣言も OK.

以下は cc1 等のコンパイル時には必要ないが実行時にエラーを起こさないために必要な宣言

(*) PRINT_OPERAND

参照箇所の 1 つ : gcc/targhooks.c

  PRINT_OPERAND (stream, x, code);

以下の宣言を追加する:

extern void hasegawa_print_operand(FILE*, rtx, int);
#define PRINT_OPERAND hasegawa_print_operand

(*) TEXT_SECTION_ASM_OP, DATA_SECTION_ASM_OP, BSS_SECTION_ASM_OP

参照箇所の 1 つ gcc/varasm.c

#ifdef TEXT_SECTION_ASM_OP
  text_section = get_unnamed_section (SECTION_CODE, output_section_asm_op,
				      TEXT_SECTION_ASM_OP);
#endif

      文字列リテラルをマクロで指定する. .text, .data, .bss セクションに切り替えるとき
      に生成する疑似命令を指定する. プリプロセッサのディレクティブで参照されているので
      constexpr による宣言はできない.

(*) POINTER_SIZE

参照箇所の 1 つ gcc/defaults.h

#ifndef POINTER_SIZE
#define POINTER_SIZE BITS_PER_WORD
#endif

      Pmode を DImode と等しくなるように宣言している場合は POINTER_SIZE が 8 と等しく
      なるようにする. プリプロセッサのディレクティブで参照されているので
      constexpr による宣言はできない.

(*) INCOMING_RETURN_ADDR_RTX

参照箇所の 1 つ gcc/dwarf2cfi.c

      initial_return_save (INCOMING_RETURN_ADDR_RTX);

      -g オプション付きで cc1 を起動したときに上の行が実行する. 函数が呼び出された直後に
      戻りアドレスがどこにあるかを指定する. 例えば aarch64 のようにリンクレジスタである
      x30 レジスタに戻りアドレスがあるのならば

#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG(Pmode, X30_REGNUM)

      のように指定する.
      例えば m68hc11 のようにスタックポインタが指しているところに戻りアドレスが
      あるのならば

#define INCOMING_RETURN_ADDR_RTX \
  gen_rtx_MEM(VOIDmode, gen_rtx_REG(VOIDmode, STACK_POINTER_REGNUM))

      のように指定する. プリプロセッサのディレクティブで参照されるのでマクロで
      指定する必要がある. この定義がなければ, 実行時エラーするようにマクロが
      定義される.

(*) UINT16_TYPE, UINT32_TYPE, UINT64_TYPE

      UNITS_PER_WORD を 1 や 2 にすると以下を実行したときに 0 番地アクセスする.

c-common.c:4304:

  char16_type_node = get_identifier (CHAR16_TYPE);

      これのマクロ展開は複雑だが, 結果的に strlen(0) の呼び出しを引き起こしている.

      CHAR16_TYPE はマクロで

gcc/defaults.h:591

#ifdef UINT_LEAST16_TYPE
#define CHAR16_TYPE UINT_LEAST16_TYPE
#else
#define CHAR16_TYPE "short unsigned int"
#endif

      となっている. UINT_LEAST16_TYPE もやはりマクロで

gcc/config/newlib-stdint.h:50

#define UINT_LEAST16_TYPE (UINT16_TYPE ? UINT16_TYPE : UINT32_TYPE ? UINT32_TYPE : UINT64_TYPE ? UINT64_TYPE : 0)

      となっている. そこで以下の宣言を追加する.

#undef UINT16_TYPE
#define UINT16_TYPE	"unsigned int"
#undef UINT32_TYPE
#define UINT32_TYPE	"long unsigned int"
#undef UINT64_TYPE
#define UINT64_TYPE	"long long unsigned int"

      実は上の宣言に替えて次のセクションで述べるマクロを使用する方が分かり易い.

(*) SHORT_TYPE_SIZE, INT_TYPE_SIZE, LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE

      UNITS_PER_WORD を 4 以外にする場合は以下のように宣言する. 以下は AVR の例:

constexpr int UNITS_PER_WORD  = 1;

#define SHORT_TYPE_SIZE		16
#define INT_TYPE_SIZE           16
#define LONG_TYPE_SIZE		32
#define LONG_LONG_TYPE_SIZE     64

(*) FLOAT_TYPE_SIZE, DOUBLE_TYPE_SIZE, LONG_DOUBLE_TYPE_SIZE

      UNITS_PER_WORD を 4 以外にする場合は以下のように宣言する. 以下は AVR の例:

#define FLOAT_TYPE_SIZE         32
#define DOUBLE_TYPE_SIZE        64
#define LONG_DOUBLE_TYPE_SIZE   64

(*) PREFERRED_DEBUGGING_TYPE

      .debug_frame セクションを出したくない場合(?)以下のようにターゲット固有部で宣言する.

#undef PREFERRED_DEBUGGING_TYPE
#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG

      例えば gcc/config/avr/elf.h でこのように宣言している. .debug_frame セクション
      が出力されてしまうと期待しない動作を gdb がしてしまうことがある.
      試しに m68hc11 でもこの対応をしてみたが, 残念ながら gdb は期待通り動作していない.
      そこまで単純ではないらしい.
