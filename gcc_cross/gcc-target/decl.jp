共通ソースファイルから参照されるターゲット固有部の宣言

(*) REGISTER_NAMES

参照箇所の 1 つ gcc/reginfo.c

static const char *const initial_reg_names[] = REGISTER_NAMES;

    生成されるアセンブラに出現するレジスタの名前の列をマクロで指定する.
    レジスタ番号 n のレジスタ名が n 番目の要素になるようにする.
    例えばターゲットプロセッサが r0, r1, ..., r15 という名前の GPR があり,
    これらだけがアセンブラに出現するレジスタで, r14 をフレームポインタ
    r15 をスタックポインタとする場合

#define REGISTER_NAMES { "r0", "r1", "r2", "r3", "r4", "r5", "r6", \
    "r7", "r8", "r9", "r10", "r11", "r12", "r13, "fp", "sp" }

#define FRAME_POINTER_REGNUM 14
#define STACK_POINTER_REGNUM 15

    のように宣言する. "fp" はフレームポインタの名前としてアセンブラ出力に使用され
    "sp" はスタックポインタの名前としてアセンブラ出力に使用される.

(*) STACK_POINTER_REGNUM

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_STACK_POINTER_REGNUM__",
				     STACK_POINTER_REGNUM);

    スタックポインタのレジスタ番号と等しくなるようにする. constexpr による宣言でも OK.

(*) FRAME_POINTER_REGNUM

参照箇所の 1 つ gcc/rtl.h

#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM

    フレームポインタのレジスタ番号と等しくなるようにする.
    プリプロセッサのディレクティブで参照されるためマクロでなくてはならない.

(*) ARG_POINTER_REGNUM

    函数が呼び出されたときに引数があるスタックの相対位置を示すレジスタを指定する.
    普通は FRAME_POINTER_REGNUM と等しくなるようにする. FIRST_PARM_OFFSET
    も参照.
    プリプロセッサのディレクティブで参照されるためマクロでなくてはならない.

(*) FIRST_PSEUDO_REGISTER

参照箇所の 1 つ gcc/hard-reg-set.h

          return (*regno < FIRST_PSEUDO_REGISTER);

    初期化指定子 REGISTER_NAMES, FIXED_REGISTERS, CALL_USED_REGISTERS の要素数
    と等しくする. constexpr による宣言でも OK.

(*) FIXED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_fixed_regs[] = FIXED_REGISTERS;

    レジスタ番号 n のレジスタをレジスタアロケーションアロゴリズムで使用できないならば 1
    そうでなければ 0 となるようにマクロを指定する. REGISTER_NAMES と要素数が等しくな
    ければならない.

(*) CALL_USED_REGISTERS

参照箇所の 1 つ gcc/reginfo.c

static const char initial_call_used_regs[] = CALL_USED_REGISTERS;

    レジスタ番号 n のレジスタが函数呼び出しの間で変更されうるのであれば 1 そうでなければ 0
    をマクロ指定する. REGISTER_NAMES と要素数が等しくなければならない.

(*) REGNO_REG_CLASS

参照箇所の 1 つ gcc/calls.c

      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))

      extern reg_class REGNO_REG_CLASS(int regno); の宣言を追加するとよい.

      レジスタ番号から次に述べる enum reg_class への変換を行なう.

(*) enum reg_class

参照箇所の 1 つ gcc/hard-reg-set.h

  enum reg_class x_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];

    レジスタアロケーションアルゴリズムで参照される. FIRST_PSEUDO_REGISTER 未満のどの
    レジスタ番号に対しても対応する reg_class のメンバが存在する. そのように宣言する.

    reg_class のメンバには以下が含まれている必要がある:

    o NO_REGS
        参照箇所の 1 つ tm-preds.h(生成されるファイル)

  return NO_REGS;

    o GENERAL_REGS
        参照箇所の 1 つ insn-preds.c(生成されるファイル)

    case CONSTRAINT_r: return GENERAL_REGS;

    o LIM_REG_CLASSES
        参照箇所の 1 つ gcc/ira.c

      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;

      enum reg_class の最後のメンバにする必要がある.

    o ALL_REGS
        参照箇所の 1 つ gcc/ira.c

    setup_reg_classes (i, GENERAL_REGS, ALL_REGS, GENERAL_REGS);

(*) N_REG_CLASSES

参照箇所の 1 つ gcc/hard-reg-set.h

  HARD_REG_SET x_reg_class_contents[N_REG_CLASSES];

    enum reg_class のメンバ LIM_REG_CLASSES と等しくする. constexpr に
    よる宣言も OK.

(*) REG_CLASS_CONTENTS

参照箇所の 1 つ gcc/reginfo.c

static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]
  = REG_CLASS_CONTENTS;

      以下のようにビットマップを指定する.

#define REGISTER_NAMES      { "sp", "fp", "a", "b" }

enum reg_class {
  NO_REGS, SP_REGS, FP_REGS, A_REGS, B_REGS,
  GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES
};

#define REG_CLASS_CONTENTS \
/* NO_REGS */		{{ 0x00000000 }, \
/* SP_REGS */		 { 0x00000001 }, \
/* FP_REGS */		 { 0x00000002 }, \
/* A_REGS */		 { 0x00000004 }, \
/* B_REGS */		 { 0x00000008 }, \
/* GENERAL_REGS */	 { 0x0000000c }, \
/* ALL_REGS */           { 0x0000000f }}

(*) BASE_REG_CLASS

参照箇所の 1 つ gcc/addresses.h

  return BASE_REG_CLASS;
      
      調査中. enum reg_class のいずれかに等しくなるようにする. constexpr に
      よる宣言も OK.

(*) UNITS_PER_WORD

参照箇所の 1 つ gcc/defaults.h

#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)

    いわゆるワードサイズと等しくする. 32 ビットプロセッサならば通常は 4. constexpr に
    よる宣言も OK.

(*) CUMULATIVE_ARGS

参照箇所の 1 つ gcc/emit-rtl.h

  CUMULATIVE_ARGS info;

    次に述べる INIT_CUMULATIVE_ARGS に必要な型を宣言する.

(*) INIT_CUMULATIVE_ARGS

参照箇所の 1 つ gcc/calls.c

  INIT_CUMULATIVE_ARGS (args_so_far_v, funtype, NULL_RTX, fndecl, n_named_args);

      以下の宣言を追加する:
      
      extern void INIT_CUMULATIVE_ARGS(CUMULATIVE_ARGS& cum,
                                       tree fntype, rtx,
                                       tree fundecl, int);

      函数のフレームサイズはその函数で宣言されたローカル変数や中間変数から計算される.
      この分とは別に, この函数はターゲットコードの函数がとる引数をスタックに保存する
      ためにフレームサイズを変更する仕組みで使用される.

      例えば, 最初の 4 つの引数を GPR の r0, r1, r2, r3 で渡すような ABI を
      採用しているコンパイラに対して

      int f(int a, int b, int c, int d, int e)
      {
        ...
      }

      のような函数に対しては, 最初の 4 つの引数に対して sizeof(int) * 4 分フレーム
      サイズを変更する必要がある(かもしれない).
      この計算を行なうために第 1 引数の cum の初期化を INIT_CUMULATIVE_ARGS で行なう.
      各引数に対して

      TARGET_FUNCTION_ARG_ADVANCE

      のマクロで定義される函数が順に呼び出されるので INIT_CUMULATIVE_ARGS で初期化した
      値を順次更新していく.

      TARGET_FUNCTION_INCOMING_ARG

      のマクロで定義される函数も順次呼び出されるので上で計算した値をもとにどのレジスタを
      使用するのかを返すようにする. 上の f ならば

      引数 a に対して r0 レジスタ, 引数 b に対して r1 レジスタ, 引数 c に対して
      r2 レジスタ, 引数 d に対して r3 レジスタ, 引数 e に対してはレジスタを使用しない

      ということを示すようにする.

(*) MOVE_MAX

参照箇所の 1 つ gcc/defaults.h

#define MOVE_MAX_PIECES   MOVE_MAX

    ロード/ストア命令で指定できる最大バイト数と等しくする. 32 ビットプロセッサ
    で 8 バイトのロード/ストアがないのであれば 4 を指定する. constexpr に
    よる宣言も OK.

(*) STRICT_ALIGNMENT

参照箇所の 1 つ gcc/c/c-typeck.c

      if ((STRICT_ALIGNMENT || warn_cast_align == 2)

      ロード/ストアをワード境界をまたいで発行できないのならば 1 を指定する.
      constexpr による宣言も OK.

(*) BITS_BIG_ENDIAN

参照箇所の 1 つ gcc/combine.c

	      if (BITS_BIG_ENDIAN)

      通常は 0 に define する. 符号ビットが最下位ビットならば 1 に define する.
      constexpr による宣言も OK.

(*) BYTES_BIG_ENDIAN

参照箇所の 1 つ gcc/c/c-typeck.c

	      if (BYTES_BIG_ENDIAN)

      ビッグエンディアンならば 1 に define する. constexpr による宣言も OK.

(*) WORDS_BIG_ENDIAN

参照箇所の 1 つ gcc/c-family/c-pragma.c

  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)

      マルチワードの並びがビッグエンディアンならば 1 に define する. すなわち 
      0x123456789abcef0LL がメモリに配置されているとき以下のようになっている.

      +------------+ +0
      | 0x12345678 |
      +------------+ +4
      | 0x9abcdef0 |
      +------------+ +8

      constexpr による宣言も OK.

(*) FUNCTION_BOUNDARY

参照箇所の 1 つ gcc/c-family/c-common.c

	  value = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);

      調査中. constexpr による宣言も OK.

(*) TRAMPOLINE_SIZE

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_TRAMPOLINE_SIZE__",
				     TRAMPOLINE_SIZE);
			     
      調査中. constexpr による宣言も OK.

(*) TARGET_CPU_CPP_BUILTINS

参照箇所の 1 つ gcc/c-family/c-cppbuiltin.c

  TARGET_CPU_CPP_BUILTINS ();

      固有のプリディファインをセットする. 函数として宣言を追加しても良いのだが

#define TARGET_CPU_CPP_BUILTINS() builtin_define_std("hasegawa")

      のようにすればよい. builtin_define_std や builtin_define は libbackend.a
      の外で定義されるため.

(*) BIGGEST_ALIGNMENT

参照箇所の 1 つ gcc/defaults.h

#define ATTRIBUTE_ALIGNED_VALUE BIGGEST_ALIGNMENT

      調査中. constexpr による宣言も OK.

(*) ATTRIBUTE_ALIGNED_VALUE

参照箇所の 1 つ gcc/c-family/c-attribs.c

    align_expr = size_int (ATTRIBUTE_ALIGNED_VALUE / BITS_PER_UNIT);

      調査中. constexpr による宣言も OK.

(*) Pmode

参照箇所の 1 つ gcc/optabs.h

  create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);

      ポインタが 4 バイトならば Pmode を SImode に define する. 8 バイトならば
      DImode に, 2 バイトのならば HImode に define する. constexpr による宣言
      も OK.

(*) MAX_REGS_PER_ADDRESS

参照箇所の 1 つ gcc/reload.h

#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))

      調査中. constexpr による宣言も OK.

(*) FUNCTION_ARG_REGNO_P

参照箇所の 1 つ gcc/alias.c

    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))

      以下の宣言をしておく:

      extern bool FUNCTION_ARG_REGNO_P(int regno);

      regno が函数を呼び出すときに引数を渡すのに使用されるならば true をそうでなければ
      false を返す.

(*) ELIMINABLE_REGS

参照箇所の 1 つ gcc/builtins.c

      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;
      
      調査中.

(*) STACK_BOUNDARY

参照箇所の 1 つ gcc/defaults.h

#define MAX_STACK_ALIGNMENT STACK_BOUNDARY
      
      調査中. constexpr による宣言も OK.

(*) PARM_BOUNDARY

参照箇所の 1 つ gcc/builtins.c

  set_mem_align (dest, PARM_BOUNDARY);
      
      調査中. constexpr による宣言も OK.

(*) FUNCTION_MODE

参照箇所の 1 つ gcc/builtins.c

    function = memory_address (FUNCTION_MODE, function);
      
      調査中. 大抵は QImode に define している. constexpr による宣言も OK.

(*) REGNO_OK_FOR_BASE_P

参照箇所の 1 つ gcc/addresses.h

  return REGNO_OK_FOR_BASE_P (regno);

      調査中. extern bool REGNO_OK_FOR_BASE_P(int regno); の宣言を追加するとよい.

(*) SLOW_BYTE_ACCESS

参照箇所の 1 つ gcc/dojump.c

      if (! SLOW_BYTE_ACCESS

      調査中. constexpr による宣言も OK.

(*) ASM_OUTPUT_ALIGN

参照箇所の 1 つ gcc/dwarf2out.c

		ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));

      extern void ASM_OUTPUT_ALIGN(FILE*, int); の宣言を追加して, その
      定義を以下のようにすればよい:

void ASM_OUTPUT_ALIGN(FILE* fp, int n)
{
  fprintf(fp, "	.align	%d\n", n);
}

      もしくはマクロにしてもよい.

(*) FIRST_PARM_OFFSET

参照箇所の 1 つ gcc/defaults.h

  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)

参照箇所の 1 つ gcc/function.c

  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);

      extern int FIRST_PARM_OFFSET(tree func); の宣言を追加するとよい.
      もしくはマクロにしてもよい.  

      函数の最初の引数があるスタックのアドレスを ARG_POINTER_REGNUM で定義
      したレジスタが指すようにこの函数でオフセットを指定する.

      仮にスタックフレームが以下のようになっているとする. そして ARG_POINTER_REGNUM
      を FRAME_POINTER_REGNUM と等しくなるように宣言しているとする.

      +----------------+ <- sp_{new}
      |                | 
      |                | 
      ~   local area   ~ 
      |                | 
      |                | 
   +0 +----------------+ <- fp_{new}
      |    fp_{old}    | 
   +4 +----------------+ <- sp_{old}
      | return address | 
   +8 +----------------+
      |  1st argument  |
      +----------------+
      |  2nd argument  |
      +----------------+

      この場合は FIRST_PARM_OFFSET の戻り値は 8 になる. 函数が構造体を返す場合
      等必ずしも最初の引数がオフセット 8 にならない場合は, 実装によっては
      FIRST_PARM_OFFSET の引数の tree func に応じて返す値を調整する必要がある
      かもしれない.

(*) CASE_VECTOR_MODE

参照箇所の 1 つ gcc/expr.c

			       gen_int_mode (GET_MODE_SIZE (CASE_VECTOR_MODE),
					     Pmode));

      調査中. 大抵は Pmode に define されている. constexpr による宣言も OK.

(*) ASM_APP_ON

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_ON, asm_out_file);

      プログラムにインラインアセンブラが出現したときに始まりのマークとしてこの文字列が生成
      ファイルに書き込まれる. constexpr による宣言も OK.

(*) ASM_APP_OFF

参照箇所の 1 つ gcc/final.c

      fputs (ASM_APP_OFF, asm_out_file);

      ASM_APP_ON と対で生成ファイルに書き込まれる. インラインアセンブラの終りのマークとし
      てこの文字列が生成ファイルに書き込まれる. constexpr による宣言も OK.

(*) FUNCTION_PROFILER

参照箇所の 1 つ gcc/final.c

  FUNCTION_PROFILER (file, current_function_funcdef_no);

      プロファイルオプションを指定されたときに参照される. プロファイルのための特別な
      コードを生成する. extern void FUNCTION_PROFILER(FILE*, int); の
      宣言を追加するとよい.

(*) REGNO_OK_FOR_INDEX_P

参照箇所の 1 つ gcc/ira-costs.c

  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);

      調査中.

(*) INDEX_REG_CLASS

参照箇所の 1 つ gcc/ira-costs.c

    rclass = INDEX_REG_CLASS;

      調査中.

(*) INITIAL_ELIMINATION_OFFSET

参照箇所の 1 つ gcc/lra-eliminations.c

      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->offset);

      調査中.

(*) DEFAULT_SIGNED_CHAR

参照箇所の 1 つ gcc/opts.c

  opts->x_flag_signed_char = DEFAULT_SIGNED_CHAR;

      char が signed char と同じ範囲の値を取るか, あるいは unsigned char と同じ範囲の
      値を取るかを指定する. constexpr による宣言も OK.

以下は cc1 等のコンパイル時には必要ないが実行時にエラーを起こさないために必要な宣言

(*) PRINT_OPERAND

参照箇所の 1 つ : gcc/targhooks.c

  PRINT_OPERAND (stream, x, code);

以下の宣言を追加する:

extern void hasegawa_print_operand(FILE*, rtx, int);
#define PRINT_OPERAND hasegawa_print_operand

(*) TEXT_SECTION_ASM_OP, DATA_SECTION_ASM_OP, BSS_SECTION_ASM_OP

参照箇所の 1 つ gcc/varasm.c

#ifdef TEXT_SECTION_ASM_OP
  text_section = get_unnamed_section (SECTION_CODE, output_section_asm_op,
				      TEXT_SECTION_ASM_OP);
#endif

      文字列リテラルをマクロで指定する. .text, .data, .bss セクションに切り替えるとき
      に生成する疑似命令を指定する. プリプロセッサのディレクティブで参照されているので
      constexpr による宣言はできない.
