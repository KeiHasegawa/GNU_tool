gcc target depend declarations refered from gcc common part

(*) REGISTER_NAMES

One of refered part : gcc/reginfo.c

static const char *const initial_reg_names[] = REGISTER_NAMES;

    Specify register names with macro style. Make the `n'th element
    the name of `n'th register.

    For exaple, there are 16 GPR `r0', `r1', ..., `r15' on the target
    processor, and they are all registers which appear assembler source
    file generated this compiler. And more, target program uses `r14' as
    frame pointer and `r15' as stack pointer.
    Then declare like below:

#define REGISTER_NAMES { "r0", "r1", "r2", "r3", "r4", "r5", "r6", \
    "r7", "r8", "r9", "r10", "r11", "r12", "r13, "fp", "sp" }

#define FRAME_POINTER_REGNUM 14
#define STACK_POINTER_REGNUM 15

    "fp" and "sp" are output to assembler files instead of `r14'
    and `r15' respectively.

(*) STACK_POINTER_REGNUM

One of refered part : gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_STACK_POINTER_REGNUM__",
				     STACK_POINTER_REGNUM);

    Declare the same value with stack pointer register number. We can
    declare using `constexpr'.

(*) FRAME_POINTER_REGNUM

One of refered part : gcc/rtl.h

#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM

    Declare the same value with frame pointer register number. Like above,
    it is refered at preprocessor directive. So it must be a macro value.

(*) ARG_POINTER_REGNUM

    Specify the register number which points to the function arguments
    location at the stack. Normaly, declare the same value with
    `FRAME_POINTER_REGNUM'. Precicely refer to `FIRST_PARM_OFFSET'.
    Samely, it must be a macro value.

(*) FIRST_PSEUDO_REGISTER

One of refered part : gcc/hard-reg-set.h

          return (*regno < FIRST_PSEUDO_REGISTER);

    Declare the same value with the number of elements of `REGISTER_NAMES',
    `FIXED_REGISTERS' and `CALL_USED_REGISTERS'. We can declare using
    `constexpr'.

(*) FIXED_REGISTERS

One of refered part : gcc/reginfo.c

static const char initial_fixed_regs[] = FIXED_REGISTERS;

    Declare macro value so that the number of its elements is equal to
    that of `REGISTER_NAMES'. If `n'th register is not changed between
    before and after calling function, `n'th element is 1, otherwise 0.

(*) CALL_USED_REGISTERS

One of refered part : gcc/reginfo.c

static const char initial_call_used_regs[] = CALL_USED_REGISTERS;

    Declare macro value so that the number of its elements is equal to
    that of `REGISTER_NAMES'. If `n'th register may be changed while
    calling function, `n'th element is 1, otherwise 0.

(*) REGNO_REG_CLASS

One of refered part : gcc/calls.c

      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))

      Add the declaration and implement it:

      extern reg_class REGNO_REG_CLASS(int regno);

      This function converts register number to enum reg_class describe at
      next section.

(*) enum reg_class

One of refered part : gcc/hard-reg-set.h

  enum reg_class x_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];

      `reg_class' is refered at register allocation algorithm. There is
      a corresponding member at `reg_class' to any register number which
      is less than `FIRST_PSEUDO_REGISTER'.

      `reg_class' contains below member:

    o NO_REGS
        One of refered part : tm-preds.h(generated file)

  return NO_REGS;

    o GENERAL_REGS
        One of refered part : insn-preds.c(generated file)

    case CONSTRAINT_r: return GENERAL_REGS;

    o LIM_REG_CLASSES
        One of refered part : gcc/ira.c

      alloc_reg_class_subclasses[i][j] = LIM_REG_CLASSES;

      This must be the last member of `reg_class'.

    o ALL_REGS
        One of refered part : gcc/ira.c

    setup_reg_classes (i, GENERAL_REGS, ALL_REGS, GENERAL_REGS);

(*) N_REG_CLASSES

One of refered part : gcc/hard-reg-set.h

  HARD_REG_SET x_reg_class_contents[N_REG_CLASSES];

    Declare the same value with `LIM_REG_CLASSES' of `reg_class'. We can
    declare using `constexpr'.

(*) REG_CLASS_CONTENTS

One of refered part : gcc/reginfo.c

static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]
  = REG_CLASS_CONTENTS;

      Declare bitmap macro. Now writing.

(*) BASE_REG_CLASS

One of refered part : gcc/addresses.h

  return BASE_REG_CLASS;
      
      Under investigating. It must be the same with one of `reg_class'
      member. We can declare using `constexpr'.

(*) UNITS_PER_WORD

One of refered part : gcc/defaults.h

#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)

    Declare as the same with word size. i.e. For 32 bit processor,
    It becomes 4 normally. We can declare using `constexpr'.

(*) CUMULATIVE_ARGS

One of refered part : gcc/emit-rtl.h

  CUMULATIVE_ARGS info;

    `INIT_CUMULATIVE_ARGS' described next section refers this declaration.

(*) INIT_CUMULATIVE_ARGS

One of refered part : gcc/calls.c

  INIT_CUMULATIVE_ARGS (args_so_far_v, funtype, NULL_RTX, fndecl, n_named_args);

      Under investigating. Add below declaration:

extern void INIT_CUMULATIVE_ARGS(const CUMULATIVE_ARGS&, tree, rtx, tree, int);

(*) MOVE_MAX

One of refered part : gcc/defaults.h

#define MOVE_MAX_PIECES   MOVE_MAX

    Declare as the same value which can be maximum bytes specified at
    load/store instruction. If target processor is 32 bit and there is
    no 8 bytes load/store instruction, declare as 4. We can declare using
    `constexpr'.

(*) STRICT_ALIGNMENT

One of refered part : gcc/c/c-typeck.c

      if ((STRICT_ALIGNMENT || warn_cast_align == 2)

      Declare as 1 if load/store instruction can be issued to the address
      which strides across word boundary. We can declare using `constexpr'.

(*) BITS_BIG_ENDIAN

One of refered part : gcc/combine.c

	      if (BITS_BIG_ENDIAN)

      Under investigating. We can declare using `constexpr'.

(*) BYTES_BIG_ENDIAN

One of refered part : gcc/c/c-typeck.c

	      if (BYTES_BIG_ENDIAN)

      Under investigating. We can declare using `constexpr'.

(*) WORDS_BIG_ENDIAN

One of refered part : gcc/c-family/c-pragma.c

  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)

      Under investigating. We can declare using `constexpr'.

(*) FUNCTION_BOUNDARY

One of refered part : gcc/c-family/c-common.c

	  value = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);

      Under investigating. We can declare using `constexpr'.

(*) TRAMPOLINE_SIZE

One of refered part : gcc/c-family/c-cppbuiltin.c

      builtin_define_with_int_value ("__LIBGCC_TRAMPOLINE_SIZE__",
				     TRAMPOLINE_SIZE);
			     
      Under investigating. We can declare using `constexpr'.

(*) TARGET_CPU_CPP_BUILTINS

One of refered part : gcc/c-family/c-cppbuiltin.c

  TARGET_CPU_CPP_BUILTINS ();

      Add here own pre-defined macro like below:

#define TARGET_CPU_CPP_BUILTINS() builtin_define_std("hasegawa")

(*) BIGGEST_ALIGNMENT

One of refered part : gcc/defaults.h

#define ATTRIBUTE_ALIGNED_VALUE BIGGEST_ALIGNMENT

      Under investigating. We can declare using `constexpr'.

(*) ATTRIBUTE_ALIGNED_VALUE

One of refered part : gcc/c-family/c-attribs.c

    align_expr = size_int (ATTRIBUTE_ALIGNED_VALUE / BITS_PER_UNIT);

      Under investigating. We can declare using `constexpr'.

(*) Pmode

One of refered part : gcc/optabs.h

  create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);

      If pointer size of the target compiler is 4, define as SImode.
      If it is 8, define as DImode. If it is 2, define as HImode.
      We can declare using `constexpr'.

(*) MAX_REGS_PER_ADDRESS

One of refered part : gcc/reload.h

#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))

      Under investigating. We can declare using `constexpr'.

(*) FUNCTION_ARG_REGNO_P

One of refered part : gcc/alias.c

    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))

      Under investigating. Add below declaration:

      extern bool FUNCTION_ARG_REGNO_P(int regno);

(*) ELIMINABLE_REGS

One of refered part : gcc/builtins.c

      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;
      
      Under investigating.

(*) STACK_BOUNDARY

One of refered part : gcc/defaults.h

#define MAX_STACK_ALIGNMENT STACK_BOUNDARY
      
      Under investigating. We can declare using `constexpr'.

(*) PARM_BOUNDARY

One of refered part : gcc/builtins.c

  set_mem_align (dest, PARM_BOUNDARY);
      
      Under investigating. We can declare using `constexpr'.

(*) FUNCTION_MODE

One of refered part : gcc/builtins.c

    function = memory_address (FUNCTION_MODE, function);
      
      Under investigating. Normally define as `QImode'. We can declare
      using `constexpr'.

(*) REGNO_OK_FOR_BASE_P

One of refered part : gcc/addresses.h

  return REGNO_OK_FOR_BASE_P (regno);

      Under investigating. Add declaration like below:

      extern bool REGNO_OK_FOR_BASE_P(int regno);

(*) SLOW_BYTE_ACCESS

One of refered part : gcc/dojump.c

      if (! SLOW_BYTE_ACCESS

      Under investigating. We can declare using `constexpr'.

(*) ASM_OUTPUT_ALIGN

One of refered part : gcc/dwarf2out.c

		ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));

      Add declaration like blow:

      extern void ASM_OUTPUT_ALIGN(FILE*, int);

      And define the function like below:

void ASM_OUTPUT_ALIGN(FILE* fp, int n)
{
  fprintf(fp, "	.align	%d\n", n);
}

      You can define as a macro.

(*) FIRST_PARM_OFFSET

One of refered part : gcc/defaults.h

  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)

One of refered part : gcc/function.c

  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);

      Add declaration like below:

      extern int FIRST_PARM_OFFSET(tree func);

      And implement this function so that the register defined as
      `ARG_POINTER_REGNUM' points to first argument location of the
      function `tree func' at stack.

      Assume that the stack frame layout becomes like below and
      define `ARG_POINTER_REGNUM' the same value with `FRAME_POINTER_REGNUM'

      +----------------+ <- sp_{new}
      |                | 
      |                | 
      ~   local area   ~ 
      |                | 
      |                | 
   +0 +----------------+ <- fp_{new}
      |    fp_{old}    | 
   +4 +----------------+ <- sp_{old}
      | return address | 
   +8 +----------------+
      |  1st argument  |
      +----------------+
      |  2nd argument  |
      +----------------+

      In this case, `FIRST_PARM_OFFSET' must return 8. If the function
      return type is structure, 1st argument offset might not be 8.
      So according to the argument `tree func' of `FIRST_PARM_OFFSET',
      return value must be calcurated.

(*) CASE_VECTOR_MODE

One of refered part : gcc/expr.c

			       gen_int_mode (GET_MODE_SIZE (CASE_VECTOR_MODE),
					     Pmode));

      Under investigating. Normally define the same value with `Pmode'.
      We can declare using `constexpr'.

(*) ASM_APP_ON

One of refered part : gcc/final.c

      fputs (ASM_APP_ON, asm_out_file);

      When inline assembler appears at a program, the string defiend 
      by `ASM_APP_ON' is written to the output file. We can declare using
      `constexpr'.

(*) ASM_APP_OFF

One of refered part : gcc/final.c

      fputs (ASM_APP_OFF, asm_out_file);

      For `ASM_APP_ON', the strign defined by `ASM_APP_OFF' is written to
      the output file as the end of inline assembler. We can declare using
      `constexpr'.

(*) FUNCTION_PROFILER

One of refered part : gcc/final.c

  FUNCTION_PROFILER (file, current_function_funcdef_no);

      When specified profile option, this part is executed. So this
      part should generate the special code for profile. Add declaration
      like below:
      
      extern void FUNCTION_PROFILER(FILE*, int);

(*) REGNO_OK_FOR_INDEX_P

One of refered part : gcc/ira-costs.c

  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);

      Under investigating.

(*) INDEX_REG_CLASS

One of refered part : gcc/ira-costs.c

    rclass = INDEX_REG_CLASS;

      Under investigating.

(*) INITIAL_ELIMINATION_OFFSET

One of refered part : gcc/lra-eliminations.c

      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->offset);

      Under investigating.

(*) DEFAULT_SIGNED_CHAR

One of refered part : gcc/opts.c

  opts->x_flag_signed_char = DEFAULT_SIGNED_CHAR;

      If `char' value range is euqalt to that of `signed char', define
      it as 1. We can declare using `constexpr'.

Frome here, they are not ncessary for just building `cc1' etc, but are
necessary for get rid of compile time error.

(*) PRINT_OPERAND

One of refered part : gcc/targhooks.c

  PRINT_OPERAND (stream, x, code);

      Add declaration like below:

extern void hasegawa_print_operand(FILE*, rtx, int);
#define PRINT_OPERAND hasegawa_print_operand

(*) TEXT_SECTION_ASM_OP, DATA_SECTION_ASM_OP, BSS_SECTION_ASM_OP

One of refered part : gcc/varasm.c

      Define the string literal as a macro. Compiler refers these macro
      when switching `.text', `.data', `.bss' section. These are
      refered at preprocessor directive. So it must be a macro value.






