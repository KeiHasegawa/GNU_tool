define_split

例えば

int f(int x, int y)
{
  return x + y;
}

に対して

f:
	a := (fp)
	b := (fp+4)
	a := a + b

のような出力をしているとして,

(define_split
  [(set (match_operand:SI 0 "nonimmediate_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  "MEM_P(operands[1])"
  [(set (match_dup 1) (match_dup 0))]
  "asm(\"int3\");")

上のような出鱈目な define_split を追加すると, 埋め込んだブレークポイントに 2 度ヒットして 

f:
	(fp) := a
	(fp+4) := b
	a := a + b

上のようにソースとデスティネーションが反転することになる. これが意味のある例とは
到底思えないが define_split の機能を理解することができるだろう.
define_split の第 2 オペランドの "MEP_P(operands[1])" が "" だと一度適用した
4 バイトの代入に対する反転を再び繰り返すことになり, 再帰呼び出しが停止しないことになる.
define_expand の説明も考慮すれば

define_expand のルールの適用
define_split のルールの適用
define_insn のルールの適用

という順番になる.

define_split は m68hc11.md で以下のように使用されている:

(define_split
  [(set (cc0)
	(compare (match_operand:QI 0 "hard_addr_reg_operand" "")
		 (const_int 0)))]
  "z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode"
  [(parallel [(set (reg:HI D_REGNUM) (match_dup 1))
	      (set (match_dup 1) (reg:HI D_REGNUM))])
   (set (cc0) (compare (reg:QI D_REGNUM)
		       (const_int 0)))
   (parallel [(set (reg:HI D_REGNUM) (match_dup 1))
	      (set (match_dup 1) (reg:HI D_REGNUM))])]
  "operands[1] = gen_rtx_REG (HImode, REGNO (operands[0]));")

define_split の第 1 オペランドには split 対象とする 3 番地コードを指定する.
上の場合はざっくりと言うと

cc0 := cmp.b(op0, 0)

となる. 上の define_split の指定に対して

  if (z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode)
    return gen_split_1(insn, operands);

のようなコードが insn-recog.c に生成される.
第 2 オペランドには生成されるプログラムにそのまま複写される条件式を書く.

gen_split_1(rtx_insn*, rtx*) の定義は insn-emit.c に生成される.

rtx_insn *
gen_split_1(rtx_insn *curr_insn, rtx *operands)
{
...
  operands[1] = gen_rtx_REG (HImode, REGNO (operands[0]));
...
  emit (gen_rtx_PARALLEL (VOIDmode,
	gen_rtvec (2,
		gen_rtx_SET (gen_rtx_REG (HImode,
	1),
	operand1),
		gen_rtx_SET (copy_rtx (operand1),
	gen_rtx_REG (HImode,
	1)))), true);
...

つまり第 4 オペランドがまず, 複写され第 3 オペランドに相当する C++ コードが
最後に生成される.
