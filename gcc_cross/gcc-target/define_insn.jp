define_insn

define_insn の最も簡単な使い方は以下:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "%0 := %1 + %2")

これは SI すなわち 4 バイトの整数の加算に対する処理を定義している.

gcc の共通部分で 4 バイトの加算が生成され, それに対してコードを生成す
る必要になったとき, この部分の記述が参照されることになる.

define_insn の直後の "addsi3" により生成される函数の名前は gen_addsi3
のようになる. 実は addsi3 は

add
si
3

と 3 つがそれぞれの意味をもつ. これらを変更すると途端に違う動作になる. 簡単に説
明すると

insn-opinit.c:

  ena[31] = HAVE_adddi3;

insn-flag.h:

#define HAVE_addsi3 1

のようにこの HAVE_addsi3 が gcc の共通ソースで参照されるからである.

"nonimmediate_operand" の次の "" には "r" のように constraint と呼ばれる
制限を記述することができる.

例えば

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "m")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r")
     (match_operand:SI 2 "general_operand" "i")))]
  ""
  "%0 := %1 + %2")

は

メモリ := レジスタ + 定数

だけを扱うようにすることができる.

"%0 := %1 + %2" の 1 つ前の "" には第 2 条件を記述することができる. これは
そのまま if の条件式に複写される.

最後の "%0 := %1 + %2" はテンプレートを指定している. これがアセンブル出力に直結
する.
ここにはテンプレートでなくて以下のようにプログラムを記述することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "*
  assert(REG_P(operands[0]);
  return \"add %0, %1, %2\"";
  ")

また以下のように各 constraint に対してテンプレートを指定することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r,r,r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r,r,r")
     (match_operand:SI 2 "general_operand" "r,m,i")))]
  ""
  "@
  addr %0, %1, %2
  addm %0, %1, %2
  addi %0, %1, %2
  ")

(*) m68hc11.md の tsthi_1

通常

(define_insn "tsthi_1"
  [(set (cc0)
	(compare (match_operand:HI 0 "general_operand" "")
		 (const_int 0)))]
  ""
  ...)

のようにしても gen_tsthi_1 が呼び出されることはないが, 例えば

static rtx
m68hc11_expand_compare(enum rtx_code code, rtx op0, rtx op1)
{
...
  emit_insn(gen_rtx_SET(cc0_rtx,
			gen_rtx_COMPARE(VOIDmode, op0, op1)));

のようにターゲット固有部分で cc0 := cmp(op0, op1) のような 3 番地コード
を生成すれば gen_tsthi_1 が呼び出されるようになる.


gcc-10.2.0/gcc/rtl.def

を見れば define_insn の構文が

(define_insn sEsTV)

となることが推測できる. ここで

s : ダブルクォーテーションで囲まれた文字列
E : 3 番地コード
T : パターンもしくは * に続くプログラムテキスト
V : 属性. オプショナル.

らしい.

(*) 函数のプロローグに対して

        enter

という出力を出そうとして以下のように .md ファイルに書いてみた.

(define_insn "prologue"
  [(clobber (const_int 0))]
  ""
  "enter")

しかし期待した動作にはならない. ここで第 3 オペランドの

[(clobber (const_int 0))]

はダミーの 3 番地コードで後に続く処理で無視される.

上に対して実際に行なわれることは

gen_prologue が呼び出されたときに 

[(clobber (const_int 0))]

という 3 番地コードが生成されるということだけである.

ちょっと捻って

(define_insn "prologue"
  [(set (reg:SI 1) (reg:SI 2))]
  ""
  "enter %0, %1")

としてみた. レジスタ番号 1 が sp で 2 は fp であることに留意すると prologue の部分は

   sp := fp

がアセンブラ出力として生成される. やはりここでも "enter %0, %1" という文字列は参照されない.
このカラクリは

1. gen_prologue という函数が呼ばれる
2. [(set (reg:SI 1) (reg:SI 2))] が生成される
3. gen_movsi で 2 で生成した 3 番地コードに対して sp := fp が出力される

ということになる.

(define_insn "prologue" ...)

で第 3 オペランドに適切な式を指定すればこれでも一応 prologue のコード
生成は可能であるが, 普通は 

(define_expand "prologue" ...)

を使用したほうが良い.

ところで函数のプロローグに対して define_insn だけを使用して

   enter

とアセンブラ出力するためには,

(define_mode_iterator ALLI [BLK BI QI HI SI DI TI SF DF])

(define_insn "mov<mode>"
  [(set (match_operand:ALLI 0 "nonimmediate_operand" "")
	(match_operand:ALLI 1 "general_operand" ""))]
  ""
  "*
  return hasegawa_mov(operands[0], operands[1]);")
...

(define_insn "prologue"
  [(set (reg:SI 1) (reg:SI 2))]
  ""
  "")
...

const char* hasegawa_mov(rtx x, rtx y)
{
  if (REG_P(x) && REGNO(x) == 1 && REG_P(y) && REGNO(y) == 2)
    return "enter";

のようにすれば少し無理やりだができる. define_insn で指定する 3 番地コー
ドは他で生成されないものである必要がある. そういう 3 番地コードを新規
に作成してもよいが, やる意義が薄いので深くは追求しない.

ところで

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  ...)

のように記述した場合に gen_addsi3 では

  [(set (operand0 (plus::SI (operand1, operand2))))]

のような 3 番地コードを生成する.


