define_insn

define_insn の最も簡単な使い方は以下:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "%0 := %1 + %2")

これは SI すなわち 4 バイトの整数の加算に対する処理を定義している.
define_insn の直後の "addsi3" により生成される函数の名前は gen_addsi3
のようになる.

"nonimmediate_operand" の次の "" には "r" のように constraint と呼ばれる
制限を記述することができる.

例えば

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "m")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r")
     (match_operand:SI 2 "general_operand" "i")))]
  ""
  "%0 := %1 + %2")

は

メモリ := レジスタ + 定数

だけを扱うようにすることができる.

"%0 := %1 + %2" の 1 つ前の "" には第 2 条件を記述することができる. これは
そのまま if の条件式に複写される.

最後の "%0 := %1 + %2" はテンプレートを指定している. これがアセンブル出力に直結
する.
ここにはテンプレートでなくて以下のようにプログラムを記述することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "*
  assert(REG_P(operands[0]);
  return \"add\ %0, %1, %2\"";
  ")

また以下のように各 constraint に対してテンプレートを指定することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r,r,r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r,r,r")
     (match_operand:SI 2 "general_operand" "r,m,i")))]
  ""
  "@
  addr %0, %1, %2
  addm %0, %1, %2
  addi %0, %1, %2
  ")

(*) m68hc11.md の tsthi_1

通常

(define_insn "tsthi_1"
  [(set (cc0)
	(compare (match_operand:HI 0 "general_operand" "")
		 (const_int 0)))]
  ""
  ...)

のようにしても gen_tsthi_1 が呼び出されることはないが, 例えば

static rtx
m68hc11_expand_compare(enum rtx_code code, rtx op0, rtx op1)
{
...
  emit_insn(gen_rtx_SET(cc0_rtx,
			gen_rtx_COMPARE(VOIDmode, op0, op1)));

のようにターゲット固有部分で cc0 := cmp(op0, op1) のような 3 番地コード
を生成すれば gen_tsthi_1 が呼び出されるようになる.
