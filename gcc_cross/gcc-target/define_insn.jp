define_insn

define_insn の最も簡単な使い方は以下:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "%0 := %1 + %2")

これは SI すなわち 4 バイトの整数の加算に対する処理を定義している.
define_insn の直後の "addsi3" だが

add si 3

とそれぞれに意味があってこのどれかを間違えると途端に期待しない動作になってしまう.

"nonimmediate_operand" の次の "" には "r" のように constraint と呼ばれる
制限を記述することができる.

例えば

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "m")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r")
     (match_operand:SI 2 "general_operand" "i")))]
  ""
  "%0 := %1 + %2")

は

メモリ := レジスタ + 定数

だけを扱うようにすることができる.

"%0 := %1 + %2" の 1 つ前の "" には第 2 条件を記述することができる. これは
そのまま if の条件式に複写される.

最後の "%0 := %1 + %2" はテンプレートを指定している. これがアセンブル出力に直結
する.
ここにはテンプレートでなくて以下のようにプログラムを記述することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  ""
  "*
  assert(REG_P(operand[0]);
  return \"add\ %0, %1, %2\"";
  ")

また以下のように各 constraint に対してテンプレートを指定することができる:

(define_insn "addsi3"
  [(set
    (match_operand:SI 0 "nonimmediate_operand" "r,r,r")
    (plus:SI
     (match_operand:SI 1 "general_operand" "r,r,r")
     (match_operand:SI 2 "general_operand" "r,m,i")))]
  ""
  "@
  addr %0, %1, %2
  addm %0, %1, %2
  addi %0, %1, %2
  ")
