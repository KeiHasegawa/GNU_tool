define_peephole2

See also "define_peephole"

Think about below situation:

int f(int x, int y)
{
  return x + y;
}

For above code, assume that `cc1' generates with -O2 option like below:

f:
	a := (sp+-1) + (sp+3)

Then add below into `.md' file:

(define_peephole2
  [(set (match_operand:SI 0 "nonimmediate_operand" "")
    (plus:SI
     (match_operand:SI 1 "general_operand" "")
     (match_operand:SI 2 "general_operand" "")))]
  "puts(\"peephole2\")"
  [(set (match_dup 1) (match_dup 0))]
  "asm(\"int3\");")

Of cause, above is unreasonable. Anyway, envoke `cc1' with -O2 option
similarly. Then after

peephole2

is output and the software break point is hit, `cc1' generates like below:

f:
	(sp+-1) := a

Again of cause, this is unreasonable. But we can understand the
function of `define_peephole2'. Instead of -O2 option, with -O1 option,
above is not applied.
