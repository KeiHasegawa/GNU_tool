For install `hasegawa-elf-gcc', do like below:

% xz -d -c ../gcc-10.2.0.tar.xz | tar xf -
% mv gcc-10.2.0 gcc-10.2.0.hasegawa-elf
% cd gcc-10.2.0.hasegawa-elf
% patch -p1 < ../gcc-10.2.0.hasegawa-elf.diff
% tar xvf ../hasegawa-elf.tar
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=hasegawa-elf --with-newlib
% make all-gcc

As this result, built `cc1' generates 3 address code into assembler file,
which are already assigned registers. Of cause, there doesn't exist some
assembler which asssembles it.

At the build process of `cc1' etc, there are generated file like below:

build/genxxx ... > tmp-xxx.c
move-if-change tmp-xxx.c insn-xxx.c

And compile them and build `libbackend.a', which is referenced when
building `cc1'.

(*) genmodes

No input file.

-h : generates declaration of `enum machine_mode'
-i : generates inline function definition of
    `mode_size_inline(machine_mode)', `mode_nunits_inline(machine_mode)', etc
-m : generates like below:

const char *const mode_name[NUM_MACHINE_MODES] =
{
  "VOID",
  "BLK",

(*) genmddeps

generates `.md' file dependency for Makefile.

(*) gengtype

Under investigation.

(*) genconstants

(define_constants [(AAA 123) (BBB 456)])

For above, generates like below:

#define AAA 123
#define BBB 456

(*) gengenrtl

generates macro definition of `gen_rtx_SET(x, y)' etc. This generation result
doesn't depends on `.md' file.

(*) genpreds

Without option,

(define_predicate "func" (match_code "subreg,reg,mem") "hoge();")

For above, generates like below:

static inline int
func_1 (rtx op ATTRIBUTE_UNUSED, machine_mode mode ATTRIBUTE_UNUSED)
{
  return hoge();
}

int
func (rtx op, machine_mode mode ATTRIBUTE_UNUSED)
{
  switch (GET_CODE (op))
    {
    case SUBREG:
    case REG:
    case MEM:
      break;
    default:
      return false;
    }
  return ((func_1 (op, mode))) && ((mode == VOIDmode || GET_MODE (op) == mode));
}

-h : generates `func' declaration.

-c :

(define_memory_constraint "xyz" "mannual string" (match_test "func(op)"))

For above, generates like below:

static inline bool satisfies_constraint_xyz(rtx op)
{
  return func(op);
}

(*) genconditions

generates C++ source file reading `.md' file. Let the file name
`gencondmd.cpp', generates `gencodmd' program like below:

g++ -o gencondmd gencondmd.o ...

which is describe next section. For example, assume that `.md' file becomes
like below:

(define_insn "jump" [(set (pc) (label_ref (match_operand 0 "" "")))] "foo"
"jump	%l0")

Then `genconditions' generates like below:

static const struct c_test insn_conditions[] = {
  { "foo",  __builtin_constant_p (foo)  ? (int) (foo)  : -1 },
};

(*) gencondmd

From the file generated by `genconditions' described previous section,
generates like below:

(define_conditions [(-1 "foo")])

(*) genflags

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  "456"
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

For above, generates like below

#define HAVE_movsi (456)
extern rtx        gen_movsi (rtx, rtx);

(*) genattr

Under investigation.

(*) genattr-common

Under investigation.

(*) gencodes

generates declaration of `enum insn_code'. For example,

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

(define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   "123"
   "jump	%l0")

For above, generates like below:

enum insn_code {
  CODE_FOR_nothing = 0,
  CODE_FOR_jump = 1,
  CODE_FOR_movsi = 2
};

const unsigned int NUM_INSN_CODES = 3;

(*) genconfig

Under investigation.

(*) gentarget-def

(define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   "123"
   "jump	%l0")

For above, generates like below:

static bool
target_have_jump (void)
{
  return 123;
}

static rtx_insn *
target_gen_jump (rtx x0)
{
  gcc_checking_assert (targetm.have_jump ());
  return insnify (gen_jump (x0));
}

#undef TARGET_HAVE_JUMP
#define TARGET_HAVE_JUMP target_have_jump
#undef TARGET_GEN_JUMP
#define TARGET_GEN_JUMP target_gen_jump

(*) gencheck

generates macro definition of XXX_CHECK(t), where type of `t' is `tree'.

(*) genhooks

No input file. This program generates macro definitions which are generated at

gcc_target targetm = TARGET_INITIALIZER;

Also it is used like below:

./genfhooks -d ../.././gcc/doc/tm.texi.in > tmp-tm.texi

for generating the document.

(*) genopinit

is envoked like below:

./genoptinit -hfoo.h -cfoo.c

For below:

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

generates like below:

static const struct optab_pat pats[NUM_OPTAB_PATTERNS] = {
  { 0x810006, CODE_FOR_movsi },
};

void
init_all_optabs (struct target_optabs *optabs)
{
  bool *ena = optabs->pat_enable;
  ena[0] = HAVE_movsi;
}
...

(*) genattrtab

is evoked like below:

build/genattrtab x.md -Aa.c -Db.c -Lc.c

Under investigation.

a.c : ???

b.c : Almost empty file.

b.c : Almost empty file.

(*) genautomata

generates almost empty file. Under investigation.

(*) genemit

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

(define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   "1"
   "jump	%l0")

For above, generates like below:

rtx gen_jump (rtx operand0)
{
  return gen_rtx_SET(pc_rtx, gen_rtx_LABEL_REF (VOIDmode, operand0));
}

rtx gen_movsi (rtx operand0, rtx operand1)
{
  {
    rtx operands[2];
    operands[0] = operand0;
    operands[1] = operand1;
#define DONE return (_val = get_insns (), end_sequence (), _val)
    emit_insn(gen_rtx_SET(operands[0], operands[1]));
    DONE;
  } 

  emit_insn (gen_rtx_SET (operand0, operand1));
  _val = get_insns();
  end_sequence ();
  return _val;
}

(*) genextract

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

(define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   "1"
   "jump	%l0")

For above, generates like below:

void
insn_extract (rtx_insn *insn)
{
  rtx *ro = recog_data.operand;
  ...
  switch (INSN_CODE (insn))
    {
    default:
      // error
    case 1: /* jump */
      ro[0] = *(ro_loc[0] = &XEXP (XEXP (pat, 1), 0));
      break;
    }
}

Note that no output about `movsi'. i.e. the output depends on `define_insn'
but doesn't depend on `define_expand'.

(*) gencfn-macros

generates macro definition of CASE_CFN_XXX.

(*) genoutput

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "
  emit_insn(gen_rtx_SET(operands[0], operands[1]));
  DONE;
  ")

(define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   "1"
   "jump	%l0")

For above, generates oke below:


static const struct insn_operand_data operand_data[] = {
  { 0,               "", E_VOIDmode, 0, 0, 0, 0 },
  { 0,               "", E_VOIDmode, 0, 0, 1, 0 },
  { general_operand, "", E_SImode,   0, 0, 1, 1 },
  { general_operand, "", E_SImode,   0, 0, 1, 1 },
};

const struct insn_data_d insn_data[] = {
  /* <internal>:0 */
  { "*placeholder_for_nothing",
     { 0 }, { 0 }, &operand_data[0], 0, 0, 0, 0, 0},
  { "jump",
     { "jump	%l0" }, { (insn_gen_fn::stored_funcptr) gen_jump },
     &operand_data[1], 1, 1, 0, 0, 1
  },
  { "movsi",
    { 0 },              { (insn_gen_fn::stored_funcptr) gen_movsi },
     &operand_data[2], 2, 2, 0, 0, 0
  }
};

(*) genpeep

Refer to "define_peep".

(*) genrecog

(define_insn "jump" [(set (pc) (label_ref (match_operand 0 "" "")))] "foo"
"jump	%l0")

For above, generates like below:


int recog(rtx x1, rtx_insn *insn,int *pnum_clobbers)
{
  rtx * const operands = &recog_data.operand[0];
  recog_data.insn = NULL;
  if (GET_CODE (x1) != SET)
    return -1;
  rtx x2 = XEXP (x1, 1);
  if (GET_CODE (x2) != LABEL_REF)
    return -1;
  rtx x3 = XEXP (x1, 0);
  if (GET_CODE (x3) != PC)
    return -1;
  rtx x4 = XEXP (x2, 0);
  operands[0] = x4;
  if (!(foo))
    return -1;
  return 1; /* jump */
}

But,

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand")
        (match_operand:SI 1 "general_operand"))]
  ""
  "")

For above, generates function code which just returns -1.

(*) genenums

Under investigation.

(*) genchecksum

generates checksum by reading `.o' and `.a' files.

