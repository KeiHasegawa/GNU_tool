(*1)

long a = 0x12345678;

オリジナルの pdp11-elf-gcc

_a:
	.word	011064 /* short */  /* 0x1234 */
	.word	053170 /* short */  /* 0x5678 */

現状の自前の cc1

_a:
	.short	22136  /* 0x5678 */
	.short	4660   /* 0x1234 */

自前の cc1 は PDP エンディアンに対応していない. 何かのマクロでこれが切り替えられた
と思うが思い出せない.

(*2)
オリジナルの pdp11-elf-gcc の si * si のコードだがおそらくできていないように思える.
以下が f を呼び出すコード.

	mov LC_1+02,-(sp)
	mov LC_1,-(sp)
	mov LC_2+02,-(sp)
	mov LC_2,-(sp)
	jsr pc, _f

これ自体は問題ないが, f のコードは

_f:
	mov r5, -(sp)
	mov sp, r5
	sub $020, sp
	mov r2, -(sp)

	mov -4(r5),r0  ★
	mov -2(r5),r1

なのでいきなり初期化されていない領域を参照している. おそらくここに第一引数があればそれなり
に動く可能性があると思い

_f:
	mov r5, -(sp)
	mov sp, r5
	sub $020, sp
	mov r2, -(sp)

	mov 4(r5), -4(r5)  ★
	mov 6(r5), -2(r5)  ★
	mov -4(r5),r0
	mov -2(r5),r1

のようにしてみたがやはりできていない. si::mul は難しそうなので一旦保留する.
単純にランタイムライブラリ函数呼び出しにしておけば良さそうに思える.

2022.05.17 14:46 ランタイムライブラリ函数呼び出しになっていることを確認した.

(*3)
di * di
オリジナルの pdp11-elf-gcc のように ___muldi3 の呼び出しにしたが ___muldi3 内で不正
メモリアクセスが発生している. もしかするとそもそもができていないのかもしれないが, 現状では
デバッグ情報がオリジナルの libgcc.a 内にないので調査も保留しておく.
