AVR の特徴

命令用メモリ 128 KB
データ用 SRAM 64 KB - 0x60
ほとんどが命令長 16 ビット
8 bit 汎用レジスタ 32 個

 命令用メモリ空間
+--------------+ 0x00000
|              |
|              |
|              |
|              |
|              |
|              |
|              |
|              | 
|              | 
|              |
|              |
+--------------+ 0x20000

他のマイコンと大きく異なる点は命令用とデータ用でメモリ空間が分かれていることで, 命令用の
メモリにストア命令を発行することはできない. しかし LPM 命令でロードならばできる.
.data や .rodata の変数の初期値もここにロードされる.


データメモリ空間
+--------------+ 0x00000
|     r0       |
|     .        |
|     .        |
|     .        |
|     r31      |
+--------------+ 0x00020
|              |
|              |
| I/O レジスタ   |
|              |
| スタックポインタ| 0x0005d
|              |
+--------------+ 0x00060
|              |
|              |
|    SRAM      |
|              |
|              |
+--------------+ 0x10000

データメモリ空間の先頭 32 バイトは汎用レジスタにマップされている.
さらに続く 0x40 バイトは I/O レジスタにマップされている.
特に, I/O レジスタ領域のオフセット 0x3d から 2 バイトはスタックポインタ
の役割をしている. つまり rcall, ret, push, pop 命令によって参照され, 更新される.
最後の 0x10000 - 0x60 バイトはプログラムが自由に使ってよい領域である.
SRAM と言った場合上の全体を指すこともある.

(*1) 簡単なサンプル

test000_start.S は main 函数を呼び出し, そこから加算をする f を呼び出して終了するという
もの.

test000_start.S ではスタックポインタをセットするため

	ldi r16, 0xff
	out 0x3d, r16
	ldi r16, 0xfe
	out 0x3e, r16

のようにしている. これでスタックポインタが 0xfffe になる.
シミュレータは仮想アドレス 0x00800000 は SRAM の先頭アドレスとして
解釈する. 

(avr-elf-gdb) x/2bx 0x0080005d

のようにすれば上の命令の実行でメモリが書き替えられるのが確認できる.
また r16 を ldi 命令で使用しているから

(arv-elf-gdb) x/1xb 0x00800010

のようにすればレジスタが書き替えられていて, このアドレスにマップされていることも確認できる.

(*2) 文字列

test001.c は文字の長さを計算する f を呼び出すプログラムである.
arv-elf-gcc は文字を通常のコンパイラと同じように .rodata セクションに
出力する.

    LOAD off    0x000000fc vaddr 0x00800060 paddr 0x00000088 align 2**0
         filesz 0x0000000e memsz 0x0000000e flags rw-


これはロードされるアドレスが命令用メモリの 0xfc 番地だが参照されるアドレスが

0x00800060

すなわちデータ用メモリの 0x60 番地ということなのでそのアドレスに main を呼び出す前にコピ
ーしておく必要がある.

(*3) hello world

「newlib」に libc.a のコンパイルとインストールの方法を書いておいた.

test002.c は "hello world" を出力しようとして試してみたが, このやり方では

_write

も呼び出されない. しかし main で printf (本当は puts だが)を呼び出した後に

(avr-elf-gdb) p my_buffer

とすれば, そこに "hello world\n" の文字が格納されていることを確認できる.
今回はこれで満足しておく.
