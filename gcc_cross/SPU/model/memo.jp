cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

以下開発メモ

(*1)
spu-elf-gcc では __vector をキーワードとして認識しているのでそれができるようにする必要が
ある.

字句解析器が __vector を読み込んだときに cc1 が独自の処理を行なうために以下の宣言を
追加する.

extern void spu_cpu_cpp_builtins(struct cpp_reader * pfile);
#define TARGET_CPU_CPP_BUILTINS() spu_cpu_cpp_builtins(pfile)

そして函数 spu_cpp_builtins では以下のようにキーワード __vector を登録しておく.
またマクロ展開に際して呼び出されるコールバック函数の登録を行なっておく.

void spu_cpu_cpp_builtins(cpp_reader* pfile)
{
  cpp_define (pfile, "__SPU__");
  cpp_define(pfile, "__vector=__attribute__((__spu_vector__))");    ★
  __vector_keyword = get_identifier("__vector");                    ★
  C_CPP_HASHNODE(__vector_keyword)->flags |= NODE_CONDITIONAL;      ★
  cpp_get_callbacks(pfile)->macro_to_expand = spu_macro_to_expand;  ★
}

(*2)
2022.06.17 13:07 現状

typedef __vector int vec_int4;

vec_int4 f(vec_int4 a, vec_int4 b)
{
  return a + b;
}

をコンパイルすると

a.c:1:1: 警告: ‘spu_vector’ 属性指示が無視されました [-Wattributes]
    1 | typedef __vector int vec_int4;
      | ^~~~~~~

のように警告が出力される. また生成されているコードは vec_int4 を int のように解釈している
コードになっている.

実際に属性指示なるものが無視されているのが自前の cc1 でオリジナルの cc1 では無視されている
ような状況なのでオリジナルの cc1 の動作を確認してみる.

まず警告が出力されている箇所を確認する.

      if (spec == NULL)
	{
	  if (!(flags & (int) ATTR_FLAG_BUILT_IN))
	    {
	      if (ns == NULL_TREE || !cxx11_attr_p)
		warning (OPT_Wattributes, "%qE attribute directive ignored",
			 name);  ★


以下のようにしてターゲット固有の属性指示を追加する:

static const attribute_spec spu_attribute_table[] =
{
  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,
       affects_type_identity, handler, exclude } */
  { "spu_vector",     0, 0, false, true,  false, false,
    spu_handle_vector_attribute, NULL },
  { NULL,             0, 0, false, false, false, false, NULL, NULL }
};

#undef  TARGET_ATTRIBUTE_TABLE
#define TARGET_ATTRIBUTE_TABLE spu_attribute_table

また spu_handle_vector_attribute で返す型の初期化を行なう:

static void spu_init_builtins()
{
  V4SI_type_node = build_vector_type(intSI_type_node, 4);
...
}

これらの型を扱えるようにするには machine_mode の追加が必要になる:

spu-modes.def:

VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */

VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */ 

(*3)
2022.06.17 17:38 現状

typedef __vector int vec_int4;

vec_int4 f(vec_int4 a, vec_int4 b)
{
  return a + b;
}

をコンパイルすると以下のように内部エラーが発生してしまう.

during RTL pass: expand
a.c: 関数 ‘f’ 内:
a.c:5:12: コンパイラ内部エラー: default_libcall_value 内、位置 targhooks.c:974
    5 |   return a + b;
      |          ~~^~~
0x8a7f715 default_libcall_value(machine_mode, rtx_def const*)
	../.././gcc/targhooks.c:974

(gdb) b targhooks.c:974
(gdb) run
...
targhooks.c:974 のブレークポイントにヒット
(gdb) where
#0  expand_binop (mode=E_TImode, binoptab=xor_optab, op0=0xb78db5dc, op1=0xb78db5f0, target=0xb78db604, unsignedp=1, methods=OPTAB_LIB_WIDEN) at ../.././gcc/optabs.c:1162
#1  0x086ef034 in expand_expr_real_2 (ops=0xbffff0bc, target=0xb78db604, tmode=E_TImode, modifier=EXPAND_NORMAL) at ../.././gcc/expr.c:9856
#2  0x085b392f in expand_gimple_stmt_1 (stmt=0xb78d5104) at ../.././gcc/cfgexpan
...

mode=E_TImode, binoptab=xor_optab と全く期待しない動作になっている.
正しくできているオリジナルの cc1 で確認してみた.

(gdb) b expand_binop
(gdb) run
...
Breakpoint 1, expand_binop (mode=E_V4SImode, binoptab=add_optab, op0=0xb79cc870, op1=0xb79cc890, target=0xb79b7cbc, unsignedp=0, methods=OPTAB_LIB_WIDEN) at ../.././gcc/optabs.c:1159
(gdb)

mode=E_V4SImode, binoptab=add_optab でこれは勿論だが期待した結果.

(*4)
2022.06.18 6:24 現時点で (*3) のエラーを回避できていない. tree -> gimple の
変換が期待したものになっていないのが主な原因.

  gsi = gsi_start (stmts);
  if (!gsi_end_p (gsi))
    {
      stmt = gsi_stmt (gsi);  ★
      if (gimple_code (stmt) != GIMPLE_LABEL)
	stmt = NULL;
    }

自前の cc1 の結果は以下:
(gdb) p debug_gimple_stmt(stmt)
_6 = VIEW_CONVERT_EXPR<uint128_t>(a_2(D));
$46 = void
(gdb)

オリジナルの cc1 の結果は以下:
(gdb) p debug_gimple_stmt(stmt)
_3 = a_1(D) + b_2(D);
$6 = void
(gdb)

ここで違いが出ている. 上のコードは基本ブロックを構成する gimple を取り出しているところで
tree -> gimple の変換はこれに先立って行なわれている.

「GNU のツール」 => 「cc1 の抽象コードの調査」 でこれは既に調査していた:

(gdb) b gimplify.c:14806
(gdb) run
(gdb) p debug_gimple_stmt(seq)
{
  _1 = a + b;
  <retval> = _1;
  return <retval>;
}
$48 = void
(gdb)

ここは期待通りの変換.

オリジナルの cc1 は gcc-9.1.0 なので行番号が少し違うが以下の結果:

(gdb) b gimplify.c:13674
(gdb) p debug_gimple_stmt(seq)
{
  D.2180 = a + b;
  return D.2180;
}
$7 = void
(gdb)

ここから a + b を変換する方法がオリジナルと自前の cc1 とで異なるということ.
この時点の勝手な想像だが, 新しく導入した型 V4SI に対して加算が定義されていないので意図しない
変換が発生しているということ.

まずは違いが最初に確認される gimple を生成している瞬間を確認する.

      scalar_int_mode mode
	= int_mode_for_size (tree_to_uhwi (TYPE_SIZE (type)), 0).require ();
      compute_type = lang_hooks.types.type_for_mode (mode, 1);
      result = f (gsi, compute_type, a, b, NULL_TREE, NULL_TREE, code, type); ★
      warning_at (loc, OPT_Wvector_operation_performance,
	          "vector operation will be expanded with a "
		  "single scalar operation");


(gdb) p mode
$62 = {m_mode = E_TImode}
(gdb) p debug_tree(a)
 <ssa_name 0xb78b90a0
    type <vector_type 0xb78c2d80 vec_int4
        type <integer_type 0xb7a4b3c0 int public SI
            size <integer_cst 0xb7850c08 constant 32>
            unit-size <integer_cst 0xb7850c1c constant 4>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b3c0 precision:32 min <integer_cst 0xb7850de8 -2147483648> max <integer_cst 0xb7850dfc 2147483647>
            pointer_to_this <pointer_type 0xb7a4bf00>>
        BLK
        size <integer_cst 0xb7850ed8 constant 128>
        unit-size <integer_cst 0xb7850eec constant 16>
        align:128 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb78c2a80 nunits:4 context <translation_unit_decl 0xb78591c8 a.c>
        pointer_to_this <pointer_type 0xb78c2ea0>>
    var <parm_decl 0xb78590e4 a>
    def_stmt GIMPLE_NOP
    version:2>
$63 = void
(gdb) p debug_tree(b)
 <ssa_name 0xb78b90c8
    type <vector_type 0xb78c2d80 vec_int4
...    
    var <parm_decl 0xb7859130 b>
...
(gdb) p debug_tree(result)
 <ssa_name 0xb78b9258
    type <integer_type 0xb7a4b780 public unsigned TI
        size <integer_cst 0xb7850ed8 constant 128>
        unit-size <integer_cst 0xb7850eec constant 16>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b780 precision:128 min <integer_cst 0xb7850f50 0> max <integer_cst 0xb785a0d8 0xffffffffffffffffffffffffffffffff>>
   
    def_stmt _13 = _11 ^ _12;
    version:13>
$66 = void
(gdb)

mode がまず期待したものになっていない. そして debug_tree(result) の結果も期待した
ものではない.

static enum gimplify_status
gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)
{
...
  /* Gimplify the body into the GIMPLE_BIND tuple's body.  */
  body = NULL;
  gimplify_stmt (&BIND_EXPR_BODY (bind_expr), &body);  ★
  gimple_bind_set_body (bind_stmt, body);

できているオリジナルの cc1 ではこのポイントで

_3 = a_1(D) + b_2(D);

を生成しているのに対して, 自前の cc1 では

_1 = a + b;

はそのままでこの後, expand_vector_operations が呼び出され結果的に意図しない gimple が
生成されている.

static void
expand_vector_operations_1 (gimple_stmt_iterator *gsi)
{
...
  if (compute_type == type)
    return;                   ★ ここで返るのが期待値

以下は自前の cc1 の結果: 
(gdb) p debug_tree(compute_type)
 <integer_type 0xb7a4b3c0 int public SI
    size <integer_cst 0xb7850c08 type <integer_type 0xb7a4b0c0 bitsizetype> constant 32>
    unit-size <integer_cst 0xb7850c1c type <integer_type 0xb7a4b060 sizetype> constant 4>
    align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b3c0 precision:32 min <integer_cst 0xb7850de8 -2147483648> max <integer_cst 0xb7850dfc 2147483647>
    pointer_to_this <pointer_type 0xb7a4bf00>>
$76 = void
(gdb) p debug_tree(type)
 <vector_type 0xb78c2a80
    type <integer_type 0xb7a4b3c0 int public SI
        size <integer_cst 0xb7850c08 constant 32>
        unit-size <integer_cst 0xb7850c1c constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b3c0 precision:32 min <integer_cst 0xb7850de8 -2147483648> max <integer_cst 0xb7850dfc 2147483647>
        pointer_to_this <pointer_type 0xb7a4bf00>>
    BLK
    size <integer_cst 0xb7850ed8 type <integer_type 0xb7a4b0c0 bitsizetype> constant 128>
    unit-size <integer_cst 0xb7850eec type <integer_type 0xb7a4b060 sizetype> constant 16>
    align:128 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb78c2a80 nunits:4 context <translation_unit_decl 0xb78591c8 a.c>
    pointer_to_this <pointer_type 0xb78c2f00>>
$77 = void
(gdb)

compute_type が vector_type になっていない.

  if (compute_type == NULL_TREE)
    compute_type = get_compute_type (code, op, type);  ★

ここで計算されていた.

(gdb) p code
$80 = PLUS_EXPR
(gdb) p op
$81 = add_optab
(gdb) p debug_tree(type)
 <vector_type 0xb78c2a80
    type <integer_type 0xb7a4b3c0 int public SI
        size <integer_cst 0xb7850c08 constant 32>
        unit-size <integer_cst 0xb7850c1c constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b3c0 precision:32 min <integer_cst 0xb7850de8 -2147483648> max <integer_cst 0xb7850dfc 2147483647>
        pointer_to_this <pointer_type 0xb7a4bf00>>
    BLK
    size <integer_cst 0xb7850ed8 type <integer_type 0xb7a4b0c0 bitsizetype> constant 128>
    unit-size <integer_cst 0xb7850eec type <integer_type 0xb7a4b060 sizetype> constant 16>
    align:128 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb78c2a80 nunits:4 context <translation_unit_decl 0xb78591c8 a.c>
    pointer_to_this <pointer_type 0xb78c2f00>>
$82 = void
(gdb) 

get_compute_type で vector が返っていない. その原因を調査する.


  if (op
      && (!VECTOR_MODE_P (TYPE_MODE (type))
	  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing))  ★
    {

この条件が成立するのが自前の cc1. 成立しないのがオリジナルの cc1. この部分のマクロ展開は
以下:

  if (op
      && (!(((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_BOOL || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_INT || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_FLOAT || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_FRACT || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_UFRACT || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_ACCUM || ((enum mode_class) mode_class[((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)]) == MODE_VECTOR_UACCUM)
   || optab_handler (op, ((((enum tree_code) ((type))->base.code) == VECTOR_TYPE) ? vector_type_mode (type) : (type)->type_common.mode)) == CODE_FOR_nothing))

これは大変だ. -g3 でリコンパイルした.

以下はオリジナルの cc1 の結果:

(gdb) p op
$17 = add_optab
(gdb) p VECTOR_MODE_P (TYPE_MODE (type))
$18 = true
(gdb) p optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)
Junk after end of expression.
(gdb) p optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing
$19 = false
(gdb)

以下は自前の cc1 の結果:

(gdb) p op
$83 = add_optab
(gdb) p VECTOR_MODE_P (TYPE_MODE (type))
$84 = false
(gdb) p optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing
$85 = true
(gdb)

3 つ目の条件が違っているのも気にはなるがまずは VECTOR_MODE_P (TYPE_MODE (type)) が
false になる理由を調査する.

以下は自前の cc1 の結果:

(gdb) p debug_tree(type)
 <vector_type 0xb78c2a80
    type <integer_type 0xb7a4b3c0 int public SI
        size <integer_cst 0xb7850c08 constant 32>
        unit-size <integer_cst 0xb7850c1c constant 4>
        align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7a4b3c0 precision:32 min <integer_cst 0xb7850de8 -2147483648> max <integer_cst 0xb7850dfc 2147483647>
        pointer_to_this <pointer_type 0xb7a4bf00>>
    BLK  ★
    size <integer_cst 0xb7850ed8 type <integer_type 0xb7a4b0c0 bitsizetype> constant 128>
    unit-size <integer_cst 0xb7850eec type <integer_type 0xb7a4b060 sizetype> constant 16>
    align:128 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb78c2a80 nunits:4 context <translation_unit_decl 0xb78591c8 a.c>
    pointer_to_this <pointer_type 0xb78c2f00>>
$99 = void
(gdb) 

以下はオリジナルの cc1 の結果
(gdb) p debug_tree(type)
 <vector_type 0xb79aa180 vec_int4
    type <integer_type 0xb7aeb3c0 int public SI
        size <integer_cst 0xb78f0cbc constant 32>
        unit-size <integer_cst 0xb78f0cd0 constant 4>
        align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7aeb3c0 precision:32 min <integer_cst 0xb78f0e9c -2147483648> max <integer_cst 0xb78f0eb0 2147483647>
        pointer_to_this <pointer_type 0xb7aebde0>>
    V4SI   ★
    size <integer_cst 0xb78f0f8c type <integer_type 0xb7aeb0c0 bitsizetype> constant 128>
    unit-size <integer_cst 0xb78f0fa0 type <integer_type 0xb7aeb060 sizetype> constant 16>
    align:128 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0xb7960b40 nunits:4 context <translation_unit_decl 0xb78fa1c8 a.c>>
$20 = void
(gdb)

違っている.

      mode = TYPE_MODE (node);
      fprintf (file, " %s", GET_MODE_NAME (mode));

この部分のマクロ展開は

      mode = ((((enum tree_code) ((node))->base.code) == VECTOR_TYPE) ? vector_type_mode (node) : (node)->type_common.mode);
      fprintf (file, " %s", mode_name[mode]);


(gdb) p ((((enum tree_code) ((node))->base.code) == VECTOR_TYPE) ? vector_type_mode (node) : (node)->type_common.mode)
$110 = E_BLKmode
(gdb) p (((enum tree_code) ((node))->base.code) == VECTOR_TYPE)
$111 = true
(gdb) p vector_type_mode (node)
$112 = E_BLKmode
(gdb) p node
$113 = (tree) 0xb78c2a80
(gdb) 


  mode = t->type_common.mode;
  if (VECTOR_MODE_P (mode)
      && (!targetm.vector_mode_supported_p (mode)  ★
	  || !have_regs_of_mode[mode]))
    {
      scalar_int_mode innermode;


これっぽい. 以下を追加:

static bool spu_vector_mode_supported_p(machine_mode mode)
{
  switch (mode) {
  case E_V16QImode:
  case E_V8HImode:
  case E_V4SImode:
  case E_V2DImode:
  case E_V4SFmode:
  case E_V2DFmode:
    return true;
  default:
    return false;
  }
}

#undef TARGET_VECTOR_MODE_SUPPORTED_P
#define TARGET_VECTOR_MODE_SUPPORTED_P	spu_vector_mode_supported_p

しかしまだ条件が成立する.

  if (VECTOR_MODE_P (mode)
      && (!targetm.vector_mode_supported_p (mode)
	  || !have_regs_of_mode[mode]))  ★

この部分のマクロ展開は以下:

  if ((((enum mode_class) mode_class[mode]) == MODE_VECTOR_BOOL || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_INT || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_FLOAT || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_FRACT || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_UFRACT || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_ACCUM || ((enum mode_class) mode_class[mode]) == MODE_VECTOR_UACCUM)
      && (!targetm.vector_mode_supported_p (mode)
   || !((&default_target_regs)->x_have_regs_of_mode)[mode]))  ★


(gdb) p ((&default_target_regs)->x_have_regs_of_mode)[mode]
$118 = false
(gdb)

オリジナルの cc1 では以下で true にセットしていた:

      for (i = 0; i < N_REG_CLASSES; i++)
	if ((targetm.class_max_nregs ((reg_class_t) i, (machine_mode) m)
	     <= reg_class_size[i])
	    && hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]))
	  {
	     contains_reg_of_mode[i][m] = 1;
	     if (hard_reg_set_intersect_p (ok_regs2, reg_class_contents[i]))
	       {
		 have_regs_of_mode[m] = 1;   ★
		 contains_allocatable_reg_of_mode[i][m] = 1;
	       }
	  }

i = 1 のとき

(gdb) p hard_reg_set_intersect_p (ok_regs2, ((&default_target_hard_regs)->x_reg_class_contents)[i])
$127 = false
(gdb)

この条件が成立していない.

以下は条件が成立するオリジナルの cc1 の結果: 
(gdb) p ok_regs2
$29 = {4294967292, 4294967295, 4294967295, 4294967295, 0}
(gdb) p ((&default_target_hard_regs)->x_reg_class_contents)[i]
$30 = {4294967295, 4294967295, 4294967295, 4294967295, 3}
(gdb) 

以下は条件が成立しない自前の cc1 の結果:
(gdb) p ok_regs2
$128 = {elts = {0, 0, 0, 0, 0}}
(gdb) p ((&default_target_hard_regs)->x_reg_class_contents)[i]
$129 = {elts = {7, 0, 0, 0, 1}}
(gdb)


#define REG_CLASS_CONTENTS \
/* NO_REGS */	    {{ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0 }, \
/* SPECIAL_REGS */   { 0x00000007, 0x00000000, 0x00000000, 0x00000000, 0x1 }, \
/* GENERAL_REGS */   { 0xfffffff8, 0xffffffff, 0xffffffff, 0xffffffff, 0x0 }, \
/* ALL_REGS */       { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x1 }}

なるほど, 7, 0, 0, 0, 1 は SPECIAL_REGS に対する値だった. だとすれば自前の cc1 は
i = 2 でこの条件が成立するのが期待値.いずれにしても ok_regs2 の値がおそらく
違っている. この変数の計算の仕方を確認する.

      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)
	if (!TEST_HARD_REG_BIT (fixed_nonglobal_reg_set, j)
	    && targetm.hard_regno_mode_ok (j, (machine_mode) m))  ★
	  {
	    SET_HARD_REG_BIT (ok_regs, j);
	    if (!fixed_regs[j])
	      SET_HARD_REG_BIT (ok_regs2, j);  ★
	  }

これっぽい. しかし以下の間違いに気付いた:

#define FIXED_REGISTERS { \
1, 1, 1, 1, 1, 1, 1, 1, \   ★


#define CALL_USED_REGISTERS { \
1, 1, 1, 0, 1, 1, 1, 1, \   ★

これを修正してもう一度トライ.

2022.06.18 11:37 現状以下に対して期待したコードを生成できている.

typedef __vector int vec_int4;

vec_int4 f(vec_int4 a, vec_int4 b)
{
  return a + b;
}

また以下に対しても期待したコードを生成できている.

int f(int a, int b)
{
  return a + b;
}

(*5)
2022.06.18 16:13

現状

int f(int a, int b)
{
  return a + b;
}

に対して以下のコードを生成している.

f:
	ai	$sp, $sp, -48
	stqd	$lr, 0($sp)
	stqd	$sp, 16($sp)
	stqd	$3, 32($sp)
	stqd	$4, 36($sp)
	$3 := 32($sp) + 36($sp)
	lqd	$lr, 0($sp)
	ai	$sp, $sp, 48
	bi	$lr

a と b は sp 相対 32 と 36 にしているのだが, これを 32 と 48 にしたい.

	  int align = STACK_SLOT_ALIGNMENT (data->arg.type,
					    GET_MODE (data->entry_parm),
					    TYPE_ALIGN (data->arg.type));

ここで計算している. この部分のマクロ展開は

   int align = ((data->arg.type) ? (((data->arg.type)->type_common.align ? ((unsigned)1) << ((data->arg.type)->type_common.align - 1) : 0)) : (((data->arg.type)->type_common.align ? ((unsigned)1) << ((data->arg.type)->type_common.align - 1) : 0)))

2022.06.18 16:26 以下の宣言を追加してリビルド開始

#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) 128

2022.06.18 17:48 期待した動作になっていることを確認. get_frame_size() を 16 バイト
アラインにすれば期待したコードになる.

(*6)
現状 hello world 11 が spu-elf-run で動作している. また vec_int4 を加算するプログラム
モ spu-elf-run で期待通り動作している.

そして spu::expand_prologue で生成しているすべての rtx_insn* insn に対して

  RTX_FRAME_RELATED_P(insn) = true;

のようにしている.

-g オプション付きでコンパイルした hello world 11 を spu-elf-gdb で動作させると現状
以下のようになる.

% spu-elf-gdb b.elf -x gdbcom -q
Reading symbols from b.elf...
...
Connected to the simulator.
Loading section .text, size 0xb8 lma 0x100
Loading section .rodata, size 0x10 lma 0x1b8
Start address 0x100
Transfer rate: 1600 bits in <1 sec.
Breakpoint 1 at 0x18c: file b.c, line 10.

Breakpoint 1, main () at b.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=<error reading variable: Cannot access memory at address 0x20>, 
    b=<error reading variable: Cannot access memory at address 0x30>) at b.c:5
5	  return a + b;
...
%

f にステップインしたとき引数の a と b を正しく表示できていない. a と b は sp 相対
0x20 と 0x30 にある.

一方

.debug_info セクションの内容(b.elf より読み込んだもの):
...
 <2><7c>: 省略番号: 5 (DW_TAG_formal_parameter)
    <7d>   DW_AT_name        : a
    <7f>   DW_AT_decl_file   : 1
    <80>   DW_AT_decl_line   : 3
    <81>   DW_AT_decl_column : 11
    <82>   DW_AT_type        : <0x61>
    <86>   DW_AT_location    : 2 byte block: 72 20 	(DW_OP_breg2 (r2): 32) ★
 <2><89>: 省略番号: 5 (DW_TAG_formal_parameter)
    <8a>   DW_AT_name        : b
    <8c>   DW_AT_decl_file   : 1
    <8d>   DW_AT_decl_line   : 3
    <8e>   DW_AT_decl_column : 18
    <8f>   DW_AT_type        : <0x61>
    <93>   DW_AT_location    : 2 byte block: 72 30 	(DW_OP_breg2 (r2): 48) ★

r2 レジスタ相対になっている.

#define REGISTER_NAMES      { \
-"$lr", "$1", "$sp", "$3", "$4", "$5", "$6", "$7", \

#define REGISTER_NAMES      { \
+"$lr", "$sp", "$2", "$3", "$4", "$5", "$6", "$7", \

-#define STACK_POINTER_REGNUM  2
+#define STACK_POINTER_REGNUM  1

上の修正を入れてリビルド 2022.06.18 17:57 開始.

2022.06.19 5:25 現状 hello world 11 を -g オプション付きでコンパイルしたプログラムを
spu-elf-gdb で実行すると以下のようになる:
% spu-elf-gdb -q -x gdbcom b.elf
Reading symbols from b.elf...
Connected to the simulator.
Loading section .text, size 0xb8 lma 0x100
Loading section .rodata, size 0x10 lma 0x1b8
Start address 0x100
Transfer rate: 1600 bits in <1 sec.
Breakpoint 1 at 0x18c: file b.c, line 10.

Breakpoint 1, main () at b.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=5, b=6) at b.c:5
5	  return a + b;
#0  f (a=5, b=6) at b.c:5
#1  0x00000198 in main () at b.c:10
Backtrace stopped: previous frame inner to this frame (corrupt stack?)    ★
hello world 11
...
%

同じことをオリジナルの cc1 で試すと ★ のエラーメッセージは出ていない.

以下はオリジナルの cc1 で生成している .debug_frame:

.debug_frame セクションの内容(b.elf より読み込んだもの):


00000000 0000000c ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -16
  Return address column: 0

  DW_CFA_def_cfa: r1 ofs 0

00000010 00000014 00000000 FDE cie=00000000 pc=00000150..00000194
  DW_CFA_advance_loc4: 8 to 00000158
  DW_CFA_def_cfa_offset: 64
  DW_CFA_nop

00000028 00000018 00000000 FDE cie=00000000 pc=00000198..000001d4
  DW_CFA_advance_loc4: 12 to 000001a4
  DW_CFA_def_cfa_offset: 32
  DW_CFA_offset_extended_sf: r0 at cfa+16
  DW_CFA_nop
  DW_CFA_nop

以下は自前の cc1 の生成した .debug_frame:

.debug_frame セクションの内容(b.elf より読み込んだもの):


00000000 00000014 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -16
  Return address column: 129

  DW_CFA_def_cfa: r1 ofs 0
  DW_CFA_register: r129 in r0
  DW_CFA_nop
  DW_CFA_nop
  DW_CFA_nop

00000018 0000001c 00000000 FDE cie=00000000 pc=00000150..0000017c
  DW_CFA_advance_loc4: 4 to 00000154
  DW_CFA_def_cfa_offset: 64
  DW_CFA_advance_loc4: 8 to 0000015c
  DW_CFA_offset: r0 at cfa-64
  DW_CFA_offset: r1 at cfa-48

00000038 0000001c 00000000 FDE cie=00000000 pc=00000180..000001b4
  DW_CFA_advance_loc4: 4 to 00000184
  DW_CFA_def_cfa_offset: 32
  DW_CFA_advance_loc4: 8 to 0000018c
  DW_CFA_offset: r0 at cfa-32
  DW_CFA_offset: r1 at cfa-16

スタックフレームの構造が違うから単純な比較はできそうにない.

2022.06.20 5:23 以下を試しに追加してビルド開始

#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM(LINK_REGNUM)

2022.06.20 6:03 症状は改善されていないことを確認. やはり意味のある調査が必要. 一旦上の
修正は削除.

spu-elf-gdb 視点から調査する必要がある.

(gdb) b backtrace_command
(gdb) run
...
backtrace_command のブレークポイントにヒット
(gdb)

エラーメッセージを出力しているのは以下:

      if (fi == NULL && trailing != NULL)
	{
	  enum unwind_stop_reason reason;

	  reason = get_frame_unwind_stop_reason (trailing);
	  if (reason >= UNWIND_FIRST_ERROR)
	    printf_filtered (_("Backtrace stopped: %s\n"),
			     frame_stop_reason_string (trailing));  ★
	}

直接の原因は reason にエラーステータスがセットされるからであるが, さらにその理由は以下:

(gdb) p trailing->stop_reason
$3 = UNWIND_INNER_ID
(gdb)

これをセットしている瞬間を確認する.

  if (get_frame_type (this_frame) == NORMAL_FRAME
      && this_frame->next->unwind->type == NORMAL_FRAME
      && frame_id_inner (get_frame_arch (this_frame->next),
			 get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))   ★ この条件が成立
    {
...
      if (!morestack_name || strcmp (morestack_name, "__morestack") != 0)
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // this frame ID is inner }\n");
	    }
	  this_frame->stop_reason = UNWIND_INNER_ID;  ★
	  return NULL;
	}

(gdb) p/x get_frame_id (this_frame)
$7 = {stack_addr = 0x1f7c0, code_addr = 0x180, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x get_frame_id (this_frame->next)
$8 = {stack_addr = 0x1f7e0, code_addr = 0x150, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)


0x180 は main のアドレス. 0x150 は f のアドレス.
f のスタックの値 0x1f7e0 >= main のスタックの値 0x1f7c0
なのでこのエラーメッセージが出ている.

main の先頭アドレスでのスタック : 0x1f800
f    の先頭アドレスでのスタック : 0x1f7e0

つまり main のスタック ID が間違えている. 0x1f7c0 をどのように計算しているか確認する.

static void
dwarf2_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);

  if (cache->unavailable_retaddr)
    (*this_id) = frame_id_build_unavailable_stack (get_frame_func (this_frame));
  else if (cache->undefined_retaddr)
    return;
  else
    (*this_id) = frame_id_build (cache->cfa, get_frame_func (this_frame));  ★
}

この部分で一旦は 0x1f800 を算出している. しかしこれが 0 に変更された後再び 0x1f7c0 に
変更されている. そして再び 0 に変更され, 最後には0x1f7c0 に変更されている.
0x1f7c0 を算出しているところは以下:

      switch (fs.regs.cfa_how)
	{
	case CFA_REG_OFFSET:
	  cache->cfa = read_addr_from_reg (this_frame, fs.regs.cfa_reg);  ★
	  if (fs.armcc_cfa_offsets_reversed)
	    cache->cfa -= fs.regs.cfa_offset;
	  else
	    cache->cfa += fs.regs.cfa_offset;   ★
	  break;

最初に 0x1f7a0 が計算されそれに fs.regs.cfa_offset = 0x20 が加算されて 0x1f7c0 に
なっている. 0x1f7a0 がどのように算出されているかが問題.

一方で以下のように値を改竄すれば期待した動作にはなっている.

      switch (fs.regs.cfa_how)
	{
	case CFA_REG_OFFSET:
	  cache->cfa = read_addr_from_reg (this_frame, fs.regs.cfa_reg);
	  if (fs.armcc_cfa_offsets_reversed)
	    cache->cfa -= fs.regs.cfa_offset;
	  else
	    cache->cfa += fs.regs.cfa_offset;
+	  if (cache->cfa == 0x1f7c0) {
+	    switch (++n) {
+	    case 1:
+	      cache->cfa = 0x1f800;
+	      break;
+	    case 2:
+	      cache->cfa = 0x20000;
+	      break;
+	    }
	  }  
	  break;

問題は 2 回目が 0x1f800 だとエラーメッセージが

Backtrace stopped: previous frame identical to this frame (corrupt stack?)

のようになるとういこと. 期待値が現状不明. 上は無理に 0x1f800 よりも大きい値を指定しただけ
のもの.

しかしまずは 0x1f800 を返すのが期待値なので何故それが返っていないかを調べてみる.

全く根拠がないが以下を入れて cc1 をビルドしてみた.

#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM(LINK_REGNUM)

やはり効果なし. 一旦上の修正は削除する.

      struct value *regval = get_frame_register_value (frame, regnum);

この時点で

(gdb) p/x value_as_address (regval)
$147 = 0x1f7a0
(gdb)

のようになっている. get_frame_register_value (frame, regnum) の戻り値
が返すアドレスの内容が変更されているように思える.

(gdb) p* regval
$148 = {lval = lval_memory, modifiable = 1, lazy = 0, initialized = 1, 
  stack = 1, location = {address = 128944, reg = {regnum = 128944, 
      next_frame_id = {stack_addr = 0, code_addr = 0, special_addr = 0, 
        stack_status = FID_STACK_INVALID, code_addr_p = 0, 
        special_addr_p = 0, artificial_depth = 0}}, internalvar = 0x1f7b0, 
(gdb) p/x regval->location.address
$151 = 0x1f7b0
(gdb)

f のプロローグをスキップした時点でのメモリダンプの結果は  

(spu-elf-gdb) x/32wx $sp
0x1f7a0:	0x00000198	0x00000000	0x00000000	0x00000000
0x1f7b0:	0x0001f7a0	0x0001f7a0	0x0001f7a0	0x0001f7a0
0x1f7c0:	0x00000005	0x00000005	0x00000005	0x00000005
0x1f7d0:	0x00000006	0x00000006	0x00000006	0x00000006
0x1f7e0:	0x00000130	0x00000000	0x00000000	0x00000000
0x1f7f0:	0x0001f7e0	0x0001f7e0	0x0001f7e0	0x0001f7e0
0x1f800:	0xcccccccc	0xcccccccc	0xcccccccc	0xcccccccc
0x1f810:	0xcccccccc	0xcccccccc	0xcccccccc	0xcccccccc
(spu-elf-gdb) 

つまり 0x1f7a0 はメモリ 0xaf7b0 にある値から算出している.

	0x1f7a0 +---------------+ <- sp_{new}
		|     0x198	|
	0x1f7b0 +---------------+
		|     0x1f7a0	|
	0x1f7c0	+---------------+
		|      5	|
	0x1f7d0	+---------------+
		|      6	|
	0x1f7e0	+---------------+ <- sp_{old}

これは, ... スタックフレームの構造はそのままで保存するスタックの値を更新前のものにするべき.
一旦 expand_prologue と expand_epilogue を修正する.

2022.06.20 13:16 上の修正を入れて hello world 11 -g オプションでコンパイルした
プログラムを spu-elf-gdb で期待通り動作させることができている.
また vec_int4 の加算をするプログラムに対しても step, where, finish が期待通り動作している.

       