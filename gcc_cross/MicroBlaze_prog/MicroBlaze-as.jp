MicroBlaze のアセンブラ

brai label

のような命令に対して

imm 0
brai label

のようなコードを出していた. MicroBlaze には IMM という命令があるらしく,

MMU 例外の場合(データストレージ例外, 命令ストレージ例外, データ TLB ミス例外,
命令 TLB ミス例外), レジスタ R17 に適切なプオルラムカウンター値がロードされ,
戻ったときに例外を発生させた命令を再実行します. その前に IMM 命令がある場合は,
IMM 命令に戻るよう値が調整されます. 例外が分岐遅延スロットの命令により発生した
場合は, その分岐命令(その前に IMM 命令がある場合は IMM 命令)に戻るように
値が調整されます.

ということらしい. IMM 命令の仕様はこれからは不明だが, どうやらアセンブラは意図して
このようなコードを生成しているらしい.

	.text
	brai label
	

をアセンブルしてみると,

		      assemble_one (s); /* Assemble 1 instruction.  */

が呼び出され, これが MicroBlaze 特有の函数


binutils-2.36.1.microblaze-elf/gas/config/tc-microblaze.c:904

void
md_assemble (char * str)

が呼び出されるという仕組みらしい.

name = "brai label" で以下が実行されていた:

  opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, name);
...

  switch (opcode->inst_type)
    {
...  
    case INST_TYPE_IMM:
      if (streq (name, "imm"))
        as_fatal (_("An IMM instruction should not be present in the .s file"));

      op_end = parse_imm (op_end + 1, & exp, MIN_IMM, MAX_IMM);

で brai のアセンブルでここにきている.

単純に nop の場合は

    case INST_TYPE_NONE:
      output = frag_more (isize);
      break;

ここにくるというわけだ.
ところで詳細は省くが

opcodes

という名前の配列に各命令が定義されている. 例えば opcode[0] は

(gdb) p opcodes[0]
$59 = {name = 0x80f9c40 "add", inst_type = 0, inst_offset_type = 0, 
  delay_slots = 0, immval_mask = 0, bit_sequence = 0, 
  opcode_mask = 4227860479, instr = add, instr_type = arithmetic_inst}

のようになっていた. この inst_type メンバが nop のように INST_TYPE_NONE
ならばプログラマが書いたようにしかコードが生成されない.

そこで以下のように修正を入れた:

+ if (getenv("MICROBLAZE_AS_SPECIAL"))
+   opcode->inst_type = INST_TYPE_NONE;

  switch (opcode->inst_type)
    {
...

おそらくこれは間違いなのだが, 私自身がアセンブラのこの動きを理解していないから
それに気付くまでこうしておく.
