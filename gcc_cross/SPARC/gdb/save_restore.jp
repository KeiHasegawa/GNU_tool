スタートアップルーチンで %wim を 2 にセットすることで save や restore 命令で
window overflow trap や window underflow trap が発生したときにそれらの
例外ハンドラで処理してみた.

例外ハンドラは

http://icps.u-strasbg.fr/people/loechner/public_html/enseignement/SPARC/sparcstack.html

の Figure 9 や Figure 10 にあるものをそのまま使用した.
そして「レジスタウィンドウの退避復元をしないプログラムの動作」と同じプログラムを
動かしてみた.

退避復元をしないときの CWP は各函数で save 命令の後は以下のようになっていた:

main : 7
f7   : 6
f6   : 5
f5   : 4
f4   : 3
f3   : 2
f2   : 1
f1   : 0
f0   : 7

そしてこの事は退避復元を行なう今回も同じである. 
%wim = 2 = 1 << 1 なので f2 の save 命令で CWP が 2 から 1 になるところで
window overflow trap が発生することになる.

このとき, 例外ハンドラ window_overflow では以下を行なう:

	  o %wim を 2 = 1 << 1 から 1 = 1 << 0 に変更
	  o レジスタウィンドウ 0 をスタックポインタの指す先に保存

	    ここでレジスタウィンドウ 0 はスタートアップルーチンのものである.
	    言い換えれば main で save 命令を実行する前のレジスタウィンドウである.
	    そして参照されるスタックポインタはスタートアップルーチンでセットした
	    %sp (%o5) であって f2 のスタックポインタではないことに注意.

例外ハンドラ window_overflow では明示的に save 命令を実行することでこのとき
目的とするレジスタウィンドウ 0 に切り換える. すなわちグラフィカルに表現すると以下のように
なる:

			       		     CWP
					     2

函数 f2 の save 命令           例外ハンドラ
       +
       |
       +------------------------+	     1
				|
			     save 命令
				|	     0

		     レジスタウィンドウ 0
		     をスタックに保存
			     


この後例外ハンドラ window_overflow では明示的に restore 命令を発行することで
f2 で使用するレジスタウィンドウ 1 に切り換える.
最後に rett 命令を発行することで window overflow trap を引き起こした f2 の
save 命令のアドレスにプログラムの制御が移る.

復帰後 %wim = 1 になっていてるので f2 の save 命令は例外を引き起こさない.

続いて f1 の save 命令が実行される. このとき CWP は 1 から 0 になるところで
%wim = 1 = 1 << 0 なのでやはり window overflow trap を引き起こす.
例外ハンドラ window_overflow では以下を行なう


	  o %wim を 1 << 0 から 1 << 7 = 128 に変更
	  o レジスタウィンドウ 7 をスタックポインタの指す先に保存

	    ここでレジスタウィンドウ 7 は main 函数のものである.
	    言い換えれば f7 で save 命令を実行する前のレジスタウィンドウである.
	    そして参照されるスタックポインタは main で更新した
	    %sp (%o5) であって勿論 f1 のスタックポインタではない.

同様にグラフィカルに表現すると以下のようになる:


			       		     CWP
					     1

函数 f1 の save 命令           例外ハンドラ
       +
       |
       +------------------------+	     0
				|
			     save 命令
				|	     7

		     レジスタウィンドウ 7
		     をスタックに保存

続いて f0 の save 命令が実行される. このとき CWP が 0 から 7 になるところで
やはり %wim = 1 << 7 = 128 なので window overflow trap を引き起こす.
例外ハンドラ window_overflow では以下を行なう

	  o %wim を 1 << 7 = 128 から 1 << 6 = 64 に変更
	  o レジスタウィンドウ 6 をスタックポインタの指す先に保存


これまで window_overflow で保存されたレジスタウィンドウは

o スタートアップルーチン
o main
o f7

のものである. これらはそれぞれ時系列に

o f6 の restore 命令で f7 のレジスタウィンドウを 
o f7 の restore 命令で main のレジスタウィンドウを
o main の restore 命令でスタートアップルーチンのレジスタウィンドウを

それぞれ復元する. f0, f1, f2 の restore 命令では window underflow trap
が引き起こされるわけではないことにも注意.

例えば, 続いて f0 の restore 命令が実行される. CWP は 7 から 0 に更新される.
%wim = 1 << 6 = 64 なのでここでは window underflow trap は(勿論)引き起こされない.

続いて f1, f2, ..., f5 の restore 命令が実行されるがやはり window underflow trap
は引き起こされない.

続いて f6 の restore 命令が実行される. このとき CWP が 5 から 6 になるところで
%wim = 1 << 6 = 64 なので window underflow trap が引き起こされる.

このとき, 例外ハンドラ window_underflow では以下を行なう:

	  o %wim を 1 << 6 = 64 から 1  << 7 = 127 に変更
	  o レジスタウィンドウ 2 をスタックポインタの指す先に保存


例外ハンドラ window_underflow では明示的に restore 命令を 2 回実行することでこのとき
                                                    ^
目的とするレジスタウィンドウ 2 に切り換える. すなわちグラフィカルに表現すると以下のように
なる:

			       		     CWP
					     5

函数 f6 の restore 命令        例外ハンドラ
       +
       |
       +------------------------+	     4
				|
			     restore 命令
			        |	     3  
			     restore 命令
				|	     2

		     レジスタウィンドウ 2
		     をスタックに保存

この後例外ハンドラ window_underflow では明示的に restore 命令を 2 回発行することで
レジスタウィンドウ 4 に切り換える.
最後に rett 命令を発行することで window underflow trap を引き起こした f6 の
restore 命令のアドレスにプログラムの制御が移る.
