Compact RISC の ABI

(*0) レジスタの別名
(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long, long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数


(*0) レジスタの別名

        fp : r13
        ra : r14
	sp : r15

(*1) 函数呼び出し

	bal (ra), func@c

	疑似コード
	
	ra = (bal 命令の次のアドレス) >> 1
	pc = func

(*2) 函数復帰

	jump	 (ra)

	疑似コード

	pc = (ra << 1)

	葉の函数でなければ popret 命令を使用する. (*4) も参照.

(*3) プロローグ

	push	$2, r13, ra
	addd	$-128, (sp)
	movd	(sp), (r13)

	上は 128 バイトのローカルエリアを使用する函数のプロローグである.

	+----------------+ <- sp_{new}, r13_{new}
	|                |
	|                |
	|   local area   |
	|                |
	|                |
	+----------------+ +128
	|     r13_{old}  |
	+----------------+ +132
	|     ra_{old}   |
	+----------------+ <- sp_{old}

(*4) エピローグ

	movd	(r13), (sp)
	addd	$128, (sp)
	popret	$2, r13, ra

	上は 128 バイトのローカルエリアを使用する函数のエピローグである.
	r13, sp, ra が復元され呼び出し元に復帰する.

(*5) 通常の函数の引数と戻り値

        sizeof(int) = 2

	第 1 引数 : r2
	第 2 引数 : r3
	第 3 引数 : r4
	第 4 引数 : r5
	第 5 引数 : r6
	第 6 引数以降 : スタックに積む

	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7);

	f(10,11,12,13,14,15,16,17);

	に対して f の先頭では

	r2 = 10, r3 = 11, r4 = 12, r5 = 13, r6 = 14

	+----------------+ <- sp
	|       15       |
	+----------------+ +2
	|       16       |
	+----------------+ +4
	|       17       |
	+----------------+ +6

	のようになっている.
	函数の戻り値は r0 にセットされる.

	可変個引数を取る函数では引数はすべてスタックで渡される.
	
(*6) long, long long を引数にとる函数, 返す函数

        sizeof(long) = 4
        sizeof(long long) = 8


	long に対してはレジスタが 2 つ使用され, 残りはスタックで渡す. r6 とスタック
	をまたぐ場合は r6 は使用されない.

	long f(int a0, long a1, int a2, long a3);

	f(10,0x12345678L,11, 0x9abcdef0L);

	に対して f の先頭アドレスでは

	r2 = 10, r3 = 0x5678, r4 = 0x1234, r5 = 11

	+----------------+ <- sp
	|     0xdef0     |
	+----------------+ +2
	|     0x9abc     |
	+----------------+ +4

	のようになる.
	函数の戻り値は r0 と r1 にセットされる.

	long long に対しては第 1 引数であってもレジスタが使用されず, スタックで渡す.
	函数の戻り値は r0, r1, r2, r3 にセットされる.

	
	typedef long long int T;

	T g(int a0, T a1, int a2, int a3, T a4, int a5, int a6, int a7, T a8)
	{
	  return a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
	}

	g(1, 2, 3, 4, 5, 6, 7, 8, 9);

	g の先頭アドレスでは以下のようになっている:

	r2 = 1, r3 = 3, r4 = 4, r5 = 6, r6 = 7

	+----------------+ <- sp
	|       2        |
	|                |
	+----------------+ +8
	|       5        |
	|                |
	+----------------+ +16
	|       8        |
	+----------------+ +18
	|       9        |
	|                |
	+----------------+ +26

(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

	Compact RISC には FPU がないのでソフトウェアで浮動少数点数演算を行なう.
	float に対しては long と同じ規則が使用される. doube, long double
	に対しては long long と同じ規則が使用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すとき, 構造体のサイズが 4 バイト以下であれば
	r2, ... , r6 レジスタが 2 つ使用される. サイズが 4 バイトより大きければ
	レジスタは使用されず, スタックが使用される.

	例えば

	struct S { int a; int b; };
	void f(struct S x, struct S y, struct S z, int a);
	f((struct S){1, 2}, (struct S){3, 4}, (struct S){5, 6}, 7);

	に対して f の先頭アドレスでは

	r2 = 1, r3 = 2, r4 = 3, r5 = 4, r6 = 7

	+----------------+ <- sp
	|       5        |
	+----------------+ +2
	|       6        |
	+----------------+ +4

	のようになっている.

	
	構造体を返す函数を呼び出すとき, 構造体のサイズが 8 バイト以下であれば r0, r1,
	r2, r3 レジスタが使用される。 サイズが 8 バイトより大きければ戻り値を格納する
	アドレスを r0, r1 にセットする.
