Investigation of break point is off the point at pru-elf-gdb.

If just locate `nop' instruction, there is no problem. But

	.text
start:
	nop
	ldi32	sp, stack
	call	%label(my_func)
end:
	nop
	
my_func:
	ret
	
for above source, this bug is reproduced, where `start' address is 0x100.
I confirmed disassemble result:

00000100 <start>:
 100:	12e0e0e0 	nop
 104:	241000e2 	ldi	sp, 4096
 108:	230044c3 	call	110 <my_func>

0000010c <end>:
 10c:	12e0e0e0 	nop

00000110 <my_func>:
 110:	20c30000 	ret

I noticed that

	ldi32	sp, stack

for above code, 2 instructions are generated or just 1 instruction is
generated according to the `stack' value.

Line information becames like below:

 Line Number Statements:
  [0x0000002a]  Extended opcode 2: set Address to 0x100
  [0x00000031]  Special opcode 7: advance Address by 0 to 0x100 and Line by 2 to 3
  [0x00000032]  Advance Line by 1 to 4
  [0x00000034]  Advance PC by fixed size amount 0 to 0x100
  [0x00000037]  Copy (view 1)
  [0x00000038]  Advance Line by 1 to 5
  [0x0000003a]  Advance PC by fixed size amount 4 to 0x104
  [0x0000003d]  Copy (view 2)
  [0x0000003e]  Advance Line by 2 to 7
  [0x00000040]  Advance PC by fixed size amount 4 to 0x108
  [0x00000043]  Copy (view 3)
  [0x00000044]  Advance Line by 5 to 12
  [0x00000046]  Advance PC by fixed size amount 4 to 0x10c
  [0x00000049]  Copy (view 4)
  [0x0000004a]  Advance PC by fixed size amount 4 to 0x110
  [0x0000004d]  xtended opcode 1: End of Sequence

Contents of the .debug_line section:

CU: test003.S:
File name                            Line number    Starting address    View    Stmt
test003.S                                      3               0x100               x
test003.S                                      4               0x100       1       x
test003.S                                      5               0x104       2       x
test003.S                                      7               0x108       3       x
test003.S                                     12               0x10c       4       x
test003.S                                      -               0x110


Line 3 and line 4 are corresponding to address 0x100.

Anyway, there is a problem about output of linker.
I also confirmed that assembler output:

% pru-elf-objdump -x -d --dwarf=rawline --dwarf=decodedline  test003.o > test003.o.objdump
...
File name                            Line number    Starting address    View    Stmt
test003.S                                      3                   0               x
test003.S                                      4                 0x4       1       x
test003.S                                      5                 0xc       2       x
test003.S                                      7                0x10       3       x
test003.S                                     12                0x14       4       x
test003.S                                      -                0x18

Fine. I also tried below source:

	.text
start:
	nop
	ldi	sp, stack
	call	%label(my_func)
end:
	nop
	
my_func:
	ret

For above, expected result is generated by linker.

