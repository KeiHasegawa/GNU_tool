せっかくなので今回のこのような問題を他のプロセッサのツールでどのように扱っているか
調べてみた.

% cat test.c
int* f()
{
  extern int var;
  return &var;
}
% aarch64-elf-gcc -g -S test.c
% aarch64-elf-as test.s -o test.o
% aarch64-elf-ld -o test.elf test.o --defsym var=0x100

のようにして var のアドレスを参照する命令がどのようになっているかを調べるというもの
である.

(*) aarch64-elf-***

	adrp	x0, var
	add	x0, x0, :lo12:var

のようなコードを生成する. この場合はそうするべきでないし, リンカで特別な対応はしていない.

(*) arm-elf-***

	ldr	r3, .L2
...
.L2:
	.word	var

のようなコードを生成するのでリンカで特別な対応は必要ない.


(*) avr-elf-***

	ldi r24,lo8(var)
	ldi r25,hi8(var)

のようなコードを生成する.  この場合はそうするべきでないし,リンカで特別な対応はしていない.

(*) bfin-elf-***

	R0.H = _var;
	R0.L = _var;

のようなコードを生成する. この場合はそうするべきでないし,リンカで特別な対応はしていない.

(*) cr16-elf-***

	movd	$_var@l, (r1,r0)

のようなコードが生成される _var が 0 ... 0xf ならば 2 バイト, 0x10 ... 0xfff ならば
4 バイトそれ以上ならば 6 バイトになる. 実装仕様はこうだが実際は
_var が 0 ... 0xfff ならば 4 バイトそれ以上ならば 6 バイトになる.
この対応を「CompactRISC」->「ブレークポイントで停止したときのパラメータの表示(3)」で行なった.
このときも .debug_line セクションの対応しかしていなかったので改めて対応した.

(*) cris-elf-***

	move.d _var,$r9

のようなコードをコンパイラが生成するがリンカは特別な対応はしていない. mov.m や mov.s のよう
な命令はないらしい. この命令は常に 6 バイトになることで 32 ビットアドレス空間を
サポートしている.

(*) frv-elf-***

	addi gr16,#gprel12(var),gr4

のようなコードを生成する. FR-V ではグローバルポインタ方式を採用している.
var は .data セクションの近くに配置する必要があるのでデフォルトリンカスクリプトの
.data セクションの先頭アドレスを指定するため  var=0x00010130 とした.
結果的に

	addi gr16,-2048,gr4

のようになった. リンカが行なうのはアドレスのチェックだけであるし, この場合はそれで
十分である.

(*) ft32-elf-***

	ldk.l  $r0,var

のようなコードを出す. リンカは特別な対応はしていない. ldk.m 相当の命令はないらしい.
ldk.s はアセンブルエラーにはならないが ldk.l とオペコードが同じ. var には
20 ビットで収まる値が要求されるが var=0x100000 としたがエラーにはならず

	ldk.l  $r0,0

というコードが生成された. これは本当はエラーにならないといけない.

(*) h8300-elf-***

	mov.w	#_var,r2

のようなコードを生成する. H8 の場合 0x100 ではなくて 0x80 を指定したがリンカは特別な
対応はしていない. mov.b 相当の短い命令はない. _var には 16 ビットで収まる値が
要求される. H8 のアーキテクチャではこれが必然だから問題ないが 16 ビットで収まらない
値が指定されてもエラーになっていない.

(*) iq2000-elf-***

	lui	%2,%hi(var) # high
	addiu	%2,%2,%lo(var) # low

のようなコードを生成する. この場合はそうするべきでないし, リンカは特別な対応をしていない.


(*) lm32-elf-***

	orhi     r1, r0, hi(var)
	ori      r1, r1, lo(var)

のようなコードを生成する. この場合はそうするべきでないし, リンカは特別な対応をしていない.


(*) m32c-elf-***

	mov.w	#_var,r0

のようなコードを生成する. M32C の場合 0x100 ではなくて 0x80 を指定したがリンカは特別な
対応はしていない. mov.b 相当の短い命令はない. この命令は 4 バイトの命令で _var には
16 ビットで収まるアドレスが要求される. しかし例によってエラーチェックはされていない.

(*) m32r-elf-***

	ld24 r4,#var

のようなコードを生成する. リンカは特別な対応をしていない. ld16 のような命令はないらしい.
var は 24 ビットで収まるアドレスが要求される. リンカはこれをチェックしている.
これだと 32 ビットのアドレス空間はサポートできていないが私は仕様として問題がないと思っている.

(*) m68hc11-elf-***

	ldd	#var

のようなコードを生成する. Motorla 68000 の場合 0x100 ではなくて 0x80 を指定したが
リンカは特別な対応をしていない. var の値は 16 ビットで収まる値が要求されるがアーキテクチャ
ではこれが必然だから問題ないが 16 ビットで収まらない値が指定されてもエラーになっていない.

(*) mcore-elf-***

	lrw	r7, var

のようなコードを生成する. var には 32 ビットの値が許可される. この命令を
配置されたアドレスから暗黙に指定されたオフセットのところに var を持つことでこれが
実現されている.

	lrw	r7, var
	mov	r2,r7
	mov	sp,r8
	ldw	r8,(sp)
	addi	sp,8
	jmp	r15           ; 函数の終わり

のようなコードには jmp 命令の次のアドレスに var の値を保持している.
そしてリンク時にその値を決定している.

(*) microblaze-elf-***

	addik	r3,r0,var

のようなコードを生成する. リンカはこれに対して

 	imm	0
 	addik	r3, r0, 256

のようにする. 「Microblaze プログラミング」->「MicroBlaze のアセンブラ」も参照.
この場合はリンカは imm 命令を出さないこともできるし, むしろそうするべきである.

(*) mips-elf-***

	la	$2,var

のようなコードを生成する. MIPS の場合グローバルポインタ方式を採用している
詳しくは「ABI」=>「MIPS」を参照. リンク後上の命令は以下のようになった:

 	addiu	v0,gp,-56

改めて確認したがこれは混乱する. 変換してるように見えるかもしれないが
リンカはエラーをチェックするだけのことをしている.

(*) mn10300-elf-***

	mov _var,d0

のようなコードを生成する. _var=0x80 のように指定してみたがこの命令は必ず 6 バイトになり
32 ビットアドレス空間をサポートできている. リンカは特別なことはしていない.

(*) moxie-elf-***

	ldi.l	$r0, var

のようなコードを生成する. この命令は必ず 6 バイトになり 32  ビットアドレス空間をサポートで
きている. リンカは特別なことはしていない. ldi.s としても同じオペコードが生成されている.

(*) msp430-elf-***

	MOV.W	#var, R12

のようなコードを生成する. var には 16 ビットで収まる値が要求される. リンカはこれを
チェックしている. リンカは特別なことはしていない.

(*) or1k-elf-***

	l.movhi	r17, ha(var)
	l.addi	r17, r17, lo(var)

のようなコードを生成する. この場合はそうするべきでないし,リンカで特別な対応はしていない.

(*) ppc-elf-***

	lis 9,var@ha
	la 9,var@l(9)

のようなコードを生成する. 9 は GPR の 9 番を表わす. リンカで特別な対応はしていない.

(*) pru-elf-***

	ldi32	r1, var

のようなコードを生成する. var が 16 ビットで収まる場合は 1 命令のみ生成するが,
そうでない場合は 2 命令になる. そして今回の問題が発生していた.

(*) rl78-elf-***

	movw	r8, #_var

のようなコードを生成する. var には 16 ビットで収まる値が要求されるがリンカはこれを
チェックしていない.

(*) rx-elf-***

	mov.L	#_var, r10

のようなコードを生成する. この命令は 6 バイトで 32 ビットアドレス空間をサポートしている.
リンカで特別な対応はしていない.

(*) sh-elf-***

	mov.l	.L3,r1

.L3:
	.long	_var

のようなコードを生成するのでリンカで特別な対応は必要ない.

(*) v850-elf-***

	movhi hi(_var),r0,r10
	movea lo(_var),r10,r10

のようなコードを生成する. この場合はそうするべきでないし, リンカで特別な対応はしていない.


(*) 分類

2 命令生成 : aarch64, avr, bfin, iq2000, lm32, or1k, ppc, v850
間接参照   : arm, mcore, sh
6 バイト   : cris, mn10300, moxie, rx
グローバルポインタ : frv, mips
24 ビット  : m32r
20 ビット : ft32(*x)
16 ビット : h8300(*x), m32c(*x), m68hc11(*x), msp430, rl78(*x)
リンカが調整 : cr16, pru
リンカが 2 命令生成 : microblaze

(*x) : ビット幅のチェックがされていない
