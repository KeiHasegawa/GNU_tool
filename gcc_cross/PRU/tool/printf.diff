*** gdb-10.2.aarch64-elf/sim/pru/interp.c	2021-04-25 13:06:26.000000000 +0900
--- gdb-10.2.pru-elf/sim/pru/interp.c	2021-11-20 18:26:13.000000000 +0900
***************
*** 154,159 ****
--- 154,160 ----
  		       nbytes, addr, write_transfer,
  		       sim_core_unmapped_signal);
      }
+ #if 0  
    else if (standalone && ((addr >= PC_ADDR_SPACE_MARKER)
  			  || (addr + nbytes > PC_ADDR_SPACE_MARKER)))
      {
***************
*** 161,166 ****
--- 162,168 ----
  		       nbytes, addr, write_transfer,
  		       sim_core_unmapped_signal);
      }
+ #endif  
    else if ((regn * 4 + regb + nbytes) > (32 * 4))
      {
        sim_io_eprintf (CPU_STATE (cpu),
***************
*** 203,208 ****
--- 205,211 ----
  		       nbytes, addr, read_transfer,
  		       sim_core_unmapped_signal);
      }
+ #if 0  
    else if (standalone && ((addr >= PC_ADDR_SPACE_MARKER)
  			  || (addr + nbytes > PC_ADDR_SPACE_MARKER)))
      {
***************
*** 213,218 ****
--- 216,222 ----
  		       nbytes, addr, read_transfer,
  		       sim_core_unmapped_signal);
      }
+ #endif  
    else if ((regn * 4 + regb + nbytes) > (32 * 4))
      {
        sim_io_eprintf (CPU_STATE (cpu),
***************
*** 517,522 ****
--- 521,713 ----
    CPU.regs[14] = ret;
  }
  
+ #include <assert.h>
+ #include <stdlib.h>
+ 
+ uint32_t first_arg(SIM_DESC sd, SIM_CPU* cpu, _Bool refer_stack)
+ {
+   if (refer_stack) {
+     int sp = cpu->pru_cpu.regs[2];
+     uint32_t a = sim_core_read_1(cpu, PC_byteaddr, read_map, sp+0);
+     uint32_t b = sim_core_read_1(cpu, PC_byteaddr, read_map, sp+1);
+     uint32_t c = sim_core_read_1(cpu, PC_byteaddr, read_map, sp+2);
+     uint32_t d = sim_core_read_1(cpu, PC_byteaddr, read_map, sp+3);
+     return (d << 24) | (c << 16) | (b << 8) | a;
+   }
+   return cpu->pru_cpu.regs[14];
+ }
+ 
+ static const char* first_string(SIM_DESC sd, SIM_CPU* cpu, _Bool refer_stack)
+ {
+   uint32_t addr = first_arg(sd, cpu, refer_stack);
+   static char buf[1024];
+   for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i ) {
+     char c = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+i);
+     buf[i] = c;
+     if (c == '\0')
+       return &buf[0]; // ok
+   }
+   assert(0 && "not enough buffer");
+   return &buf[0];
+ }
+ 
+ enum arg_class { NONE, WORD, DW, DF, LDF, STR };
+ 
+ static const char* get_part(const char* fmt, enum arg_class* how)
+ {
+   for ( ; *fmt ; ++fmt) {
+     char c = *fmt;
+     if (c == 'd' || c == 'i' || c == 'x' || c == 'u') {
+       if (*how == NONE)
+ 	*how = WORD;
+       return ++fmt;
+     }
+     if (c == 'c') {
+       *how = WORD;
+       return ++fmt;
+     }
+     if (c == 'f') {
+       char prev = *(fmt-1);
+       *how = prev == 'L' ? LDF : DF;
+       return ++fmt;
+     }
+     if (c == 's') {
+       *how = STR;
+       return ++fmt;
+     }
+     if (c == 'l') {
+       if (*how == NONE)
+ 	*how = WORD;
+       else
+ 	*how = DW;
+     }
+   }
+   assert(0 && "unexpected");
+   return fmt;
+ }
+ 
+ static unsigned int arg32(SIM_DESC sd, SIM_CPU* cpu, int nth)
+ {
+   assert(nth);
+   int sp = cpu->pru_cpu.regs[2];
+   int addr = sp + 4*nth;
+   uint32_t a = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+0);
+   uint32_t b = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+1);
+   uint32_t c = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+2);
+   uint32_t d = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+3);
+   return (d << 24) | (c << 16) | (b << 8) | a;
+ }
+ 
+ static uint64_t arg64(SIM_DESC sd, SIM_CPU* cpu, int nth)
+ {
+   assert(nth);
+   int sp = cpu->pru_cpu.regs[2];
+   int addr = sp + 4*nth;
+   uint32_t a0 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+0);
+   uint32_t b0 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+1);
+   uint32_t c0 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+2);
+   uint32_t d0 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+3);
+   uint64_t hi = (d0 << 24) | (c0 << 16) | (b0 << 8) | a0;
+   uint32_t a1 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+4);
+   uint32_t b1 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+5);
+   uint32_t c1 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+6);
+   uint32_t d1 = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+7);
+   uint64_t lo = (d1 << 24) | (c1 << 16) | (b1 << 8) | a1;
+   return (hi << 32) | lo; 
+ }
+ 
+ static const char*
+ handle(SIM_DESC sd, SIM_CPU* cpu, const char* fmt, int* nth, int* ret)
+ {
+   char c = *fmt;
+   if (c != '%') {
+     putchar(c);
+     ++*ret;
+     return fmt+1;
+   }
+   const char* beg = fmt;
+   c = *++fmt;
+   if (c == '%') {
+     putchar(c);
+     ++*ret;
+     return fmt+1;
+   }
+   enum arg_class how = NONE;
+   const char* end = get_part(fmt, &how);
+   char part_fmt[256];
+   int n = end - beg;
+   assert(n + 1 < sizeof part_fmt/sizeof part_fmt[0]);
+   strncpy(&part_fmt[0], beg, n);
+   part_fmt[n] = '\0';
+   if (how == WORD) {
+     int arg = arg32(sd, cpu, (*nth)++);
+     *ret += printf(part_fmt, arg);
+     return end;
+   }
+   if (how == DW) {
+     if (*nth & 1)
+       ++*nth;
+     uint64_t arg = arg64(sd, cpu, *nth);
+     *nth += 2;
+     *ret += printf(part_fmt, arg);
+     return end;
+   }
+   if (how == DF || how == LDF) {
+     if (*nth & 1)
+       ++*nth;
+     union {
+       uint64_t i;
+       double d;
+     } u = { arg64(sd, cpu, *nth) };
+     *nth += 2;
+     if (how == DF)
+       *ret += printf(part_fmt, u.d);
+     else
+       *ret += printf(part_fmt, (long double)u.d);
+     return end;
+   }
+   if (how == STR) {
+     uint32_t addr = arg32(sd, cpu, (*nth)++);
+     char buf[256];
+     for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i) {
+       char c = sim_core_read_1(cpu, PC_byteaddr, read_map, addr+i);
+       buf[i] = c;
+       if (c == '\0') {
+ 	*ret += printf(part_fmt, &buf[0]);  // ok
+ 	return end;
+       }
+     }
+     assert(0 && "not enough buffer");
+     return end;
+   }
+   asm("int3");
+   return end;
+ }
+ 
+ static void do_printf(SIM_DESC sd, SIM_CPU* cpu)
+ {
+   const char* fmt = first_string(sd, cpu, TRUE);
+   int nargc = 1;
+   int ret = 0;
+   while (*fmt)
+     fmt = handle(sd, cpu, fmt, &nargc, &ret);
+   cpu->pru_cpu.regs[14] = ret;
+ }
+ 
+ static void do_puts(SIM_DESC sd, SIM_CPU* cpu)
+ {
+   const char* arg = first_string(sd, cpu, FALSE);
+   int ret = puts(arg);
+   cpu->pru_cpu.regs[14] = ret;
+ }
+ 
+ static void do_putchar(SIM_DESC sd, SIM_CPU* cpu)
+ {
+   int arg = first_arg(sd, cpu, false);
+   int ret = putchar(arg);
+   cpu->pru_cpu.regs[14] = ret;
+ }
+ 
  /* Simulate one instruction.  */
  static void
  sim_step_once (SIM_DESC sd)
***************
*** 529,542 ****
  
    /* Fetch the initial instruction that we'll decode.  */
    inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);
    TRACE_MEMORY (cpu, "read of insn 0x%08x from %08x", inst, PC_byteaddr);
  
    op = pru_find_opcode (inst);
  
    if (!op)
      {
!       sim_io_eprintf (sd, "Unknown instruction 0x%04x\n", inst);
!       RAISE_SIGILL (sd);
      }
    else
      {
--- 720,757 ----
  
    /* Fetch the initial instruction that we'll decode.  */
    inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);
+   switch (inst) {
+   case 0xbadbeef0: exit(0);
+   case 0xbadbeef1:
+     do_printf(sd, cpu);
+     ++CPU.pc;
+     inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);
+     break;
+   case 0xbadbeef2:
+     do_puts(sd, cpu);
+     ++CPU.pc;
+     inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);
+     break;
+   case 0xbadbeef3:
+     do_putchar(sd, cpu);
+     ++CPU.pc;
+     inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);
+     break;
+   }
    TRACE_MEMORY (cpu, "read of insn 0x%08x from %08x", inst, PC_byteaddr);
  
    op = pru_find_opcode (inst);
  
    if (!op)
      {
!       if (inst == 0x26badbee) {
! 	sim_engine_halt (CPU_STATE (cpu), cpu, NULL, PC_byteaddr,
! 			 sim_stopped, SIM_SIGTRAP);
!       }
!       else {
! 	sim_io_eprintf (sd, "Unknown instruction 0x%04x\n", inst);
! 	RAISE_SIGILL (sd);
!       }
      }
    else
      {
***************
*** 690,697 ****
        else
  	return 0;
      }
!   else
      return 0;
  }
  
  static void
--- 905,914 ----
        else
  	return 0;
      }
!   else {
!     asm("int3");
      return 0;
+   }
  }
  
  static void
