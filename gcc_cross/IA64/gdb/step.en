By fixing break-point problem, then I faced to the problem about step command
like below:

Breakpoint 1 at 0x1d1: file test.c, line 8.

Breakpoint 1, main () at test.c:8
8	  return f(5, 6);
(ia64-elf-gdb) step
f (a=-858993460, b=-858993460) at test.c:2
2	{
(ia64-elf-gdb)

ia64-elf-gdb could not skip prologue correctly.
I confirmed that `ia64_skip_prologue' was not called after step command like
below:

M-x gdb
gdb --annotate=3 ./gdb
(gdb) cd ~/lang/53_GNU_tool/gcc_cross/IA64/test/test004
(gdb) run -q -x gdbcom test.elf
...
Reproduced by executing from gdb

(gdb) b ia64_skip_prologue
(gdb) b step_command
(gdb) run
...
`ia64_skip_prologue' break-point hit before `step_command' break-point hit.
(gdb) disable 1   # disable `ia64_skip_prologue' break-point
(gdb) c
...
`step_command' break-point hit.
(gdb) enable      # enable `ia64_skip_prologue' break-point
(gdb) c
...
`ia64_skip_prologue' break-point did not hit.
...
f (a=-858993460, b=-858993460) at test.c:2
2	{
A debugging session is active.


Then I tried to examine the reason why `ia64_skip_prologue' was not called.

After `step_command' break-point hit, the next condition:

  if (!frame_id_eq (get_stack_frame_id (frame),
		    ecs->event_thread->control.step_stack_frame_id)
      && (frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
		       ecs->event_thread->control.step_stack_frame_id)
	  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,
			    outer_frame_id)
	      || (ecs->event_thread->control.step_start_function
		  != find_pc_function (ecs->event_thread->stop_pc ())))))
    {

should have been satisfied.

(gdb) p frame_id_eq (get_stack_frame_id (frame), ecs->event_thread->control.step_stack_frame_id)
$413 = false  # OK
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
$417 = false  # Unexpected
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$418 = {stack_addr = 0xfc0, code_addr = 0x1a0, special_addr = 0xf90, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x1, 
  artificial_depth = 0x0}
(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$419 = {stack_addr = 0xfc0, code_addr = 0x1a0, special_addr = 0xfc0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x1, 
  artificial_depth = 0x0}
(gdb) 

`special_addr' member value was different between above two. Here, I noticed
that BSP was reasd-only special register, which was described at:

Software Development Mannual Volume 1

Then, I tried like below:

ia64-tdep.c:1896
  if (cache->base != 0)
    (*this_id) = frame_id_build_special (cache->base, cache->pc, cache->bsp);  // This line
  if (gdbarch_debug >= 1)

(gdb) b ia64-tdep.c:1896
(gdb) command
>silent
>if (cache->pc == 0x1a0)
 >set cache->bsp=0xfc0
 >end
>c
>end
(gdb) run

Above meant that BSP for `main' frame should be 0xfc0 not 0xf90.
...
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x130 lma 100
Loading section .IA_64.unwind_info, size 0x28 lma 230
Loading section .IA_64.unwind, size 0x30 lma 258
Start address 100
Transfer rate: 3136 bits in <1 sec.
Breakpoint 1 at 0x1d1: file test.c, line 8.

Breakpoint 1, main () at test.c:8
8	  return f(5, 6);

f (a=5, b=6) at test.c:3
3	  return a + b;
A debugging session is active.


This was expected result. i.e. BSP for `main' frame was not correct.

Here, I also noticed that br.call.sptk.many instruction was not implemented
correctly and br.ret.sptk.many.
