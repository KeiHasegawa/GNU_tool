I created the simple program like below:

int f(int a, int b)
{
  return a + b;
}

int main()
{
  return f(5, 6);
}

And built like below:

% ia64-elf-gcc -o test.o test.c -g -c
% ia64-elf-ld -o test.elf ../default.o test.o -T ../default.x

where, ../default.o was startup routine.

Then executed test.elf under control of ia64-elf-gdb like below:

% cat gdbcom.2
set prompt (ia64-elf-gdb) 
target sim
load
sim memory-fill 0xcc
sim memory-region 0xe00,0x208
b main
run
quit
% ia64-elf-gdb -q -x gdbcom.2 test.elf
Reading symbols from test.elf...
Connected to the simulator.
Loading section .text, size 0x130 lma 100
Loading section .IA_64.unwind_info, size 0x28 lma 230
Loading section .IA_64.unwind, size 0x30 lma 258
Start address 100
Transfer rate: 3136 bits in <1 sec.
Breakpoint 1 at 0x1d1: file test.c, line 8.              (*1)

Breakpoint 1, 0x00000000000001d0 in main () at test.c:7  (*2)
7	{
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
%

Note that the address of break-point of `main' is 0x1d1 => (*1)

So, before break-point working, I fixed like below:

extern "C"
void execute_for_me(SIM_DESC sd, sim_cpu* cpu, uint32_t tmp, sim_cia cia)
{
...
  if (insn[1] == 0x3333300) {
    cpu->psr |= (1 << 24) | (1 << 13) ;
    cpu->pc += 1;
    sim_engine_halt(sd, cpu, 0, cpu->pc, sim_stopped, SIM_SIGTRAP);
  }

By above fix, simulator part became to be able to detect break instruction.
But at this point, ia64-elf-gdb could not work well. => (*2)
Stopped source line should be test.c:8, not test.c:7.
