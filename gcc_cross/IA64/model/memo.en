cc1 model

Refer to "AARCH64" => "cc1 model" => "Memo".
In similar way, cc1 model of IA64 can be built.

Development note:

(*1)
2022.08.03 10:12 hello world 11 program can be executed with ia64-elf-run as
I expected.

(*2)
I had arealdy known that original cc1 did not generate .debug_frame section.
So I tried below:

#undef PREFERRED_DEBUGGING_TYPE
#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG

But when I stepped into `f' from `main' ia64-elf-gdb aborted.

Once I canceled above macro declaration.

(*3)
Intentionally, I did not add the property like below

  RTX_FRAME_RELATED_P(insn) = true;

for all rtx_insn* insn generated at ia64::expand_prologue.

Then I executed hello world 11 with ia64-elf-gdb

% ia64-elf-gdb -q -x gdbcom.2 a.elf
...
Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
(ia64-elf-gdb) s
f (a=5, b=6) at a.c:5
5	  return a + b;
(ia64-elf-gdb) where
#0  f (a=5, b=6) at a.c:5
#1  0x0000000000000000 in ?? ()
(ia64-elf-gdb) quit
...
%

`where' command did not work.

I had already known that original `cc1' generated some pseudo instruction.
Then I tried to emit them:

     .proc	f#
     .prologue
     .save	ar.pfs, r?
     .vframe	r?
     .save	rp, r?
     .body
     .restore	sp
     .endp	f#

But ia64-elf-gdb still could not recognize function return address.
Of cause, ia64-elf-gdb could recognize function return address of the program
generated by originail `cc1'.

I decided to examine how ia64-elf-gdb calculated function return address
of the program generated by original `cc1'.

I noticed that ia64-elf-gdb calculated function return address at

      if (pc_p)
	{
	  this_frame->prev_pc.value = pc;         // Here
	  this_frame->prev_pc.status = CC_VALUE;

And above `pc' was calculated at


	  pc = gdbarch_unwind_pc (prev_gdbarch, this_frame);  // Here


And more, above was calculated at

  else if (regnum == IA64_IP_REGNUM)
    {
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      if (addr != 0)
	{
#if 0  
	  read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8, byte_order);
#else
	  safe_read_memory_unsigned_integer(addr,
					    8, byte_order, &pc);
#endif	  
	}
      else if (cache->frameless)
	{
	  get_frame_register (this_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8, byte_order);  // Here
	}

original `cc1' doesn't generate code saving `b0' register for `f'.
On the other hand, my `cc1' generate code saving `b0' into r34

Then I tried like below:

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-12.1.0.ia64-elf/host-i686-pc-linux-gnu/gcc
% cat -n b.c
     1	extern int printf(const char* , ...);
     2	
     3	int f(int a, int b)
     4	{
     5	  return a + b;
     6	}
     7	
     8	
     9	int g(int a, int b)
    10	{
    11	  return f(a-1, b-1);
    12	}
    13	
    14	int main()
    15	{
    16	  printf("hello world %d\n", g(5, 6));
    17	  return 0;
    18	}
%

Normally, I built b.elf with -g option and executed it under control of
ia64-elf-gdb:

% ia64-elf-gdb b.elf -x gdbcom.2 -q
...
Connected to the simulator.
Loading section .text, size 0x280 lma 100
Loading section .IA_64.unwind_info, size 0x40 lma 390
Loading section .IA_64.unwind, size 0x48 lma 3d0
Loading section .rodata, size 0x10 lma 380
Start address 100
Transfer rate: 6336 bits in <1 sec.
Breakpoint 1 at 0x2f1: file b.c, line 16.

Breakpoint 1, main () at b.c:16
16	  printf("hello world %d\n", g(5, 6));
(ia64-elf-gdb) s
g (a=<error reading variable: Cannot access memory at address 0xffffffffffffffb8>, b=<error reading variable: Cannot access memory at address 0xffffffffffffffb8>) at b.c:11
11	  return f(a-1, b-1);
(ia64-elf-gdb) 

I thought I should fix this problem before fixing ia64-elf-gdb `where' command
for the program generated by my `cc1'.
