AVR の特徴

命令用メモリ 128 KB
データ用 SRAM 64 KB - 0x60
命令長 16 ビット
8 bit 汎用レジスタ 32 個

 命令用メモリ空間
+--------------+ 0x00000
|              |
|              |
|              |
|              |
|              |
|              |
|              |
|              | 
|              | 
|              |
|              |
+--------------+ 0x20000

他のマイコンと大きく異なる点は命令用とデータ用でメモリ空間が分かれていることで, 命令用の
メモリにストア命令を発行することはできない(発行した場合, シミュレータは単に無視している).
しかし LPM 命令でロードならばできる.
.data や .rodata の変数の初期値もここにロードされる.


データメモリ空間
+--------------+ 0x00000
|     r0       |
|     .        |
|     .        |
|     .        |
|     r31      |
+--------------+ 0x00020
|              |
|              |
| I/O レジスタ   |
|              |
| スタックポインタ| 0x0005d
|              |
+--------------+ 0x00060
|              |
|              |
|    SRAM      |
|              |
|              |
+--------------+ 0x10000

データメモリ空間の先頭 32 バイトは汎用レジスタにマップされている.
さらに続く 0x40 バイトは I/O レジスタにマップされている.
特に, I/O レジスタ領域のオフセット 0x3d から 2 バイトはスタックポインタ
の役割をしている. つまり rcall, ret, push 命令によって参照され, 更新される.
最後の 0x10000 - 0x60 バイトはプログラム自由に使ってよい領域である.
SRAM と言った場合上の全体を指すこともある.

(*1) 簡単なサンプル

test000_start.S は main 函数を呼び出し, そこから加算をする f を呼び出して終了するという
もの.

test000_start.S ではスタックポインタをセットするため

	ldi r16, 0xff
	out 0x3d, r16
	ldi r16, 0xfe
	out 0x3e, r16

のようにしている. これでスタックポインタが 0xfffe になる.
gdb は仮想アドレス 0x00800000 は SRAM の先頭アドレスとして
解釈する. 

(avr-elf-gdb) x/2bx 0x0080005d

のようにすれば上の命令の実行でメモリが書き替えられるのが確認できる.
また r16 を ldi 命令で使用しているから

(arv-elf-gdb) x/1xb 0x00800010

のようにすればレジスタが書き替えられていることも確認できる.

(*2) 文字列

test001.c は文字の長さを計算する f を呼び出すプログラムである.
arv-elf-gcc は文字を通常のコンパイラと同じように .rodata セクションに
出力する.

    LOAD off    0x000000fc vaddr 0x00800060 paddr 0x00000088 align 2**0
         filesz 0x0000000e memsz 0x0000000e flags rw-


これはロードされるアドレスが 0xfc 番地だが実行されるアドレスが

0x00800060

ということなのでそのアドレスに main を呼び出す前にコピーしておく必要がある.

(*3) hello world

wbuf.c で

  *fp->_p++ = c;

のようにしているが, fp->_p の値は 0. つまりアドレスの 0 に対してストアしている.


(avr-elf-gdb) x/i $pc
=> 0x3b6 <__swbuf_r+254>:	st	Z, r18
(avr-elf-gdb) p/c $r18
$8 = 104 'h'
(avr-elf-gdb) p $r30
$9 = 0
(avr-elf-gdb) p $r31
$10 = 0
(avr-elf-gdb)

write が呼び出される以前の問題. さてこれは何がまずいのか.
