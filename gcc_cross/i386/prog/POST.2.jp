(*1) セグメントレジスタへの値のセット
(*2) cld, rep, stosw
(*3) 0x19 の割り込み
(*4) 0x19 の割り込み(2)
(*5) セグメントレジスタで 64 KB の壁を超える
(*6) 16 ビットの C コード





(*1) セグメントレジスタへの値のセット

normal_post:
...
	xor	%ax, %ax
	mov	%ax, %ds
	mov	%ax, %ss

では DS や SS をクリアしている. この部分の実際のシミュレーションを確認してみた.

  void BX_CPP_AttrRegparmN(2)
BX_CPU_C::load_seg_reg(bx_segment_reg_t *seg, Bit16u new_value)  ★ ここ
{
  if (protected_mode())

この命令のシミュレーションでは上の函数が呼び出されている. 以下は

	mov	%ax, %ds

に対するときの値:

(gdb) p new_value
$6 = 0
(gdb) p/x *seg
$7 = {selector = {value = 0x0, index = 0x0, ti = 0x0, rpl = 0x0}, cache = {valid = 0x7, p = 0x1, dpl = 0x0, segment = 0x1, type = 0x3, u = {segment = {base = 0x0, limit_scaled = 0xffff, g = 0x0, d_b = 0x0, avl = 0x0}, gate = {param_count = 0x0, dest_selector = 0x0, dest_offset = 0xffff}, taskgate = {tss_selector = 0x0}}}}
(gdb) 

...
  seg->selector.value = new_value;      ★ この値が new_value で変更されるらしいが 
  seg->selector.rpl = real_mode() ? 0 : 3;
  seg->cache.valid = SegValidCache;
  seg->cache.u.segment.base = new_value << 4;
  seg->cache.segment = 1; /* regular segment */
  seg->cache.p = 1; /* present */

他のメンバも更新されるということ. なるほど, これによれば 0 クリアすること自体にも意味があると
いうこと.

(*2) cld, rep, stosw

20222.04.26 11:00
ix86 である領域に値をセットするには以下のようにするらしい.

	# clear BIOS data area
	mov	%ax, %es
	mov	$bios_data_size, %cx
	sar	%cx
	mov	$bios_data, %di 
	cld
	rep
	stosw

bios_data は 0x400 でこの 256 バイトの領域を %ax の値でセットするのが上のコード.
ここで一応 cld, rep, stosw 命令について知っておく.

cld は Clear Direction Flag という命令でフレグレジスタにある DF フラグ
をクリアする命令らしい.

rep, stosw 命令は

この組み合わせで使用される.

void BX_CPP_AttrRegparmN(1) BX_CPU_C::REP_STOSW_YwAX(bxInstruction_c*i) ★
{

シミュレーションしている函数は上だった. 要は rep 命令は次の命令を定数回繰り返すような
命令らしい. そして stosw は %di レジスタをデスティネーションアドレスと
して %es レジスタを書き込む命令らしい. これを %cx 回繰り返すということ.

(*3) 0x19 の割り込み

2022.04.26 14:30
現段階で不完全ではあるものの post_init_ivt を呼び出してそこから戻っている.

POST の最後の処理は

	sti	# enable interrupts
	int	$0x19

のようにしている.

int19_handler:
	jmp	int19_relocated

	.global	int19_relocated
int19_relocated: # Boot function, relocated
...
	push	%ax

int19_next_boot:

	# Call the C code for the next boot device
	call int19_function

というわけで int19_function が呼び出されるということらしい.

(*4) 0x19 の割り込み(2)

2022.04.26 14:50
少し乱暴だが post_init_ivt を呼び出したところで 0x19 の割り込みを発生させてみた.


int19_relocated: # Boot function, relocated
...
	push	%bp        ★ この命令で不正メモリアクセスが発声している

(i386-elf-gdb) sim memory-info
Memory maps:
 memory region 0x00000000,0x400
 memory region 0x00000400,0x100
 memory region 0x0000e6f2,0x3
 memory region 0x0000efd2,0xc
 memory region 0x0000e0b5,0x157
 memory region 0x0000f841,0xb
 memory region 0x0000f84d,0xb
 memory region 0x0000f859,0x2
 memory region 0x0000ff53,0x1
 memory region 0x0000fff0,0x7    ★ Power On Reset の ljmp 命令
 memory region 0x0000fff8,0x6    ★ 現状のスタック
(i386-elf-gdb) p/x $esp
$1 = 0xfff8
(i386-elf-gdb) 

さてこのエラーをどのように回避するべきだろうか.

  => 実は後になって判明するのだが Power On Reset 後の ljmp 命令が正しくない.
     16 ビットのコードになっていれば 7 バイトではなくて 5 バイトで済んでいて
     スタッックの領域はこれでもたりていた. このときは違う回避をしていた.

por.x は現状以下:

	. = 0xfffe;
	stack = .;

以下のようにしてみた:

	. = 0x10000;
	stack = .;

リンクで以下のエラーになる:
post.o: in function `normal_post':
/home/khasegawa/lang/53_GNU_tool/gcc_cross/i386/test/test005/post.S:50:(.text+0x2b): relocation truncated to fit: R_386_16 against symbol `stack' defined in .por section in test.elf
int18.o: in function `int18_handler':
/home/khasegawa/lang/53_GNU_tool/gcc_cross/i386/test/test005/int18.S:6:(.text+0x1): relocation truncated to fit: R_386_16 against symbol `stack' defined in .por section in test.elf
int18.o: in function `int19_relocated':
/home/khasegawa/lang/53_GNU_tool/gcc_cross/i386/test/test005/int18.S:33:(.text+0x1e): relocation truncated to fit: R_386_16 against symbol `stack' defined in .por section in test.elf

一応これは期待した動作ではある. これがエラーとして捕えられなければ生成
されるコードは

	mov	$stack, %sp

に対して

	mov	$0, %sp

になってしまうからリンカがエラーを適切に捕えている. それはそれで OK.
そこで以下のようにしてみた:

	. = 0x0;  /* 0x10000 */
	stack = .;

なんだか少しずるい気もするが, 今自分が生成したいコードがそれなのでこうした.
そして

sim memory-region 0xfff8,6

を

sim memory-region 0xfff8,8

のように修正した. これで一応エラーを回避できている.

(*5) セグメントレジスタで 64 KB の壁を超える

20022:04.26 15:00

	# Start from the first boot device (0, in AX)
	mov	$0x9ff0, %bx 	# 0x9ff0:IPL_SEG
	mov	%bx, %ds        #  Set segment to write to the IPL memory
★ これ	mov	%ax, 0x82    	# Save the sequence number
				# 0x82:IPL_SEQUENCE_OFFSET
	mov	%ax, %ds	# and reset the segment.
	
	push	%ax

現状この命令で不正メモリアクセスエラーが発生している:

core: 2 byte write to unmapped address 0x9ff82 at 0xe201
                                          ★ 64 KB の壁を超えたらしい
					     そして不正メモリアクセスエラー

%ds = 0x9ff0

なので

	mov	%ax, 0x82

は  0x9ff82 番地にアクセスするというわけだ. これがセグメントの考え方.

一応シミュレーションしている部分を確認してみる:

  BX_CPP_INLINE void BX_CPP_AttrRegparmN(3)
BX_CPU_C::write_virtual_word_32(unsigned s, Bit32u offset, Bit16udata) ★
{
  Bit32u laddr = agen_write32(s, offset, 2);
  write_linear_word(s, laddr, data);
}

上の函数が

void BX_CPP_AttrRegparmN(1) BX_CPU_C::MOV_OdAX(bxInstruction_c *i)

から呼び出されていることを確認した. このとき

(gdb) p s
$15 = 3

つまり 3 番のセグメントレジスタ, すなわち %ds ということ.

このエラーを回避するだけなら 0x9ff82 番地に 2 バイトメモリを割り当てればよい
ので i386-elf-gdb のコマンドで対応しておいた:

sim memory-region 0xfff8,8     スタック
sim memory-region 0x9ff82,2    IPL SEQUENCE で使用される. 今回追加.

初めて 64KB の壁を突破したことになる.

(*6) 16 ビットの C コード
現状 int19_function は空の函数だが

void int19_function(uint16_t seq_nr)
{
}

i386-elf-gcc -o cfun.o cfun.c -c -g

のようにコンパイルしている. そして生成されるコードは

int19_function:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp
	movl	8(%ebp), %eax
	movw	%ax, -4(%ebp)
	nop
	leave
	ret

のようなものである. さて 16 ビット用のコードが生成できるかどうかは不明.
引数の seq_nr が正しく表示されないのは ebp 相対 -12 にあるとされているから.

オリジナルの i386-elf-gcc のソースを覗いてみた:

static void
x86_file_start (void)
{
  default_file_start ();
  if (TARGET_16BIT)
    fputs ("\t.code16gcc\n", asm_out_file);  ★


おそらく TARGET_16BIT が true に評価される状況を作れば 16 ビット用のコードを
生成してくれると思われる.

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.i386-elf/gcc/config/i386/i386.opt

から以下を発見:

m16
Target RejectNegative Negative(m32) Report Mask(CODE16) InverseMask(ISA_64BIT) Var(ix86_isa_flags) Save
Generate 16bit i386 code.

% i386-elf-gcc -S cfun.c -m16
見た目はあまり変わらないが

	.file	"cfun.c"
	.code16gcc
	.text
...
int19_function:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp
	movl	8(%ebp), %eax
	movw	%ax, -4(%ebp)
	nop
	leave
	ret

おそらくだがこれでできているはず.
  => 実はこれではだめだった

2022.04.26 16:30

(i386-elf-gdb) b int19_function
(i386-elf-gdb) run
...
int19_function のブレークポイントにヒット
(i386-elf-gdb) disassemble
Dump of assembler code for function int19_function:
=> 0x0000e1d4 <+0>:	push   %bp
   0x0000e1d6 <+2>:	mov    %sp,%bp
   0x0000e1d9 <+5>:	sub    $0x4,%sp
   0x0000e1dd <+9>:	mov    0x8(%di),%ax
   0x0000e1e2 <+14>:	mov    %eax,-0x4(%di)
   0x0000e1e6 <+18>:	nop
   0x0000e1e7 <+19>:	leavew 
   0x0000e1e9 <+21>:	retw   
End of assembler dump.
(i386-elf-gdb)

プロローグがスキップされていないことに気付く. また逆アセンブルの結果が 16 ビットモード
になっている.

そして最初の引数は %di レジスタ相対 8 にあるように見える.
  => 実は逆アセンブルの結果が正しくないからそもそもが正しくない.

(i386-elf-gdb) stepi 3
(i386-elf-gdb) x/i $eip
=> 0xe1dd <int19_function+9>:	mov    0x8(%di),%ax         ★
(i386-elf-gdb) info register
eax            0x0                 0
ecx            0x0                 0
edx            0x0                 0
ebx            0x9ff0              40944
esp            0xfff4              0xfff4 <power_on_reset+4>
ebp            0xfff8              0xfff8
esi            0x0                 0
edi            0x400               1024
eip            0xe1dd              0xe1dd <int19_function+9>
eflags         0x46                [ PF ZF ]
cs             0xf000              61440
ss             0x0                 0
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(i386-elf-gdb) stepi
core: 4 byte read to unmapped address 0x10000 at 0xe1dd

ここでエラーしている. この mov 命令で 0x10000 番地にアクセスする理由を調べてみる.

BX_CPP_INLINE Bit32u BX_CPP_AttrRegparmN(1) BX_CPU_C::BxResolve32(bxInstruction_c *i)
{
  Bit32u eaddr = (Bit32u) (BX_READ_32BIT_REG(i->sibBase()) + i->displ32s()); ★

アドレスを計算しているのはこの部分.

(gdb) p i->displ32s()
$28 = 8
(gdb) 

8 は %di 相対 8 ということ.
  => %ebp の間違い. 逆アセンブルの結果が正しくない.

(gdb) p i->sibBase()
$29 = 5
(gdb)

状況からすると 5 番のレジスタすなわち %ebp を読み出してそれに 8 を加算して 0x10000
となっている. そもそも逆アセンブルの結果と命令が合致していない. 命令のシミュレーション
は bochs だが逆アセンブルルーチンは i386-elf-gdb に組み込まれていたものだから.


void BX_CPP_AttrRegparmN(1) BX_CPU_C::MOV32S_GdEdM(bxInstruction_c *i)
{
  Bit32u eaddr = (Bit32u) BX_CPU_RESOLVE_ADDR_32(i);
#if 0  
  Bit32u val32 = stack_read_dword(eaddr);
#else
  Bit32u val32 = sim_core_read_aligned_4_for_me(eaddr);  ★ ここでエラー
#endif  

  BX_WRITE_32BIT_REGZ(i->dst(), val32);

  BX_NEXT_INSTR(i);
}

エラーはこの部分で発生しているのだがこれは 32 ビットでレジスタにロードしているということ.
つまり

	movl	8(%ebp), %eax

に相当することが行なわれている.
cfun.S に期待値を作成してみた. 以下はその一部:

	.file	"cfun.c"
	.code16gcc		★
	.text
...
int19_function:
.LFB1:
	.loc 1 55 1
	.cfi_startproc
	push	%bp		★
	.cfi_def_cfa_offset 4	★
	.cfi_offset 5, -4	★
	mov	%sp, %bp	★
	.cfi_def_cfa_register 5
	sub	$2, %sp	      	★
	movw	2(%bp), %ax	★
	movw	%ax, -2(%bp)	★
	.loc 1 56 1
	nop
	leave                #  このときは leave のままで修正し切れず. leavew が正解
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
...
	.byte	0x91
	.sleb128 -10		★
	.byte	0

これで期待した動作になっている. というかでっちあげている. つまり, 単純に -m16 をオプションと
して付加したからといって自分が望むコードが生成されるというわけではないらしい.

さてどうするべきか考え中. むしろ自分がするべきことはこの -m16 を期待通り動作するように
オリジナルの i386-elf-gcc を修正することなのかも.

とはいえ今は BIOS を動作させることよりも 64 KB を超えてメモリにアクセスすることなので
そっちを目標にする.
