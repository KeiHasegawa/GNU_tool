cc1 の雛形

「AARCH64」=>「cc1 の雛形」=>「メモ」 を参照.
AARCH64 と同様の手順で cc1 の雛形をビルドすることができる.

開発記録

(*1)
hello world をコンパイルしたところ __main を呼び出すコードが生成されている.

static void
expand_main_function (void)
{
#if (defined(INVOKE__main)				\
     || (!defined(HAS_INIT_SECTION)			\
	 && !defined(INIT_SECTION_ASM_OP)		\
	 && !defined(INIT_ARRAY_SECTION_ASM_OP)))
  emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode);
#endif
}

ここから問題の rtx_insn が生成されていた. ひとまず, 原因は判明したし, これが悪さを
することはなさそうなのでこのままにしておく.

(*2)
Z8000 は printf にスタックで引数を渡すのだが, ここで push 命令を生成したい.
現状 main 函数のコードは以下:

_main:
	push	@r15, r10
	ld	r10, r15
	call	___main
	ld	r6, #6
	ld	r7, #5
	call	_f
	ld	r3, r2
	r15 := r15 + -4
	ld	r2, r15
	(mem:HI (plus:HI (reg:HI 2 r2 [27])
        (const_int 2 [0x2])) [0  S2 A8]) := r3
	(mem:HI (reg:HI 2 r2 [27]) [0  S2 A8]) := _LC0
	call	_printf
	r15 := r15 + 4
	ld	r2, #0
	ld	r15, r10
	pop	r10, @r15
	ret	t

まずは

#define PUSH_ROUNDING(X)	(X)

だけを z8k.h に追加して生成コードがどのように変化するか確認する.
2022.03.23 11:00 ビルド開始.

11:30 に確認したところこれだけで期待する rtx_insn が生成されている.

define pushhi1 は必要なかった.

(*3)
現状

hello world 11

ができている. そして

  RTX_FRAME_RELATED_P(insn) = true;

のような rtx_insn は生成していない. -g オプション付きで hello world 11 をコンパイル
した結果の抜粋は以下:

	.stabs	"/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/",100,0,2,_Ltext0
	.stabs	"a.c",100,0,2,_Ltext0
	.text
_Ltext0:
	.stabs	"gcc2_compiled.",60,0,0,0
	.align	0
	.stabs	"f:F(0,1)=r(0,1);-32768;32767;",36,0,3,_f
	.stabs	"int:t(0,1)",128,0,0,0
	.stabs	"a:p(0,1)",160,0,3,-2
	.stabs	"b:p(0,1)",160,0,3,-4
	.global	_f
_f:
	.stabn	68,0,4,_LM0-_LFBB1
_LM0:
_LFBB1:
	push	@r15, r10

それっぽく生成されている. リンク後の a.coff の objdump の結果の抜粋は以下:

セクション:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000d4  00000100  00000100  000000a8  2**1
                  CONTENTS, ALLOC, LOAD, CODE
  1 .stab         00000330  00000000  00000000  0000017c  2**1
                  CONTENTS
  2 .stabstr      000000df  00000000  00000000  000004ac  2**0
                  CONTENTS
...
int16 f (int16 a /* 0xfffffffe */, int16 b /* 0xfffffffc */)
{ /* 0x17c */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 4 addr 0x17c */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 5 addr 0x18a */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 6 addr 0x194 */
} /* 0x19a */
typedef int16 int;
int16 main ()
{ /* 0x1aa */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 9 addr 0x1aa */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 9 addr 0x1ae */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 10 addr 0x1b2 */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 11 addr 0x1ca */
  /* file /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.z8k-coff.mine/host-i686-pc-linux-gnu/gcc/a.c line 12 addr 0x1ce */
} /* 0x1d4 */

これもそれっぽい.

z8k-coff-gdb でこのプログラムを動作させ main にブレークポイントをセットしたところ以下のように
なった:

Connected to the simulator.
Loading section .text, size 0xd4 lma 0x100
Start address 0x100
Transfer rate: 1696 bits in <1 sec.
Breakpoint 1 at 0x1ae: file a.c, line 9.

これはソースファイルと行番号の対応ができていそうに見える. 実際のところは適切にプロローグ
をスキップできてはいないが, オリジナルのコンパイラでは全くできていなかった部分.

つまり「Z8000 の gdb」=>「C の函数にブレークポイント」ではどこに原因があるか解決
できなかったが, これだけの現象から推測するとコンパイラに問題があったということになる.

これ以降は z8k-coff-gdb 側から動作の解析を行なう.

(*4)
z8k-coff-gdb から調査した結果, f にステップインしたときプロローグを適切にスキップできない
原因はローカルラベルの扱いができていないこと.

現状以下のように

_f:
	.stabn	68,0,4,_LM0-_LFBB1
_LM0:
_LFBB1:

ローカルラベルであるべきものが函数のラベルと変わらないものになっている.
これを修正する.
ローカルラベルは以下のように名前を付けられているらしい:

  char label[256];
...
  ASM_GENERATE_INTERNAL_LABEL (label, "LC", labelno);

そこで以下のように修正した:

void z8k_asm_output_labelref(FILE* fp, const char* label)
{
  if (label[0] == '.')
    fprintf(fp, "%s", label);
  else
    fprintf(fp, "_%s", label);
}

extern void z8k_asm_output_labelref(FILE*, const char*);
#define ASM_OUTPUT_LABELREF(FILE, NAME) z8k_asm_output_labelref(FILE, NAME)

これで期待通りの生成結果になる:

_f:
	.stabn	68,0,4,.LM0-.LFBB1
.LM0:
.LFBB1:
	push	@r15, r10
	ld	r10, r15
	dec	r15, #4
	ld	-2(r10), r7
	ld	-4(r10), r6
	.stabn	68,0,5,.LM1-.LFBB1
.LM1:
