z8k-coff-ld が生成するコードのアドレスに 0x80000XXX のようにビット 31 がセット
される原因を調査してみる.

(gdb) run -o test.elf test.o -T ../default.x
...

% z8k-coff-objdump -g test.elf
...
test.S:
/* file test.S line 3 addr 0x80000100 */
/* file test.S line 4 addr 0x80000102 */
/* file test.S line 5 addr 0x80000104 */
/* file test.S line 7 addr 0x80000106 */

再現している. どこかで .text セクションを読み込んでいるがおそらくそれは

bfd_get_section_contents

だと山を張ってみる.

(gdb) b bfd_get_section_contents
(gdb) run

デバッグ情報が ld-new から抜けているらしい. もう一度ビルド.

(gdb) run
...
ブレークポイントにヒット. .text セクションが読み出されていることを確認.
おそらく問題は .stab セクションを読み出し, そのアドレスを

0 -> 0x80000100
2 -> 0x80000102
4 -> 0x80000104
6 -> 0x80000106

のようにしている部分があると考えられる. .stab セクションを読み出していることも確認.

(gdb) fin

(gdb) p sz
$6 = 72
(gdb) x/72bx data
0x813d530:	0x00	0x00	0x00	0x01	0x00	0x00	0x00	0x05
0x813d538:	0x00	0x00	0x00	0x0f	0x00	0x00	0x00	0x08
0x813d540:	0x64	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x813d548:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x03
0x813d550:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x813d558:	0x44	0x00	0x00	0x04	0x00	0x00	0x00	0x02
0x813d560:	0x00	0x00	0x00	0x00	0x44	0x00	0x00	0x05
0x813d568:	0x00	0x00	0x00	0x04	0x00	0x00	0x00	0x00
0x813d570:	0x44	0x00	0x00	0x07	0x00	0x00	0x00	0x06
(gdb) 

おそらくだが最後の 6 は問題のアドレス 6 と予想.

	  dst = (dst & 0xffff) | ((dst & 0xff0000) << 8) | 0x80000000;
	  bfd_put_32 (in_abfd, dst, data + *dst_ptr);

ここでやっていた. そこで以下のように修正:

	  dst &= 0xffff;

これで自分が期待している動作にはなっている.

