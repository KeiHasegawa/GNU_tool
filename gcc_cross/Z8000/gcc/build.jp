不明なバージョンでビルドしてみた:

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work
% wget http://www.z80ne.com/m20/sections/download/z8kgcc/z8kgcc-jan-19-2009.tar.bz2
% bunzip2 -c z8kgcc-jan-19-2009.tar.bz2 | tar tvf - > z8kgcc-jan-19-2009.tar.bz2.list
% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG
% cd src/gcc
% ./configure --prefix=/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG --target=z8k-coff
% make
...
gcc -DCROSS_COMPILE -DIN_GCC    -g  -DHAVE_CONFIG_H   -o cccp cccp.o cexp.o prefix.o mbchar.o \
  version.o obstack.o   
/usr/local/lib/gcc/i686-pc-linux-gnu/10.2.0/../../../../i686-pc-linux-gnu/bin/ld: cexp.o:/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/./config/z8k/z8k.h:57: multiple definition of `target_flags'; cccp.o:/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/./config/z8k/z8k.h:57: first defined here

z8k.h を以下のように変更

extern char *call_used_option;
extern char *args_in_option;
extern char *args_mlist;
extern char *fakes_option;
...
extern int pmode;
...
extern int saved_reg_on_stack_hack;

% make

`if [ -f /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/../bison/bison ] ; then case . in /*) echo /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/../bison/bison -L ./../bison/ ;; *) echo /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/../bison/bison -L /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/src/gcc/./../bison/ ;; esac else echo bison ; fi`  -d c-parse.y -o c-parse.c
c-parse.y:1281.19-20: エラー: $$ に対する $4 midrule `structsp' が宣言された型を持っていません
 1281 | 		{ $$ = start_struct (RECORD_TYPE, $2);
      |                   ^~

これはさすがに無理っぽい.

structsp:
	  STRUCT identifier '{'
		{ $$ = start_struct (RECORD_TYPE, $2);
		  /* Start scope of tag before parsing components.  */
		}
	  component_decl_list '}' maybe_attribute 
		{ $$ = finish_struct ($<ttype>4, $5, $7); }

この書き方は知らない. $<ttype>4 で何を参照しているのか.
もしかすると古い bison では合法だったのかもしれない.

% cp c-parse.y c-parse.y.org
%

$<ttype>$
$<ttype>2

など出現している. 折角だからここを調べてみる.


$<ttype>$ で $$ ではなくて $$ の本来の型ではなくて ttype メンバを参照したいときにこのよう
に書くらしい.


finish_struct(tree, tree, tree) だから $<ttype>4 は何らかの tree 型を参照して
いる.


structsp:
	  STRUCT identifier '{'
		{ $$ = start_struct (RECORD_TYPE, $2);
		  /* Start scope of tag before parsing components.  */
		}
	  component_decl_list '}' maybe_attribute 
		{ $$ = finish_struct ($<ttype>4, $5, $7); }

ということは $<type>4 はおそらく $$ が正解かと思ったが違った.

これは以下のような文法中のルール

aaa : bbb { ... } ccc
    ;

の上の { ... } で $$ を参照すると生成されるメッセージらしい.

yyval.<メンバ名> を直接書けばおそらくこれを作成した人の意図と同じになる.

structsp の場合なら yylval.ttype になる.

これでエラーを回避できたが次のエラーがまた発生している.

gcc -DCROSS_COMPILE -DIN_GCC    -g  -DHAVE_CONFIG_H     -I. -I. -I./config -DYYTOKENTYPE -c \
 ./c-lex.c -o c-lex.o
...
./c-gperf.h:56:16: エラー: ‘TYPESPEC’ undeclared here (not in a function); did you mean ‘TYPE_DECL’?
   56 |       {"int",  TYPESPEC, RID_INT},

残念ながら gcc-3.4.4 でビルドをしたほうが良さそう.
