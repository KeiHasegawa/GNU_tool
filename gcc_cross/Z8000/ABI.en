Z8000 ABI

(*1) Registers

    r10 : frame pointer
    r15 : stack pointer

(*2) Function call

	call	func

	Pseudo code

	sp := sp - 2
	[sp] := (call next instuction address)
	pc := func

(*3) Return from function

	ret	t

	Pseudo code

	tmp := [sp]
	sp := sp - 2
	pc := tmp

(*4) Prologue

	push	@r15, r10
	ld	r10, r15
	dec	r15, #128
	
        Above is prologue for the function which uses 128 bytes local area.

     +0 +---------------+ <- r15_{new}
	|   		|
	|   		|
	~   		~
	|   		|
	|   		|
   +128 +---------------+ <- r10_{new}
	|   r10_{old}	|
	+---------------+ <- sp_{old}
	| return address|
	+---------------+

(*5) Epilogue

	ld	r15, r10
	pop	r10, @r15
	ret	t

        Above is epilogue which doesn't depends on function local area.
	r10, r15 are restored and return to callee.

(*6) Normal argument and return value

        sizeof(int) = 2

	1st : r7
	2nd : r6
	...
	6th : r2
	7th : use stack

	For exxample,

	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7);

	f(10, 11, 12, 13, 14, 15, 16, 17);

	at the start address of `f', registers and stack layout become
	like below:

	r7 = 10, r6 = 11, r5 = 12, r4 = 13, r3 = 14, r2 = 15

	+---------------+ <- sp_{old}
	| return address|
	+---------------+ +2
	|	16	|
	+---------------+ +4
	|	17	|
	+---------------+ +6

	For function taking variable number arguments, all arguments are
	passed by using stack.

	Function return value is set to `r2'.

(*7) `long', `long long' argument and return value

	sizeof(long) = 4
	sizeof(long long) = 8

	For a `long' argument, 2 registers are used. For example,

	long f(int a0, long a1, long a2, long a3);

	f(10, 11, 12, 0x12345678);

	at the start address of `f' registers and stack layout become
	like below:


	r7 = 10, r5 = 11, r4 = 0, r3 = 12, r2 = 0

	+---------------+ <- sp_{old}
	| return address|
	+---------------+ +2
	|     0x1234	|
	+---------------+ +4
	|     0x5678	|
	+---------------+ +6

	In this case, `r6' is not used.


