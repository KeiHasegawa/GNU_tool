PowerPC の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*1) 函数呼び出し

	bl func

	疑似コード

	lr = (bl 命令の次のアドレス)
	pc = func

(*2) 函数復帰

	blr

	疑似コード

	pc = lr

(*3) プロローグ

	stwu 1,-144(1)
	mflr 0
	stw 0,148(1)
	stw 31,140(1)
	mr 31,1

	上は 132 バイトの領域を使用する函数のプロローグである.

	+------------------+ <- r1_{new}, r31_{new}
	|     r1_{old}     |
	+------------------+
	|     ********     |
	+------------------+ +8    -
	|                  |       ^
	|                  |       |
	|    local area    |	  132
	|                  |       |
	|                  |       V
	+------------------+ +140  -
	|    r31_{old}     |
	+------------------+ <- r1_{old}
	|     ********     |	
	+------------------+ +148
	|     lr_{old}     |
	+------------------+
	|     ********     |	
	+------------------+

	実際はこの函数で 128 バイトの配列を宣言したがスタックは 132 バイト分確保
	している.
	r31 はフレームポインタのような使い方をしているが, 実際は r1 レジスタと
	同じアドレスを指している.

(*4) エピローグ

	addi 11,31,144
	lwz 0,4(11)
	mtlr 0
	lwz 31,-4(11)
	mr 1,11
	blr

	上は 132 バイトの領域を使用する函数のエピローグである.
	r31, lr, r1 が復元されて呼び出し元に復帰する.
	プロローグでは r1 の指す領域に r1 のもとの値を保存していたが, このエピローグでは
	その値を参照していない.

(*5) 通常の函数の引数と戻り値

        第 1 引数 : r3
        第 2 引数 : r4
	...
        第 8 引数 : r10
	第 9 引数以降 : スタックを使用する

	例えば

	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
	      int a8, int a9);
	      
	f(10, 11, 12, 13, 14, 15, 16, 17, 18, 19);

	に対して f の先頭アドレスでは

	r3 = 10, r4 = 11, r5 = 12, r6 = 13, r6 = 14, r7 = 15, r8 = 16, r9 = 17

	+------------------+ <- r1
	|     r1_{old}     |
	+------------------+
	|     ********     |
	+------------------+ +8
	|        18        |
	+------------------+ +12
	|        19        |
	+------------------+ +16

	のようになっている. ここで r1_{old} は f を呼び出す函数が呼ばれる前の r1 の
	値である.
	函数の戻り値は r3 レジスタにセットされる.

(*6) long long を引数にとる函数, 返す函数

	sizeof(long long) = 8

	第 1 引数が long long ならば r3, r4 レジスタに値がセットされる.
	第 2 引数が long long ならば r5, r6 レジスタに値がセットされる.
	第 3 引数が long long ならば r7, r8 レジスタに値がセットされる.
	第 4 引数が long long ならば r9, r10 レジスタに値がセットされる.
	第 5 引数以降はスタックを使用する.

	long long
	f(int a0, long long a1, long long a2, long long a3, long long a4);

	f(10, 0x123456789abcdef0L, 0x1122334455667788,
	  0x99aabbccddeeff00, 0x0fedcba987654321);

	に対して f の先頭アドレスでは

	r3 = 10
	r5 = 0x12345678, r6 = 0x9abcdef0
	r7 = 0x11223344, r8 = 0x55667788
	r9 = 0x99aabbcc, r10= 0xddeeff00

	+------------------+ <- r1
	|     r1_{old}     |
	+------------------+
	|     ********     |
	+------------------+ +8
	|    0x0fedcba9    |
	+------------------+ +12
	|    0x87654321    |
	+------------------+ +16

	のようになっている.
	函数の戻り値は r3, r4 にセットされる.
	
(*7) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

	float に対して
	第 1 引数 : f1
	...
	第 8 引数 : f8
	第 9 引数以降 : スタックを使用する.

	戻り値は f1 にセットされる.

	double に対しても同様. 浮動少数点レジスタが float の加算

	fadds

	に対して 4 バイトとしてプロセッサが扱うが

	faddd

	に対しては 8 バイトとしてプロセッサが扱うということなのだろうと思う.
	ところで
	
	(ppc-elf-gdb) p sizeof(long double)
	16
	(ppc-elf-gdb)
	
	のようになった. おそらくこれは間違いで 8 が正しい.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数とする函数を呼び出す場合, レジスタは使用せず, スタックに構造体がコピー
	される.
	構造体を返す函数を呼び出す場合, 戻り値を格納するアドレスが r3 レジスタにセットされ
	る.
