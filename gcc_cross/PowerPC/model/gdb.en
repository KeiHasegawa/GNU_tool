Now, for hello world 11 program generated by my `cc1' with -g option,
ppc-elf-gdb could not skip `f' prologue when stepping into `f' from main.

I investigated the reason from a view point of ppc-elf-gdb

(gdb) b step_command
(gdb) run
...
`step_command' break-point hit
(gdb)

I expected `handle_step_into_function' was called and confirmed like below:  

(gdb) b handle_step_into_function
(gdb) c
...
`handle_step_into_function' break-point hit
(gdb)

Skipping prologue is done by below function:

rs6000-tdep.c:1451
static CORE_ADDR
skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc, CORE_ADDR lim_pc,
	       struct rs6000_framedata *fdata)
{
...

(gdb) b skip_prologue
(gdb) c
...
`handle_step_into_function' break-point hit again.
(gdb) c
...
`skip_prologue' break-point hit.
(gdb) p/x pc
$1 = 0x0
(gdb) p/x lim_pc
$2 = 0x20000000
(gdb) 

Because at address 0 no code was located, above was not expected result.

(gdb) finish
And here, just returned 0, and could not skip prologue and then became like
below:

f (a=-858993460, b=0) at a.c:4
4	{
A debugging session is active.

For `a.elf' generated by original `cc1', of cause ppc-elf-gdb worked well,
and I did the same investigation and found that:

1. `step_command' break-point hit
2. `handle_step_into_function' break-point hit 3 times
3. `skip_prologue(pc=0x100)' was called

It may be correct that `handle_step_into_function' is caled 3 times.

  => 3 times reason is:

00000144 <main>:
 144:	94 21 ff f0 	stwu    r1,-16(r1)
 148:	7c 08 02 a6 	mflr    r0
 14c:	90 01 00 14 	stw     r0,20(r1)
 150:	93 e1 00 0c 	stw     r31,12(r1)
 154:	7c 3f 0b 78 	mr      r31,r1         (*) stop here and 3 instrunctions
 158:	38 80 00 06 	li      r4,6               will be executed and jump to
 15c:	38 60 00 05 	li      r3,5               `f'
 160:	4b ff ff b1 	bl      110 <f>


For a.elf generated by my `cc1', when `handle_step_into_function' break-point
was hit at 2 times and then I did like below:

(gdb) b process_event_stop_test

which calls `handle_step_into_function'

static void
process_event_stop_test (struct execution_control_state *ecs)
{
...
  if (!frame_id_eq (get_stack_frame_id (frame),
		    ecs->event_thread->control.step_stack_frame_id)
      && (frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
		       ecs->event_thread->control.step_stack_frame_id)
	  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,
			    outer_frame_id)
	      || (ecs->event_thread->control.step_start_function
		  != find_pc_function (ecs->event_thread->suspend.stop_pc)))))
    {

While this condition was evaluated, there existed `skip_prologue(pc=0)' call.
I did the same investigation for a.elf generated by original `cc1', and
found no `skip_prologue' call while above condition was evalueated.

For a.elf generated by original `cc1', at above condition:

(gdb) p frame_id_eq (get_stack_frame_id (frame), ecs->event_thread->control.step_stack_frame_id)
$3 = false
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
$4 = true
(gdb) p frame_id_eq (ecs->event_thread->control.step_stack_frame_id, outer_frame_id)
$5 = false
(gdb)

and the condition was satisfied. On the other hand, for a.elf generated by
my `cc1'

(gdb) p frame_id_eq (get_stack_frame_id (frame), ecs->event_thread->control.step_stack_frame_id)
$3 = false
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
`skip_prologue' break-point hit. Once disabled it
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
$7 = false
(gdb) 


i.e.

frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)

At above expression, there was difference.

For a.elf generated by original `cc1':
(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$7 = {stack_addr = 0x20000, code_addr = 0x1fc, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}

For a.elf generated by my `cc1':
(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$13 = {stack_addr = 0x1fff0, code_addr = 0x210, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

For a.elf generated by original `cc1':
(gdb) p *get_current_frame ()
$9 = {level = 0, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x0, unwind = 0x88938a0 <dwarf2_frame_unwind>, 
  prev_arch = {p = false, arch = 0x0}, prev_pc = {status = CC_UNKNOWN, 
    masked = false, value = 0}, prev_func = {addr = 0, status = CC_UNKNOWN}, 
  this_id = {p = frame_id_status::NOT_COMPUTED, value = {stack_addr = 0, 
      code_addr = 0, special_addr = 0, stack_status = FID_STACK_INVALID, 
      code_addr_p = 0, special_addr_p = 0, artificial_depth = 0}}, 
  base = 0x0, base_cache = 0x0, next = 0x8e94220, prev_p = false, prev = 0x0, 
  stop_reason = UNWIND_NO_REASON, stop_string = 0x0}
(gdb) 

For a.elf generated by my `cc1':
(gdb) p *get_current_frame ()
$14 = {level = 0, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x0, unwind = 0x88938a0 <dwarf2_frame_unwind>, 
  prev_arch = {p = false, arch = 0x0}, prev_pc = {status = CC_UNKNOWN, 
    masked = false, value = 0}, prev_func = {addr = 0, status = CC_UNKNOWN}, 
  this_id = {p = frame_id_status::NOT_COMPUTED, value = {stack_addr = 0, 
      code_addr = 0, special_addr = 0, stack_status = FID_STACK_INVALID, 
      code_addr_p = 0, special_addr_p = 0, artificial_depth = 0}}, 
  base = 0x0, base_cache = 0x0, next = 0x8e94230, prev_p = false, prev = 0x0, 
  stop_reason = UNWIND_NO_REASON, stop_string = 0x0}
(gdb)


For a.elf generated by original `cc1':
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$11 = {stack_addr = 0x20000, code_addr = 0x1fc, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

For a.elf generated by my `cc1':
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$15 = {stack_addr = 0x1fff0, code_addr = 0x0, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

For a.elf generated by original `cc1':
code_addr = 0x1fc

For a.elf generated by my `cc1':
code_addr = 0x0

Here, there was the important difference. Expected value `code_addr'
is 0x210 so that above condition is satisfied, where, 0x1fc is
`main' address of a.elf generated by original `cc1' and 0x210 is
that of my `cc1'.

0x20000 is the value of stack pointer at the start address of `main' and
the value is the same between original `cc1' and my `cc1'.

The frame size of `main' is 16 for both `cc1', and 0x1fff0 = 0x20000 - 16.

For original `cc1':
(gdb) s
skip_artificial_frames (frame=0x8eb3f20) at frame.c:515
(gdb) fin
Run till exit from #0  skip_artificial_frames (frame=0x8eb3f20) at frame.c:515
0x081bc7da in frame_unwind_caller_id (next_frame=<optimized out>) at frame.c:671
Value returned is $12 = (frame_info *) 0x8eb3f20
(gdb) p *$12
$13 = {level = 1, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8eb3f98, unwind = 0x88938a0 <dwarf2_frame_unwind>, 
  prev_arch = {p = true, arch = 0x8e820e8}, prev_pc = {status = CC_UNKNOWN, 
    masked = false, value = 0}, prev_func = {addr = 0, status = CC_UNKNOWN}, 
  this_id = {p = frame_id_status::COMPUTED, value = {stack_addr = 131072, 
      code_addr = 508, special_addr = 0, stack_status = FID_STACK_VALID, 
      code_addr_p = 1, special_addr_p = 0, artificial_depth = 0}}, 
  base = 0x0, base_cache = 0x0, next = 0x8e9429c, prev_p = false, prev = 0x0, 
  stop_reason = UNWIND_NO_REASON, stop_string = 0x0}
(gdb)

For my `cc1':
(gdb) s
skip_artificial_frames (frame=0x8eb55e0) at frame.c:515
(gdb) fin
Run till exit from #0  skip_artificial_frames (frame=0x8eb55e0) at frame.c:515
0x081bc7da in frame_unwind_caller_id (next_frame=<optimized out>) at frame.c:671
Value returned is $17 = (frame_info *) 0x8eb55e0
(gdb) p *$17
$18 = {level = 1, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8eb5658, unwind = 0x88f50e0 <rs6000_frame_unwind>, 
  prev_arch = {p = false, arch = 0x0}, prev_pc = {status = CC_UNKNOWN, 
    masked = false, value = 0}, prev_func = {addr = 0, status = CC_UNKNOWN}, 
  this_id = {p = frame_id_status::COMPUTED, value = {stack_addr = 131056, 
      code_addr = 0, special_addr = 0, stack_status = FID_STACK_VALID, 
      code_addr_p = 1, special_addr_p = 0, artificial_depth = 0}}, 
  base = 0x0, base_cache = 0x0, next = 0x8e942ac, prev_p = false, prev = 0x0, 
  stop_reason = UNWIND_NO_REASON, stop_string = 0x0}
(gdb) c
Continuing.
(gdb)

For original `cc1':
code_addr = 508 = 0x1fc

For my `cc1':
code_addr = 0

So, I investigated the way of `code_addr' member of reeturn value of
`skip_artificial_frames' is set

(gdb) p ((frame_info *) 0x8eb3f20)->this_id.value.code_addr
$15 = 508
(gdb) p &((frame_info *) 0x8eb3f20)->this_id.value.code_addr
$16 = (CORE_ADDR *) 0x8eb3f64
(gdb) watch *(int*) 0x8eb3f64
(gdb) run
...

    (*this_id) = frame_id_build (cache->cfa, get_frame_func (this_frame));

The watch-point hit at above line
(gdb) p/x cache->cfa
$18 = 0x20000
(gdb) 

Then I fixed my `cc1' like below:

For every rtx_ins* insn generated at `expand_prologue'

  RTX_FRAME_RELATED_P(insn) = true;

And confirmed the same thing for a.elf generated by my `cc1'.

(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$22 = {stack_addr = 0x20000, code_addr = 0x210, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) 

`stack_addr' became 0x20000 from 0x1fff0

(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$23 = {stack_addr = 0x1fff0, code_addr = 0x0, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

Not so changed.

00000014 00000028 00000000 FDE cie=00000000 pc=000001c8..00000210
  DW_CFA_advance_loc4: 4 to 000001cc
  DW_CFA_offset: r1 at cfa+0

Above was not correct. Once fixed my `cc1' and became like below:

00000014 00000028 00000000 FDE cie=00000000 pc=000001c8..00000210
  DW_CFA_advance_loc4: 4 to 000001cc
  DW_CFA_offset_extended_sf: r1 at cfa+24
  DW_CFA_def_cfa_offset: 24

Again confimed that:

(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$24 = {stack_addr = 0x20000, code_addr = 0x210, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$25 = {stack_addr = 0x1fff0, code_addr = 0x0, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) 

Not so changed. Not improved.

get_current_frame() returned for my `cc1':

(gdb) p/x *$28
$30 = {level = 0x0, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8e94324, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820f8}, prev_pc = {status = 0x1, masked = 0x0, 
    value = 0x20000000}, prev_func = {addr = 0x0, status = 0x1}, this_id = {
    p = 0x2, value = {stack_addr = 0x1fff0, code_addr = 0x1c8, 
      special_addr = 0x0, stack_status = 0x1, code_addr_p = 0x1, 
      special_addr_p = 0x0, artificial_depth = 0x0}}, base = 0x0, 
  base_cache = 0x0, next = 0x8e94230, prev_p = 0x1, prev = 0x8eb55e0, 
  stop_reason = 0x0, stop_string = 0x0}
(gdb)

stack_addr = 0x1fff0, code_addr = 0x1c8

These were stack pointer value at start address of `f' and start address of `f'.
I thought they were correct.

On the other hand, get_current_frame() returned for original `cc1':


(gdb) p/x *$21
$22 = {level = 0x0, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8e94314, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94220, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

stack_addr = 0x1fff0, code_addr = 0x1c8

OK.
That was, there was the difference about `frame_unwind_caller_id' return value.

Original `cc1'
(gdb) p/x *next_frame
$23 = {level = 0x0, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8e94314, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94220, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

My `cc1'
(gdb) p/x *next_frame
$31 = {level = 0x0, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8e94324, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820f8}, prev_pc = {status = 0x1, masked = 0x0, 
    value = 0x20000000}, prev_func = {addr = 0x0, status = 0x1}, this_id = {
    p = 0x2, value = {stack_addr = 0x1fff0, code_addr = 0x1c8, 
      special_addr = 0x0, stack_status = 0x1, code_addr_p = 0x1, 
      special_addr_p = 0x0, artificial_depth = 0x0}}, base = 0x0, 
  base_cache = 0x0, next = 0x8e94230, prev_p = 0x1, prev = 0x8eb55e0, 
  stop_reason = 0x0, stop_string = 0x0}
(gdb)

There was the difference between

original `cc1' : value = 0x0 

      my `cc1' : value = 0x20000000


Original `cc1':

(gdb) p/x *this
$24 = {level = 0x1, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8eb3f98, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x20000, code_addr = 0x1fc, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e9429c, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

stack_addr = 0x20000, code_addr = 0x1fc
These are the start of `main' address and stack pointer value there.

My `cc1':

(gdb) p/x *this_frame
$32 = {level = 0x1, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8eb5658, unwind = 0x88f50e0, prev_arch = {p = 0x0, 
    arch = 0x0}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x0, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e942ac, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

Above were absolutely unexpected. I annotated the first
`frame_unwind_caller_id' call, so:

(gdb) delete
(gdb) b frame_unwind_caller_id
(gdb) run
...
break-point hit
(gdb)

My `cc1':
(gdb) p/x *next_frame
$32 = {level = 0x0, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8e94314, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94220, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb) n
(gdb) p/x *next_frame
$33 = {level = 0x0, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8e94314, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94220, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb) n
(gdb) n
(gdb) p/x *this_frame
$34 = {level = 0x1, pspace = 0x8e2b858, aspace = 0x8e2bd00, 
  prologue_cache = 0x8eb3f98, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820e8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x20000, code_addr = 0x1fc, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e9429c, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

Original `cc1':
(gdb) p/x *next_frame
$36 = {level = 0x0, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8e94324, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820f8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94230, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb) n
(gdb) p/x *next_frame
$37 = {level = 0x0, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8e94324, unwind = 0x88938a0, prev_arch = {p = 0x1, 
    arch = 0x8e820f8}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x1c8, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e94230, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb) n
(gdb) 
(gdb) p/x *this_frame
$38 = {level = 0x1, pspace = 0x8e2b860, aspace = 0x8e2bd08, 
  prologue_cache = 0x8eb5658, unwind = 0x88f50e0, prev_arch = {p = 0x0, 
    arch = 0x0}, prev_pc = {status = 0x0, masked = 0x0, value = 0x0}, 
  prev_func = {addr = 0x0, status = 0x0}, this_id = {p = 0x2, value = {
      stack_addr = 0x1fff0, code_addr = 0x0, special_addr = 0x0, 
      stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
      artificial_depth = 0x0}}, base = 0x0, base_cache = 0x0, 
  next = 0x8e942ac, prev_p = 0x0, prev = 0x0, stop_reason = 0x0, 
  stop_string = 0x0}
(gdb)

These seemed that there was the difference about `this_frame' calculation.

Original `cc1':
(gdb) p/x this_frame->this_id.value.stack_addr
$41 = 0x20000
(gdb) p &this_frame->this_id.value.stack_addr
$42 = (CORE_ADDR *) 0x8eb3f5c
(gdb) watch *(int*)0x8eb3f5c
Hardware watchpoint 9: *(int*)0x8eb3f5c
(gdb) run
...

static void
dwarf2_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);

  if (cache->unavailable_retaddr)
    (*this_id) = frame_id_build_unavailable_stack (get_frame_func (this_frame));
  else if (cache->undefined_retaddr)
    return;
  else
    (*this_id) = frame_id_build (cache->cfa, get_frame_func (this_frame));
    // Here, set cachec->cfa = 0x20000
}

On the other hand, my `cc1':

(gdb) p/x this_frame->this_id.value.stack_addr
$41 = 0x1fff0
(gdb) p &this_frame->this_id.value.stack_addr
$42 = (CORE_ADDR *) 0x8eb561c
(gdb) watch *(int*)0x8eb561c
Hardware watchpoint 10: *(int*)0x8eb561c
(gdb) run
...
static void
rs6000_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct rs6000_frame_cache *info = rs6000_frame_cache (this_frame,
							this_cache);

  if (!info->base_p)
    {
      (*this_id) = frame_id_build_unavailable_stack (info->pc);
      return;
    }

  /* This marks the outermost frame.  */
  if (info->base == 0)
    return;

  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
  // Set here info->base = 0x1fff0
}


Original `cc1':
(gdb) where
#0  0x08152b02 in dwarf2_frame_this_id (this_frame=0x8eb3f20, this_cache=0x8eb3f2c, this_id=0x8eb3f5c) at dwarf2/frame.c:1233
#1  0x081b9e39 in compute_frame_id (fi=0x8eb3f20) at frame.c:590
#2  0x081ba53d in get_prev_frame_if_no_cycle (this_frame=0x8e9429c) at frame.c:1983
#3  0x081bc6c1 in get_prev_frame_always (this_frame=0x8e9429c) at frame.c:2183
#4  0x081bc7ce in frame_unwind_caller_id (next_frame=<optimized out>) at frame.c:669

My `cc1':

(gdb) where
#0  0x082e0062 in rs6000_frame_this_id (this_frame=0x8eb55e0, this_cache=0x8eb55ec, this_id=0x8eb561c) at rs6000-tdep.c:3633
#1  0x081b9e39 in compute_frame_id (fi=0x8eb55e0) at frame.c:590
#2  0x081ba53d in get_prev_frame_if_no_cycle (this_frame=0x8e942ac) at frame.c:1983
#3  0x081bc6c1 in get_prev_frame_always (this_frame=0x8e942ac) at frame.c:2183
#4  0x081bc7ce in frame_unwind_caller_id (next_frame=<optimized out>) at frame.c:669



      fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);

(gdb) p fi->unwind->this_id

dwarf2_frame_this_id : Original `cc1'

rs6000_frame_this_id : My `cc1'


      /* Find the unwinder.  */
      if (fi->unwind == NULL)
	frame_unwind_find_by_frame (fi, &fi->prologue_cache);  // Here

Above code chosed `fi->unwind' and generated the diffence.


(gdb) info b
Num     Type           Disp Enb Address    What
9       breakpoint     keep y   0x081b9b9a in frame_unwind_caller_id(frame_info*) at frame.c:665
	breakpoint already hit 1 time
13      breakpoint     keep y   0x081b986c in compute_frame_id(frame_info*) at frame.c:585
	breakpoint already hit 1 time
(gdb) run
...
`frame_unwind_caller_id' break-point hit
(gdb) c
...
`frame_unwind_find_by_frame' calling break-point hit
(gdb) s


  for (entry = table->list; entry != NULL; entry = entry->next)
    if (frame_unwind_try_unwinder (this_frame, this_cache, entry->unwinder))
      return;

For original `cc1', above condition was satisfied at 6 times. On the other
hand, for my `cc1' it was satisified at 9 times.

For my `cc1', at 6 times, stepping into `frame_unwind_try_unwinder'

(gdb) s
0x081b852f in frame_unwind_try_unwinder (this_frame=0x8eb65e0, this_cache=0x8eb65ec, unwinder=0x88948c0 <dwarf2_frame_unwind>) at frame-unwind.c:124
(gdb)

and then return 0. And it caused the difference.


  CORE_ADDR block_addr = get_frame_address_in_block (this_frame);

For original `cc1':
(gdb) p/x block_addr
$50 = 0x21b
(gdb) 

For my `cc1'
(gdb) p/x block_addr
$57 = 0x1fffffff
(gdb)

This was obviously storane address, where 0x21b was the address of calling `f'
at`main':

000001fc <main>:
 1fc:	94 21 ff f0 	stwu    r1,-16(r1)
 200:	7c 08 02 a6 	mflr    r0
 204:	90 01 00 14 	stw     r0,20(r1)
 208:	93 e1 00 0c 	stw     r31,12(r1)
 20c:	7c 3f 0b 78 	mr      r31,r1
 210:	38 80 00 06 	li      r4,6
 214:	38 60 00 05 	li      r3,5
 218:	4b ff ff b1 	bl      1c8 <f>       This one
 21c:	7c 69 1b 78 	mr      r9,r3

2022.02.14 18:42
I tried to re-build with:

#define LR_REGNUM 96

But this phenomenon was not changed.

Again:
(gdb) b frame_unwind_caller_id
(gdb) b frame.c:585
(gdb) b dwarf2_frame_sniffer
(gdb) run
...
`dwarf2_frame_sniffer' break-point hit. Once disabled it:
(gdb) disa 3
(gdb) c
...
`frame_unwind_caller_id' break-point hit.
(gdb) c
...
frame.c:585 break-point hit.
(gdb) enable
(gdb) c
...
`dwarf2_frame_sniffer' break-point hit.
(gdb) s


CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  /* A draft address.  */
  CORE_ADDR pc = get_frame_pc (this_frame);

Here, `pc' expected value was 0x23f, but currently, 0x0.

00000210 <main>:
 210:	94 21 ff f0 	stwu    r1,-16(r1)
 214:	7c 08 02 a6 	mflr    r0
 218:	90 01 00 14 	stw     r0,20(r1)
 21c:	93 e1 00 0c 	stw     r31,12(r1)
 220:	7c 3f 0b 78 	mr      r31,r1
 224:	38 80 00 06 	li      r4,6
 228:	38 60 00 05 	li      r3,5
 22c:	4b ff ff 9d 	bl      1c8 <f>        This one
 230:	90 7f 00 08 	stw     r3,8(r31)

Before letting `LR_REGNUM' 96, `get_frame_pc' returned 0x1fffffff.

At above process, it's same if changing `dwarf2_frame_sniffer' to
`dwarf2_frame_prev_register':

(gdb) delete
(gdb) b frame_unwind_caller_id
(gdb) b frame.c:585
(gdb) b dwarf2_frame_prev_register
(gdb) run
...
`dwarf2_frame_prev_register' break-point hit. Once disable it:
(gdb) disa 4
(gdb) c
...
`frame_unwind_caller_id' break-point hit.
(gdb) c
...
frame.c:585 break-point hit.
(gdb) enable
(gdb) c
...
`dwarf2_frame_prev_register' break-point hit.
(gdb)

At `dwarf2_frame_prev_register', variable `cache' was

my `cc1':
(gdb) p/x *cache
$7 = {cfa = 0x1fff0, unavailable_retaddr = 0x0, undefined_retaddr = 0x0, 
  reg = 0x8ebef30, retaddr_reg = {loc = {offset = 0x0, reg = 0x0, exp = {
        start = 0x0, len = 0x0}, fn = 0x0}, how = 0x0}, addr_size = 0x4, 
  per_objfile = 0x8e6fd68, tailcall_cache = 0x0}
(gdb) 

original `cc1':
(gdb) p/x *cache
$7 = {cfa = 0x1fff0, unavailable_retaddr = 0x0, undefined_retaddr = 0x0, 
  reg = 0x8ea6200, retaddr_reg = {loc = {offset = 0x0, reg = 0x0, exp = {
        start = 0x0, len = 0x0}, fn = 0x0}, how = 0x0}, addr_size = 0x4, 
  per_objfile = 0x8e6fd58, tailcall_cache = 0x0}
(gdb)

At this point, no diffence. Then executed below:

    case DWARF2_FRAME_REG_SAVED_REG:
      realnum = dwarf_reg_to_regnum_or_error
	(gdbarch, cache->reg[regnum].loc.reg);
      return frame_unwind_got_register (this_frame, regnum, realnum);

my `cc1'
realnum = 96

original `cc1':
realnum = 67

Here, difference appeared.
And for my `cc1', changed `realnum' to 67 and continued:

f (a=5, b=6) at a.c:5
5	  return a + b;
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

OK. ppc-elf-gdb could skip prologue correctly.

And I investigated below:

      realnum = dwarf_reg_to_regnum_or_error
	(gdbarch, cache->reg[regnum].loc.reg);

original `cc1'
cache->reg[regnum].loc.reg = 108

my `cc1'
cache->reg[regnum].loc.reg = 96

At this point, I noticed that there existed .cfi_xxx pseudo instructions
in `start.S' and they caused .eh_frame section. I deleted them from `start.S'.
Then .eh_frame section was deleted from a.elf generated by my `cc1'.
But the situation was still not changed.

Original `cc1' .eh_frame

00000038 00000024 0000003c FDE cie=00000000 pc=000001fc..00000254
  DW_CFA_advance_loc: 4 to 00000200
  DW_CFA_def_cfa_offset: 16
  DW_CFA_advance_loc: 12 to 0000020c
  DW_CFA_offset_extended_sf: r65 at cfa+4
  DW_CFA_offset: r31 at cfa-4
  DW_CFA_advance_loc: 4 to 00000210
  DW_CFA_def_cfa_register: r31
  DW_CFA_advance_loc: 60 to 0000024c
  DW_CFA_def_cfa: r11 ofs 0
  DW_CFA_advance_loc: 4 to 00000250
  DW_CFA_restore: r31
  DW_CFA_def_cfa_register: r1
  DW_CFA_nop
  DW_CFA_nop
  DW_CFA_nop

My `cc1' .debug_frame

00000040 00000028 00000000 FDE cie=00000000 pc=00000210..00000268
  DW_CFA_advance_loc4: 4 to 00000214
  DW_CFA_offset_extended_sf: r1 at cfa+16  # No corresponding at .eh_frame of original `cc1'
  DW_CFA_def_cfa_offset: 16
  DW_CFA_advance_loc4: 12 to 00000220
  DW_CFA_offset_extended_sf: r96 at cfa+4
  DW_CFA_offset: r31 at cfa-4
  DW_CFA_advance_loc4: 4 to 00000224
  DW_CFA_def_cfa_register: r31
  DW_CFA_nop

Then I tried to delete below:

DW_CFA_offset_extended_sf: r1 at cfa+16

But not changed yet.

static int
rs6000_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
...
      case 108:
        return tdep->ppc_lr_regnum;


Thinking about above code, I tried to investigate the reason why

cache->reg[regnum].loc.reg = 108

at orignal `cc1'.


		if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
		  {
/* This code */	    cache->reg[regnum].loc.reg = fs.retaddr_column;
		    cache->reg[regnum].how = DWARF2_FRAME_REG_SAVED_REG;


On the other hand, my `cc1'

		if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
/* This code */	  cache->reg[regnum] = regs[retaddr_column];

It was tiresome work, letting `LR_REGNUM' 108 not 96 worked well.
