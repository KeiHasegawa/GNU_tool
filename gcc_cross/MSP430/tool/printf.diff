*** gdb-10.2.org/sim/msp430/msp430-sim.c	2021-04-25 13:06:26.000000000 +0900
--- gdb-10.2.msp430-elf/sim/msp430/msp430-sim.c	2022-02-03 16:46:57.000000000 +0900
***************
*** 132,138 ****
    CPU_PC_STORE (MSP430_CPU (sd)) = msp430_pc_store;
    CPU_REG_FETCH (MSP430_CPU (sd)) = msp430_reg_fetch;
    CPU_REG_STORE (MSP430_CPU (sd)) = msp430_reg_store;
! 
    /* Allocate memory if none specified by user.
       Note - these values match the memory regions in the libgloss/msp430/msp430[xl]-sim.ld scripts.  */
    if (sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, &c, 0x2, 1) == 0)
--- 132,138 ----
    CPU_PC_STORE (MSP430_CPU (sd)) = msp430_pc_store;
    CPU_REG_FETCH (MSP430_CPU (sd)) = msp430_reg_fetch;
    CPU_REG_STORE (MSP430_CPU (sd)) = msp430_reg_store;
! #if 0
    /* Allocate memory if none specified by user.
       Note - these values match the memory regions in the libgloss/msp430/msp430[xl]-sim.ld scripts.  */
    if (sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, &c, 0x2, 1) == 0)
***************
*** 145,151 ****
      sim_do_commandf (sd, "memory-region 0x10000,0x80000"); /* HIGH FLASH RAM.  */
    if (sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, &c, 0x90000, 1) == 0)
      sim_do_commandf (sd, "memory-region 0x90000,0x70000"); /* HIGH ROM.  */
! 
    /* Check for/establish the a reference program image.  */
    if (sim_analyze_program (sd,
  			   (STATE_PROG_ARGV (sd) != NULL
--- 145,151 ----
      sim_do_commandf (sd, "memory-region 0x10000,0x80000"); /* HIGH FLASH RAM.  */
    if (sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, &c, 0x90000, 1) == 0)
      sim_do_commandf (sd, "memory-region 0x90000,0x70000"); /* HIGH ROM.  */
! #endif
    /* Check for/establish the a reference program image.  */
    if (sim_analyze_program (sd,
  			   (STATE_PROG_ARGV (sd) != NULL
***************
*** 190,196 ****
    unsigned char resetv[2];
    int c;
    int new_pc;
! 
    /* Set the PC to the default reset vector if available.  */
    c = sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, resetv, 0xfffe, 2);
    new_pc = resetv[0] + 256 * resetv[1];
--- 190,196 ----
    unsigned char resetv[2];
    int c;
    int new_pc;
! #if 0
    /* Set the PC to the default reset vector if available.  */
    c = sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, resetv, 0xfffe, 2);
    new_pc = resetv[0] + 256 * resetv[1];
***************
*** 198,204 ****
    /* If the reset vector isn't initialized, then use the ELF entry.  */
    if (abfd != NULL && !new_pc)
      new_pc = bfd_get_start_address (abfd);
! 
    sim_pc_set (MSP430_CPU (sd), new_pc);
    msp430_pc_store (MSP430_CPU (sd), new_pc);
  
--- 198,207 ----
    /* If the reset vector isn't initialized, then use the ELF entry.  */
    if (abfd != NULL && !new_pc)
      new_pc = bfd_get_start_address (abfd);
! #else
!   assert(abfd);
!   new_pc = bfd_get_start_address (abfd);
! #endif  
    sim_pc_set (MSP430_CPU (sd), new_pc);
    msp430_pc_store (MSP430_CPU (sd), new_pc);
  
***************
*** 217,224 ****
    Get_Byte_Local_Data *ld = (Get_Byte_Local_Data *)vld;
    char buf[1];
    SIM_DESC sd = ld->sd;
! 
    sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, buf, ld->gb_addr, 1);
    ld->gb_addr ++;
    return buf[0];
  }
--- 220,232 ----
    Get_Byte_Local_Data *ld = (Get_Byte_Local_Data *)vld;
    char buf[1];
    SIM_DESC sd = ld->sd;
! #if 0
    sim_core_read_buffer (sd, MSP430_CPU (sd), read_map, buf, ld->gb_addr, 1);
+ #else
+   SIM_CPU* cpu = MSP430_CPU(sd);
+   sim_cia cia = msp430_pc_fetch(cpu);
+   buf[0] = sim_core_read_aligned_1(cpu, cia, read_map, ld->gb_addr);
+ #endif  
    ld->gb_addr ++;
    return buf[0];
  }
***************
*** 678,698 ****
--- 686,718 ----
        switch (opc->size)
  	{
  	case 8:
+ #if 0	  
  	  buf[0] = val;
  	  sim_core_write_buffer (sd, MSP430_CPU (sd), write_map, buf, addr, 1);
+ #else
+ 	  sim_core_write_aligned_1 (MSP430_CPU (sd), MSP430_CPU (sd)->state.regs[0], write_map, addr, val);
+ #endif	  
  	  break;
  	case 16:
+ #if 0
  	  buf[0] = val;
  	  buf[1] = val >> 8;
  	  sim_core_write_buffer (sd, MSP430_CPU (sd), write_map, buf, addr, 2);
+ #else
+ 	  sim_core_write_aligned_2 (MSP430_CPU (sd), MSP430_CPU (sd)->state.regs[0], write_map, addr, val);
+ #endif	  
  	  break;
  	case 20:
  	case 32:
+ #if 0	  
  	  buf[0] = val;
  	  buf[1] = val >> 8;
  	  buf[2] = val >> 16;
  	  buf[3] = val >> 24;
  	  sim_core_write_buffer (sd, MSP430_CPU (sd), write_map, buf, addr, 4);
+ #else
+ 	  sim_core_write_aligned_4 (MSP430_CPU (sd), MSP430_CPU (sd)->state.regs[0], write_map, addr, val);
+ #endif	  
  	  break;
  	default:
  	  assert (! opc->size);
***************
*** 1064,1072 ****
--- 1084,1097 ----
      msp430_cio (sd);
  
    ld.sd = sd;
+  label:  
    ld.gb_addr = PC;
    opsize = msp430_decode_opcode (MSP430_CPU (sd)->state.regs[0],
  				 opcode, msp430_getbyte, &ld);
+   if (opsize < 0) {
+     PC += 2;
+     goto label;
+   }
    PC += opsize;
    if (opsize <= 0)
      {
***************
*** 1494,1496 ****
--- 1519,1716 ----
  	sim_events_process (sd);
      }
  }
+ 
+ static int first_arg(SIM_DESC sd, SIM_CPU *cpu, _Bool refer_stack)
+ {
+   if (refer_stack) {
+     int sp = REG_GET(MSR_SP);
+     return mem_get_val(sd, sp+2, 16);
+   }
+   return REG_GET(12);
+ }
+ 
+ static const char* first_string(SIM_DESC sd, SIM_CPU *cpu, _Bool refer_stack)
+ {
+   uint16_t addr = first_arg(sd, cpu, refer_stack);
+   static char buf[1024];
+   for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i) {
+     char c = mem_get_val(sd, addr+i, 8);
+     buf[i] = c;
+     if (c == '\0')
+       return &buf[0]; // ok
+   }
+ 
+   assert(0 && "not enough buffer");
+   return &buf[0];
+ }
+ 
+ enum arg_class { NONE, WORD, LONG, LONGLONG, DF, LDF, STR };
+ 
+ static const char* get_part(const char* fmt, enum arg_class* how)
+ {
+   for ( ; *fmt ; ++fmt) {
+     char c = *fmt;
+     if (c == 'd' || c == 'i' || c == 'x' || c == 'u') {
+       if (*how == NONE)
+ 	*how = WORD; 
+       return ++fmt;
+     }
+     if (c == 'c') {
+       *how = WORD;
+       return ++fmt;
+     }
+     if (c == 'f') {
+       char prev = *(fmt-1);
+       *how = prev == 'L' ? LDF : DF;
+       return ++fmt;
+     }
+     if (c == 's') {
+       *how = STR;
+       return ++fmt;
+     }
+     if (c == 'l') {
+       if (*how == NONE)
+ 	*how = LONG;
+       else
+ 	*how = LONGLONG;
+     }
+   }
+   assert(0 && "unexpected");
+   return fmt;
+ }
+ 
+ static int arg16(SIM_DESC sd, sim_cpu* cpu, int nth)
+ {
+   assert(nth);
+   int sp = REG_GET(MSR_SP);
+   int addr = sp+2+2*nth;
+   short ret = mem_get_val(sd, addr, 16);
+   return ret;
+ }
+ 
+ static unsigned int arg32(SIM_DESC sd, sim_cpu* cpu, int nth)
+ {
+   assert(nth);
+   int sp = REG_GET(MSR_SP);
+   int addr = sp+2+2*nth;
+   return mem_get_val(sd, addr, 32);
+ }
+ 
+ static unsigned long long arg64(SIM_DESC sd, sim_cpu* cpu, int nth)
+ {
+   assert(nth);
+   int sp = REG_GET(MSR_SP);
+   int addr = sp+2+2*nth;
+   unsigned int a = mem_get_val(sd, addr+0, 32);
+   unsigned long long b = mem_get_val(sd, addr+4, 32);
+   return (b << 32) | a;
+ }
+ 
+ static const char*
+ handle(SIM_DESC sd, SIM_CPU *cpu, const char* fmt, int* nth, int* ret)
+ {
+   char c = *fmt;
+   if (c != '%') {
+     putchar(c);
+     ++*ret;
+     return fmt+1;
+   }
+   const char* beg = fmt;
+   c = *++fmt;
+   if (c == '%') {
+     putchar(c);
+     ++*ret;
+     return fmt+1;
+   }
+   enum arg_class how = NONE;
+   const char* end = get_part(fmt, &how);
+   char part_fmt[256];
+   int n = end - beg;
+   assert(n + 1 < sizeof part_fmt/sizeof part_fmt[0]);
+   strncpy(&part_fmt[0], beg, n);
+   part_fmt[n] = '\0';
+   if (how == WORD) {
+     int arg = arg16(sd, cpu, (*nth)++);
+     *ret += printf(part_fmt, arg);
+     return end;
+   }
+   if (how == LONG) {
+     int arg = arg32(sd, cpu, *nth);
+     *nth += 2;
+     *ret += printf(part_fmt, arg);
+     return end;
+   }
+   if (how == LONGLONG) {
+     unsigned long long arg = arg64(sd, cpu, *nth);
+     *nth += 4;
+     *ret += printf(part_fmt, arg);
+     return end;
+   }
+   if (how == DF || how == LDF) {
+     union {
+       unsigned long long i;
+       double d;
+     } u = { arg64(sd, cpu, *nth) };
+     *nth += 4;
+     if (how == DF)
+       *ret += printf(part_fmt, u.d);
+     else
+       *ret += printf(part_fmt, (long double)u.d);
+     return end;
+   }
+   if (how == STR) {
+     uint16_t addr = arg16(sd, cpu, (*nth)++);
+     char buf[256];
+     for (int i = 0 ; i != sizeof buf/sizeof buf[0] ; ++i) {
+       char c = mem_get_val(sd, addr+i, 8);
+       buf[i] = c;
+       if (c == '\0') {
+ 	*ret += printf(part_fmt, &buf[0]);  // ok
+ 	return end;
+       }
+     }
+     assert(0 && "not enough buffer");
+     return end;
+   }
+   asm("int3");
+   return end;
+ }
+ 
+ void do_printf(void*);
+ void do_printf(void* ptr)
+ {
+   Get_Byte_Local_Data* p = (Get_Byte_Local_Data*)ptr;
+   SIM_DESC sd = p->sd;
+   if (!sd)
+     return;
+   const char* fmt = first_string(sd, MSP430_CPU(sd), TRUE);
+   int argc = 1;
+   int ret = 0;
+   while (*fmt)
+     fmt = handle(sd, MSP430_CPU(sd), fmt, &argc, &ret);
+   REG_PUT(12, ret);
+ }
+ 
+ void do_puts(void*);
+ void do_puts(void* ptr)
+ {
+   Get_Byte_Local_Data* p = (Get_Byte_Local_Data*)ptr;
+   SIM_DESC sd = p->sd;
+   if (!sd)
+     return;
+   const char* fmt = first_string(sd, MSP430_CPU(sd), FALSE);
+   int ret = puts(fmt);
+   REG_PUT(12, ret);
+ }
+ 
+ void do_putchar(void*);
+ void do_putchar(void* ptr)
+ {
+   Get_Byte_Local_Data* p = (Get_Byte_Local_Data*)ptr;
+   SIM_DESC sd = p->sd;
+   if (!sd)
+     return;
+   int arg = first_arg(sd, MSP430_CPU(sd), FALSE);
+   int ret = putchar(arg);
+   REG_PUT(12, ret);
+ }
