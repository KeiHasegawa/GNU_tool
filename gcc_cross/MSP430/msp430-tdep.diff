*** gdb-10.2.org/gdb/msp430-tdep.c	2021-04-25 13:06:26.000000000 +0900
--- gdb-10.2.msp430-elf/gdb/msp430-tdep.c	2022-02-03 17:05:27.000000000 +0900
***************
*** 159,164 ****
--- 159,167 ----
  static struct type *
  msp430_register_type (struct gdbarch *gdbarch, int reg_nr)
  {
+   if (reg_nr == MSP430_SP_RAW_REGNUM || reg_nr == MSP430_SP_REGNUM)
+     return builtin_type (gdbarch)->builtin_data_ptr;
+   
    if (reg_nr < MSP430_NUM_REGS)
      return builtin_type (gdbarch)->builtin_uint32;
    else if (reg_nr == MSP430_PC_REGNUM)
***************
*** 173,178 ****
--- 176,184 ----
  static struct type *
  msp430x_register_type (struct gdbarch *gdbarch, int reg_nr)
  {
+   if (reg_nr == MSP430_SP_RAW_REGNUM || reg_nr == MSP430_SP_REGNUM)
+     return builtin_type (gdbarch)->builtin_data_ptr;
+ 
    if (reg_nr < MSP430_NUM_REGS)
      return builtin_type (gdbarch)->builtin_uint32;
    else if (reg_nr == MSP430_PC_REGNUM)
***************
*** 283,289 ****
  
  struct msp430_get_opcode_byte_handle
  {
!   CORE_ADDR pc;
  };
  
  /* Fetch a byte on behalf of the opcode decoder.  HANDLE contains
--- 289,296 ----
  
  struct msp430_get_opcode_byte_handle
  {
!   void* sd;
!   int pc;
  };
  
  /* Fetch a byte on behalf of the opcode decoder.  HANDLE contains
***************
*** 365,370 ****
--- 372,378 ----
        struct msp430_get_opcode_byte_handle opcode_handle;
        MSP430_Opcode_Decoded opc;
  
+       opcode_handle.sd = 0;
        opcode_handle.pc = pc;
        bytes_read = msp430_decode_opcode (pc, &opc, msp430_get_opcode_byte,
  					 &opcode_handle);
***************
*** 571,578 ****
  
    if (TYPE_LENGTH (valtype) > 8
        || valtype->code () == TYPE_CODE_STRUCT
!       || valtype->code () == TYPE_CODE_UNION)
!     return RETURN_VALUE_STRUCT_CONVENTION;
  
    if (readbuf)
      {
--- 579,592 ----
  
    if (TYPE_LENGTH (valtype) > 8
        || valtype->code () == TYPE_CODE_STRUCT
!       || valtype->code () == TYPE_CODE_UNION) {
!     if (readbuf) {
!       ULONGEST addr;
!       regcache_cooked_read_unsigned (regcache, MSP430_R12_REGNUM, &addr);
!       read_memory(addr, readbuf, TYPE_LENGTH(valtype));
!     }
!     return RETURN_VALUE_ABI_RETURNS_ADDRESS;
!   }
  
    if (readbuf)
      {
***************
*** 635,640 ****
--- 649,675 ----
  }
  
  /* Implement the "push_dummy_call" gdbarch method.  */
+ #include <numeric>
+ 
+ static bool is_aggregate(type_code code)
+ {
+   switch (code) {
+   case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
+     return true;
+   default:
+     return false;
+   }
+ }
+ 
+ static int aggregate_space(int s, value* arg)
+ {
+   auto arg_type = check_typedef (value_type (arg));
+   auto code = arg_type->code();
+   if (!is_aggregate(code))
+     return s;
+   int len = TYPE_LENGTH(arg_type);
+   return s + len;
+ }
  
  static CORE_ADDR
  msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
***************
*** 659,664 ****
--- 694,703 ----
    gdb_assert (func_type->code () == TYPE_CODE_FUNC
  	      || func_type->code () == TYPE_CODE_METHOD);
  
+   CORE_ADDR asp = sp;
+   using namespace std;
+   sp -= accumulate(&args[0], &args[nargs], 0, aggregate_space);
+ 
    /* We make two passes; the first does the stack allocation,
       the second actually stores the arguments.  */
    for (write_pass = 0; write_pass <= 1; write_pass++)
***************
*** 695,702 ****
--- 734,749 ----
  	      || arg_type->code () == TYPE_CODE_UNION)
  	    {
  	      /* Aggregates of any size are passed by reference.  */
+ #if 0	      
  	      store_unsigned_integer (struct_addr_buf, 4, byte_order,
  				      value_address (arg));
+ #else
+ 	      if (write_pass) {
+ 		asp -=  arg_size;
+ 		store_unsigned_integer (struct_addr_buf, 4, byte_order, asp);
+ 		write_memory(asp, arg_bits, arg_size);
+ 	      }
+ #endif	      
  	      arg_bits = struct_addr_buf;
  	      arg_size = (code_model == MSP_LARGE_CODE_MODEL) ? 4 : 2;
  	    }
