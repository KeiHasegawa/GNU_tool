cc1 model

Refer to "AARCH64" => "cc1 model" => "Memo".
In similar way, cc1 model of MSP430 can be built.

Development note from here:

In MSP430 ABI, Arguments to the function which takes variable length argumets
are passed with stack. For below code:

#include <stdio.h>

int f(int a, int b);

int main()
{
  printf("hello world %d\n", f(5, 6));
  return 0;
}

Original cc1 adjusts stack pointer by 4 bytes at main function prologue like
below:

  fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;
                                           (*)
  increment_stack (- fs);

But I decided to implement my `cc1' by using default gcc common character.
There exists push instruction in MSP430 and it's easy to use it.

At this point, hello world 11 can be executed with msp430-elf-run. I noticed
that msp430-elf-gdb could not step into function `f' suitably for this
program compiled with -g option. Here, no rtx_insn* insn generated at
msp430_expand_prologue was added below property:

  RTX_FRAME_RELATED_P(insn) = true;

Then I added above property for every rtx_insn* insn generated at
msp430_expand_prologue. But msp430-elf-gdb still could not step into function.

Original `cc1' generates .debug_frame section like below:

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -2
  Return address column: 0

  DW_CFA_def_cfa: r1 ofs 2
  DW_CFA_offset: r0 at cfa-2
  DW_CFA_nop
  DW_CFA_nop

00000014 00000014 00000000 FDE cie=00000000 pc=00000576..0000058a
  DW_CFA_advance_loc4: 2 to 00000578
  DW_CFA_def_cfa_offset: 6
  DW_CFA_nop

On the other hand, my `cc1' generates .debug_frame section like below:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -2
  Return address column: 17

  DW_CFA_def_cfa: r1 ofs 0
  DW_CFA_offset: r17 at cfa+0

00000012 00000010 00000000 FDE cie=00000000 pc=00140576..0014077a
  DW_CFA_nop
  DW_CFA_def_cfa_offset: 4
  DW_CFA_nop

I was take care of above. But I was also take care of below:

my `cc1':

	.4byte	.LEFDE2-.LASFDE2
.LASFDE2:
	.4byte	.Lframe0
	.2byte	.LFB4                        (*)
	.2byte	.LFE4-.LFB4                  (*)


Original `cc1'

	.4byte	.LEFDE0-.LASFDE0
.LASFDE0:
	.4byte	.Lframe0
	.4byte	.LFB3                        (*)
	.4byte	.LFE3-.LFB3                  (*)

Then I added below declaration:

#define	DWARF2_ADDR_SIZE	4

As this result, msp430-elf-gdb became to be able to step into function,
but still could not display arguments correctly.

I noticed that the break-point of `main' worked well but that of `f' didn't
work well. i.e. the break-ponint of `f' didn't correspond to its source file
location.

For the piece of code:

int f(int a, int b)
{
  return a + b;
}

my `cc1' generated like below:

	.file	"b.c"
	.text
.Ltext0:
	.align	0
	.global	f
	.type	f, @function
f:
.LFB0:
.LM1:
	SUB.W	#4, R1
.LCFI0:
	MOV.W	R12, @R1
	MOV.W	R13, 2(R1)
.LM2:
	MOV.W	@R1, R12
	ADD.W	2(R1), R12
.LM3:
	ADD.W	#4, R1
	RET
.LFE0:
	.size	f, .-f

No pseudo instruction `.loc' was generated. But the reason why the break-point
of `main' worked well  was not obvious.

Anyway I thought I should investigate the reason why the `.loc' was not
generated.

Orignal `cc1' generated `.loc' like below:

$23 = (rtx_insn *) 0xb78774c8
   19: R12:HI=[R1:HI+0x2]
$24 = void
	.loc 1 3 12
	MOV.W	2(R1), R12

And it was generated:

final.c:2646

	    (*debug_hooks->source_line) (last_linenum, last_columnnum,
					 last_filename, last_discriminator,
					 is_stmt);    (*)

The below condition was not satisfied in my `cc1' so that `.loc' was not
generated: 

  if (output_asm_line_debug_info ())     (*)
    {

Then I investigated below code:

  if (dwarf2out_as_loc_support == AUTODETECT_VALUE)
    dwarf2out_as_loc_support
      = dwarf2out_default_as_loc_support ();

Finally, I knew that

#define DWARF2_ASM_LINE_DEBUG_INFO	true

declaration was necessary. I guessed that in MSP430 `cc1'

STACK_POINTER_REGNUM and FRAME_POINTE_REGNUM

were declared as the same value and that's why above declaration was necessary.

Then I confirmed that `.loc's were generated after re-building `cc1'.

And I noticed that in original `cc1':

#define STACK_POINTER_REGNUM		1

#define FRAME_POINTER_REGNUM 		4 /* not usually used, call preserved */

Even if above, there might exist the way to generate code which is normally
generated with `-fomit-frame-pointer' option.

And more, I also noticed that the program which was generated by original `cc1'
with -g option could not be executed with msp430-elf-gdb suitably.

On the other hand,

~/lang/53_GNU_tool/gcc_cross/MSP430/test/test006/test.c

is more simple than hello world 11 program and msp430-elf gdb works well
for this program.

Moreover, compiling

~/lang/53_GNU_tool/gcc_cross/MSP430/tool/sample.c

with -g option and building sample.elf and execute it under control of
msp430-elf-gdb, the same phenomenon occured. i.e. could not step into `f'
but could step into other functions.

Then I modified `a.c' like below:

% cat a.c
#include <stdio.h>

int f(int a, int b)
{
  return a + b;
}

int g(int a,  int b)
{
  return a - b;
}

int main()
{
  g(5, 6);
  printf("hello world %d\n", f(5, 6));
  return 0;
}
%

And compile `a.c' with -g option and execute under control of msp430-elf-gdb
as I have so far.

o break-point of `main' worked well
o could step into `g' and arguments `a' and `b' could be displayed correctly
o where command worked well
o finish command worked well

But at the line of:

  printf("hello world %d\n", f(5, 6));

executing step command caused stepping into `printf' not into `f'.

For my `cc1', I did the same thing. I found that

o could not skip prologue when stepping into `g'
o if could skip prologue, arguments `a' and `b' could be displayed correctly
o where command became like below:

(msp430-elf-gdb) where
#0  g (a=5, b=6) at a.c:10
#1  0x000005aa in main () at a.c:15
Backtrace stopped: frame did not save the PC
(msp430-elf-gdb)

There were some problems at this point. I decided to make a goal
that the program which is compiled with -g option by original `cc1'
can be executed under control of msp430-elf-gdb.

=> msp430-elf-ld had a bug about this stuff. After fixed, the program generated
  by original `cc1' was executed under control of msp430-elf-gdb as I expected.

Then at this point, the program generated by my `cc1' was executed like below:
% ./cc1 -g -quiet a.c
% msp430-elf-as -o a.o a.s
% msp430-elf-ld -o a.elf ~/lang/53_GNU_tool/gcc_cross/MSP430/tool/start.o a.o -T ~/lang/53_GNU_tool/gcc_cross/MSP430/tool/sample.x
% msp430-elf-gdb -q -x gdbcom a.elf
...
Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=1434, b=1310) at a.c:4
4	{
#0  f (a=1434, b=1310) at a.c:4
#1  0x0000059a in main () at a.c:10
Backtrace stopped: frame did not save the PC
hello world 11
%

There were some problems but at first, msp430-elf-gdb could not skip prologue
when stepping into `f'. If it could, arguments `a' and `b' could be displayed
correctly.

From the view point of `msp430-elf-gdb', it could skip `main' prologue
but could not skip `f' prologue.

(gdb) delete
(gdb) b step_command
(gdb) run
...
break-point hit
(gdb) b sim_write
(gdb) c
...
sim_write's break-point hit
(gdb) p/x mem
$8 = 0x58e                      # address of `main'
(gdb) c
Continuing.
f (a=1434, b=1310) at a.c:4
4	{
#0  f (a=1434, b=1310) at a.c:4
#1  0x0000059a in main () at a.c:10
Backtrace stopped: frame did not save the PC

Thread 1 "gdb" hit Breakpoint 3, sim_write (sd=0x8b7ef00, mem=1422, buf=0x86c7221 <msp430_break_insn> "CC", length=2) at ./../common/sim-hrw.c:37
(gdb)

i.e. msp430-elf-gdb did not set break-point at start address of `f'.

After `step_commmand' was called, `sim_resume' and `process_event_stop_test'
were called 3 times. At the 3rd time,

static void
process_event_stop_test (struct execution_control_state *ecs)
{
...
  stop_pc_sal = find_pc_line (ecs->event_thread->suspend.stop_pc, 0);   (*)


(gdb) p/x ecs->event_thread->suspend.stop_pc
$10 = 0x57a
(gdb) n
(gdb) p/x stop_pc_sal
$12 = {pspace = 0x8b306a0, symtab = 0x8b7c4f8, symbol = 0x0, section = 0x0, 
  msymbol = 0x0, line = 0x4, pc = 0x57a, end = 0x584, explicit_pc = 0x0, 
  explicit_line = 0x0, is_stmt = 0x1, prob = 0x0, objfile = 0x0}
(gdb)

0000057a <f>:
 57a:	21 82       	sub	#4,	r1	;r2 As==10

0000057c <.LCFI0>:
 57c:	81 4c 00 00 	mov	r12,	0(r1)	;
 580:	81 4d 02 00 	mov	r13,	2(r1)	;

00000584 <.Loc.5.1>:

I thought `stop_pc_sal.pc' expected value was 0x584.

I compared the msp430-elf-gdb action for the program generated by original
`cc1'  and generated by my `cc1' and finally I found that

  if (!frame_id_eq (get_stack_frame_id (frame),
		    ecs->event_thread->control.step_stack_frame_id)
      && (frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
		       ecs->event_thread->control.step_stack_frame_id)
	  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,
			    outer_frame_id)
	      || (ecs->event_thread->control.step_start_function
		  != find_pc_function (ecs->event_thread->suspend.stop_pc)))))
    {

above condition was statisfied for original `cc1' and not satisfied for my
`cc1'.

For my `cc1',
(gdb) p frame_id_eq (get_stack_frame_id (frame), ecs->event_thread->control.step_stack_frame_id)
$18 = false
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
$19 = false
(gdb) p ecs->event_thread->control.step_start_function
$20 = (symbol *) 0x8b7d184
(gdb) p find_pc_function (ecs->event_thread->suspend.stop_pc)
$21 = (symbol *) 0x8b7d278

On the other hand, for original `cc1'
(gdb) p frame_id_eq (get_stack_frame_id (frame), ecs->event_thread->control.step_stack_frame_id)
$1 = false
(gdb) p frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)
$2 = true
(gdb) p frame_id_eq (ecs->event_thread->control.step_stack_frame_id, outer_frame_id)
$3 = false
(gdb)

i.e.

frame_id_eq (frame_unwind_caller_id (get_current_frame ()), ecs->event_thread->control.step_stack_frame_id)

differs.

For original `cc1':
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$5 = {stack_addr = 0xff00, code_addr = 0x58e, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$6 = {stack_addr = 0xff00, code_addr = 0x58e, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

For my `cc1':
(gdb) p/x frame_unwind_caller_id (get_current_frame ())
$22 = {stack_addr = 0xfefc, code_addr = 0x58e, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb) p/x ecs->event_thread->control.step_stack_frame_id
$23 = {stack_addr = 0xfefe, code_addr = 0x58e, special_addr = 0x0, 
  stack_status = 0x1, code_addr_p = 0x1, special_addr_p = 0x0, 
  artificial_depth = 0x0}
(gdb)

At last, I noticed that at original `cc1' code

#define INCOMING_FRAME_SP_OFFSET		(TARGET_LARGE ? 4 : 2)

I was not sure but add below and tried again:

#define INCOMING_FRAME_SP_OFFSET 2

Finally, msp430-elf-gdb worked well for the program generated my `cc1'.

Refer to "gcc target depend part" => "gcc target depend declarations refered from gcc common part" =>  `INCOMING_FRAME_SP_OFFSET'



