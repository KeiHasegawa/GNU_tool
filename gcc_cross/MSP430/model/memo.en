cc1 model

Refer to "AARCH64" => "cc1 model" => "Memo".
In similar way, cc1 model of MSP430 can be built.

Development note from here:

In MSP430 ABI, Arguments to the function which takes variable length argumets
are passed with stack. For below code:

#include <stdio.h>

int f(int a, int b);

int main()
{
  printf("hello world %d\n", f(5, 6));
  return 0;
}

Original cc1 adjusts stack pointer by 4 bytes at main function prologue like
below:

  fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;
                                           (*)
  increment_stack (- fs);

But I decided to implement my `cc1' by using default gcc common character.
There exists push instruction in MSP430 and it's easy to use it.

At this point, hello world 11 can be executed with msp430-elf-run. I noticed
that msp430-elf-gdb could not step into function `f' suitably for this
program compiled with -g option. Here, no rtx_insn* insn generated at
msp430_expand_prologue was added below property:

  RTX_FRAME_RELATED_P(insn) = true;

Then I added above property for every rtx_insn* insn generated at
msp430_expand_prologue. But msp430-elf-gdb still could not step into function.

Original `cc1' generates .debug_frame section like below:

00000000 00000010 ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -2
  Return address column: 0

  DW_CFA_def_cfa: r1 ofs 2
  DW_CFA_offset: r0 at cfa-2
  DW_CFA_nop
  DW_CFA_nop

00000014 00000014 00000000 FDE cie=00000000 pc=00000576..0000058a
  DW_CFA_advance_loc4: 2 to 00000578
  DW_CFA_def_cfa_offset: 6
  DW_CFA_nop

On the other hand, my `cc1' generates .debug_frame section like below:

00000000 0000000e ffffffff CIE
  Version:               3
  Augmentation:          ""
  Code alignment factor: 1
  Data alignment factor: -2
  Return address column: 17

  DW_CFA_def_cfa: r1 ofs 0
  DW_CFA_offset: r17 at cfa+0

00000012 00000010 00000000 FDE cie=00000000 pc=00140576..0014077a
  DW_CFA_nop
  DW_CFA_def_cfa_offset: 4
  DW_CFA_nop

I was take care of above. But I was also take care of below:

my `cc1':

	.4byte	.LEFDE2-.LASFDE2
.LASFDE2:
	.4byte	.Lframe0
	.2byte	.LFB4                        (*)
	.2byte	.LFE4-.LFB4                  (*)


Original `cc1'

	.4byte	.LEFDE0-.LASFDE0
.LASFDE0:
	.4byte	.Lframe0
	.4byte	.LFB3                        (*)
	.4byte	.LFE3-.LFB3                  (*)

Then I added below declaration:

#define	DWARF2_ADDR_SIZE	4

As this result, msp430-elf-gdb became to be able to step into function,
but still could not display arguments correctly.

I noticed that the break-point of `main' worked well but that of `f' didn't
work well. i.e. the break-ponint of `f' didn't correspond to its source file
location.

For the piece of code:

int f(int a, int b)
{
  return a + b;
}

my `cc1' generated like below:

	.file	"b.c"
	.text
.Ltext0:
	.align	0
	.global	f
	.type	f, @function
f:
.LFB0:
.LM1:
	SUB.W	#4, R1
.LCFI0:
	MOV.W	R12, @R1
	MOV.W	R13, 2(R1)
.LM2:
	MOV.W	@R1, R12
	ADD.W	2(R1), R12
.LM3:
	ADD.W	#4, R1
	RET
.LFE0:
	.size	f, .-f

No pseudo instruction `.loc' was generated. But the reason why the break-point
of `main' worked well  was not obvious.

Anyway I thought I should investigate the reason why the `.loc' was not
generated.

Orignal `cc1' generated `.loc' like below:

$23 = (rtx_insn *) 0xb78774c8
   19: R12:HI=[R1:HI+0x2]
$24 = void
	.loc 1 3 12
	MOV.W	2(R1), R12

And it was generated:

final.c:2646

	    (*debug_hooks->source_line) (last_linenum, last_columnnum,
					 last_filename, last_discriminator,
					 is_stmt);    (*)

The below condition was not satisfied in my `cc1' so that `.loc' was not
generated: 

  if (output_asm_line_debug_info ())     (*)
    {

Then I investigated below code:

  if (dwarf2out_as_loc_support == AUTODETECT_VALUE)
    dwarf2out_as_loc_support
      = dwarf2out_default_as_loc_support ();

Finally, I knew that

#define DWARF2_ASM_LINE_DEBUG_INFO	true

declaration was necessary. I guessed that in MSP430 `cc1'

STACK_POINTER_REGNUM and FRAME_POINTE_REGNUM

were declared as the same value and that's why above declaration was necessary.

Then I confirmed that `.loc's were generated after re-building `cc1'.

And I noticed that in original `cc1':

#define STACK_POINTER_REGNUM		1

#define FRAME_POINTER_REGNUM 		4 /* not usually used, call preserved */

Even if above, there might exist the way to generate code which is normally
generated with `-fomit-frame-pointer' option.

And more, I also noticed that the program which was generated by original `cc1'
with -g option could not be executed with msp430-elf-gdb suitably.

On the other hand,

~/lang/53_GNU_tool/gcc_cross/MSP430/test/test006/test.c

is more simple than hello world 11 program and msp430-elf gdb works well
for this program.

Moreover, compiling

~/lang/53_GNU_tool/gcc_cross/MSP430/tool/sample.c

with -g option and building sample.elf and execute it under control of
msp430-elf-gdb, the same phenomenon occured. i.e. could not step into `f'
but could step into other functions.

Then I modified `a.c' like below:

% cat a.c
#include <stdio.h>

int f(int a, int b)
{
  return a + b;
}

int g(int a,  int b)
{
  return a - b;
}

int main()
{
  g(5, 6);
  printf("hello world %d\n", f(5, 6));
  return 0;
}
%

And compile `a.c' with -g option and execute under control of msp430-elf-gdb
as I have so far.

o break-point of `main' worked well
o could step into `g' and arguments `a' and `b' could be displayed correctly
o where command worked well
o finish command worked well

But at the line of:

  printf("hello world %d\n", f(5, 6));

executing step command caused stepping into `printf' not into `f'.

For my `cc1', I did the same thing. I found that

o could not skip prologue when stepping into `g'
o if could skip prologue, arguments `a' and `b' could be displayed correctly
o where command became like below:

(msp430-elf-gdb) where
#0  g (a=5, b=6) at a.c:10
#1  0x000005aa in main () at a.c:15
Backtrace stopped: frame did not save the PC
(msp430-elf-gdb)

There were some problems at this point. I decided to make a goal
that the program which is compiled with -g option by original `cc1'
can be executed under control of msp430-elf-gdb.
