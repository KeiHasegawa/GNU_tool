"Investigation from a view point objdump" revealed that .text setion
of start.o size was 0x7a but

At 0x500, locating .text section

.text of start.o was located at [0x500, 0x57a)
.text of a.o should have been located at [0x57a, ...)
but it was located at [0x576, ...)

Once more, I confirmed the last address of `memcpy' was 0x576.

After assembling, the start address of `memcpy' of start.o was:

0000002e <memcpy>:
...
00000078 <.Loc.61.1>:
  78:	30 41       	ret			

0x2e, and the last address was 0x7a (=0x78+2)

On the other hand, after linking:

0000052c <memcpy>:
...
00000574 <.Loc.61.1>:
 574:	30 41       	ret			

memcpy was located at [0x500 + 0x2c, 0x500 + 0x76).

i.e. both the start address and the last address was wrong.
So at first, I decided to investigate the reason why the start address of
`memcpy' became 0x52c not 0x52e.

After assembling:
  12:	30 40 00 00 	br	#0x0000		;

After linking:
 512:	fa 3f       	jmp	$-10     	;abs 0x508


i.e. `br' instruction (4 bytes) was replaced to `jmp' instruction (2 bytes)
And that caused this bug. If msp430-elf-ld do this optimization, it has
to update `DW_AT_high_pc' of the .debug_info section:

    <10>   DW_AT_low_pc      : 0x500
    <14>   DW_AT_high_pc     : 0x57a

But it doesn't.

It's troublesome work, so, I tried to make msp430-elf-ld not do this
optimization. But this kind of optimization is done by cr16-elf-ld and
it's not obvious that cr16-el-ld caused the phenomonen described at

~/lang/53_GNU_tool/gcc_cross/CompactRISC/test/test011/MEMO

I'm not sure.

Anyway, at first, I should specify the part of this optimization.
I created the environment for this investigation at below directory:

~/lang/53_GNU_tool/gcc_cross/MSP430/test/test022

.text section of test.o is

31400000 b0120000 03433040 0000
                      ^^^^^^^^^
where, `br' instruction is the 10'th byte. 

(gdb) b section.c:1523
(gdb) run
...
(gdb) p section->name
$13 = 0x8189b48 ".text"
(gdb) p count
$14 = 12
(gdb) x/12bx location
0x8189ae0:	0x31	0x40	0x00	0x10	0xb0	0x12	0x0c	0x05
0x8189ae8:	0x03	0x43	0xfa	0x3f
(gdb)

At this point, the 10'th byte was 0xfa and 11'th was 0x3f. These will be
changed somewhere.


(gdb) p/x ((char*)location)[10]
$15 = 0xfa
(gdb) p &((char*)location)[10]
$16 = 0x8189aea "\372?"
(gdb)

I'll catch the timing of chaning this.

At first, 10'th byte was 0x30, and 0x30 is `br' instruction 1st byte.
And then it was changed from 0x30 to 0x00 not to 0xfa at below code:

		    /* Fix the opcode right way.  */
		    bfd_put_16 (abfd, opcode, contents + irel->r_offset - 2);
		    irel->r_offset -= 2;

		    /* Delete bytes.  */
		    if (!msp430_elf_relax_delete_bytes (abfd, sec,
							irel->r_offset + 2, 2))
		      goto error_return;

And more, it  was changed from 0x00 to 0xfa at below code:

static bfd_reloc_status_type
msp430_final_link_relocate (reloc_howto_type *	   howto,
			    bfd *		   input_bfd,
			    asection *		   input_section,
			    bfd_byte *		   contents,
			    Elf_Internal_Rela *	   rel,
			    bfd_vma		   relocation,
			    struct bfd_link_info * info)
{
...
    case R_MSP430_2X_PCREL:
      ...
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents);
      /* Handle second jump instruction.  */
      x = bfd_get_16 (input_bfd, contents - 2);
      srel += 1;
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents - 2);
      break;

That is, at 1st timing, we should modify .debug_info section.


	/* Try to turn a 16-bit absolute branch into a 10-bit pc-relative
	   branch.  */
	if ((uses_msp430x_relocs (abfd)
	     && ELF32_R_TYPE (irel->r_info) == R_MSP430X_ABS16)
	    || (! uses_msp430x_relocs (abfd)
		&& ELF32_R_TYPE (irel->r_info) == R_MSP430_16))
	  {
...
                  1st timing operation


I felt it was troublesome work, so tried to compile out above.
And then, I confirmed that msp430-elf-ld worked well as I expected.
