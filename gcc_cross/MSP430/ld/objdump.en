Disassemble below file

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf

The result became like below:

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	
0000057a <L0^A>:
 57a:	02 00       	mova	@r0,	r2	;
 57c:	81 4d 00 00 	mov	r13,	0(r1)	;

This is unexpected reuslt. Now I dicided to investigate the reason.
The expected result is:

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	81 4c 02 00 	mov	r12,	2(r1)	;
 57c:	81 4d 00 00 	mov	r13,	0(r1)	;


Simply
(gdb) run -d /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf> a.objdump

like above, the phenomenon is reproduced. It's obvious that the line
information of the file generated by msp430-elf-ld is not correct, but
I investigated from a view point of msp430-elf-objdump.

Disassmeble was done at below function:

static void
disassemble_bytes (struct disassemble_info * inf,
		   disassembler_ftype        disassemble_fn,
		   bfd_boolean               insns,
		   bfd_byte *                data,
		   bfd_vma                   start_offset,
		   bfd_vma                   stop_offset,
		   bfd_vma		     rel_offset,
		   arelent ***               relppp,
		   arelent **                relppend)
{

This function was called for each label.

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	
0000057a <L0^A>:

I guessed that the label located at 0x57a caused this phenomenon. And
the [0x578, 0x57c) object code are: 

81 4c 02 00

and these are correct.

A label is displayed at below code:

	  pinfo->fprintf_func (pinfo->stream, "\n");
	  objdump_print_addr_with_sym (abfd, section, sym, addr,
				       pinfo, FALSE);
	  pinfo->fprintf_func (pinfo->stream, ":\n");

The label located at 0x57a can be confirmed like below:
(gdb) b objdump.c:3295
(gdb) command
>if (addr!=0x57a)
 >c
 >end
>end
(gdb) c

I'll try to investigate the reason of locating label at 0x57a.

static void
disassemble_section (bfd *abfd, asection *section, void *inf)
{
...
  while (addr_offset < stop_offset)
    {
...
      addr = section->vma + addr_offset;
...

Now I want to catch the timing of addr=0x57a.

b objdump.c:3193
command
if (addr!=0x57a)
c
end
end

OK, come here.

(gdb) p *sym
$5 = {the_bfd = 0x81aca08, name = 0x81b427d "L0\001", value = 122, flags = 1, 
  section = 0x81aec94, udata = {p = 0x0, i = 0}}
(gdb)

L0^A may be there.

`sym' is calculated at below code:

  sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,
                                             (struct disassemble_info *) inf,
                                             &place);


(gdb) p sym
$6 = (asymbol *) 0x81b64c4
(gdb)

b objdump.c:3166
command
if (sym!=0x81b64c4)
c
end
end

Above gdb command cannot catch the timing I want to catch.
So try to catch previous timing:

b objdump.c:3193
command
if (addr!=0x578)
c
end
end

OK, I could catch.

(gdb) b objdump.c:3166
(gdb) c
...
I noticed that the msp430-elf-objdump did not work as I expected:

  while (addr_offset < stop_offset)
    {
...
      addr = section->vma + addr_offset;
...
      // `sym' might be updated in this loop

    }


	    nextsym = sorted_syms[place];

So now, 

(gdb) p *nextsym
$10 = {the_bfd = 0x81aaa08, name = 0x81b227d "L0\001", value = 122, 
  flags = 1, section = 0x81acc94, udata = {p = 0x0, i = 0}}
(gdb)

the result became like above:

(gdb) p *sorted_syms[58]
$13 = {the_bfd = 0x81aaa08, name = 0x81b227d "L0\001", value = 122, 
  flags = 1, section = 0x81acc94, udata = {p = 0x0, i = 0}}
(gdb) p sorted_syms[58]
$14 = (asymbol *) 0x81b44c4
(gdb)

I tried to catch the timing of above updated:

      for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
	{
	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));

	  sym->symbol.the_bfd = abfd;
	  sym->symbol.name = bfd_elf_sym_name (abfd, hdr, isym, NULL);
	  sym->symbol.value = isym->st_value;

That was above code.

(gdb) n
(gdb) n
(gdb) p *sym
$16 = {symbol = {the_bfd = 0x81aaa08, name = 0x81b227d "L0\001", value = 0, 
    flags = 0, section = 0x0, udata = {p = 0x0, i = 0}}, internal_elf_sym = {
    st_value = 1402, st_size = 0, st_name = 373, st_info = 0 '\000', 
    st_other = 0 '\000', st_target_internal = 0 '\000', st_shndx = 1}, 
  tc_data = {hppa_arg_reloc = 0, mips_extr = 0x0, any = 0x0}, version = 0}
(gdb) 


(gdb) p/x *isym
$18 = {st_value = 0x57a, st_size = 0x0, st_name = 0x175, st_info = 0x0, 
  st_other = 0x0, st_target_internal = 0x0, st_shndx = 0x1}
(gdb) p/x isym->st_value
$23 = 0x57a
(gdb) p &isym->st_value
$24 = (bfd_vma *) 0x81b3778
(gdb) 

Again I tried to catch the timing above updated:

bfd_boolean
elf_swap_symbol_in (bfd *abfd,
		    const void *psrc,
		    const void *pshn,
		    Elf_Internal_Sym *dst)
{
...
  if (signed_vma)
    dst->st_value = H_GET_SIGNED_WORD (abfd, src->st_value);
  else
    dst->st_value = H_GET_WORD (abfd, src->st_value);  // This one

(gdb) p/x src->st_value
$26 = {0x7a, 0x5, 0x0, 0x0}
(gdb) p/x src->st_value[0]
$27 = 0x7a
(gdb) p &src->st_value[0]
$28 = (unsigned char *) 0x81b3114 "z\005"
(gdb) 

And again I tried to catch the timing above updated:

      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
				      NULL, NULL, NULL);         // This one


  nread = abfd->iovec->bread (abfd, ptr, size);  // This one

(gdb) p size
$44 = 1424
(gdb) x/1424bx ptr
...
0x81b3110:	0x75	0x01	0x00	0x00	0x7a	0x05	0x00	0x00



(gdb) p ptr
$45 = (void *) 0x81b2dd0
(gdb) p 0x81b3110 - 0x81b2dd0
$46 = 832
(gdb) p/x *((char*)ptr+832+4)
$47 = 0x7a
(gdb) 

This was caused becase 836 th byte became 0x7a in some section.

% msp430-elf-objdump -s /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf > a.objdump 


Contents of section .debug_info:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00050000 7a050000 00000000 08000000  ....z...........
               ^^^^

This might be the reason.

% msp430-elf-objdump -g /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf > a.objdump 

  Compilation Unit @ offset 0x0:
   Length:        0x22 (32-bit)
   Version:       2
   Abbrev Offset: 0x0
   Pointer Size:  4
 <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x500
    <14>   DW_AT_high_pc     : 0x57a            # This one
    <18>   DW_AT_name        : (indirect string, offset: 0x0): start.S
    <1c>   DW_AT_comp_dir    : (indirect string, offset: 0x8): /home/khasegawa/lang/53_GNU_tool/gcc_cross/MSP430/tool

0x57a is wrong. The expected value is 0x576, which implies that 4 is added 
not suitably.

% msp430-elf-objdump -g ~/lang/53_GNU_tool/gcc_cross/MSP430/tool/start.o > start.o.objdump 

.debug_info セクションの内容(/home/khasegawa/lang/53_GNU_tool/gcc_cross/MSP430/tool/start.o より読み込んだもの):

  Compilation Unit @ offset 0x0:
   Length:        0x22 (32-bit)
   Version:       2
   Abbrev Offset: 0x0
   Pointer Size:  4
 <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x0
    <14>   DW_AT_high_pc     : 0x7a

At first, I thought this was caused by msp430-elf-ld, but from above result
it might be cause by msp430-elf-as.

% msp430-elf-objdump -d ~/lang/53_GNU_tool/gcc_cross/MSP430/tool/start.o > start.o.objdump 


00000076 <.Loc.60.1>:
  76:	31 52       	add	#8,	r1	;r2 As==11

00000078 <.Loc.61.1>:
  78:	30 41       	ret			

But now, it was not.

.text section of start.o size is 0x7a, so 0x57a is correct.

It's not correct that start address of `f' becomes 0x576. In other words,
.text section address of `a.o' should not be 0x576. It should be 0x57a.


