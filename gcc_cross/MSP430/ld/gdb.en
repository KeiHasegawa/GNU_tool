/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf

For above program, msp430-elf-gdb executes it, cannot step into `f'. Now
I started to investigate the reason.

The result of execution became like below:
Breakpoint 1 at 0x58c: file a.c, line 10.

Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
hello world 11
printf () at start.S:20
20		RET
#0  printf () at start.S:20
#1  0x000005a6 in main () at a.c:10
main () at a.c:11
11	  return 0;

It's not easy to understand, but it showed that msp430-elf-gdb could not
step into `f' and stopped at `printf'.
It was expected that msp430-elf-gdb skipped the prologue of `f'

	SUB.W	#4, R1
.LCFI0:
	; end of prologue
	MOV.W	R12, 2(R1)
	MOV.W	R13, @R1

and stopped here.

And more, I noticed that the result of msp430-elf-objdump was not expected:


00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	
0000057a <L0^A>:
 57a:	02 00       	mova	@r0,	r2	; (*) not expected!
 57c:	81 4d 00 00 	mov	r13,	0(r1)	;

00000580 <.Loc.5.1>:
 580:	1c 41 02 00 	mov	2(r1),	r12	;
 584:	2c 51       	add	@r1,	r12	;

According to above result, expected stop address becomes 0x580.

(msp430-elf-gdb) b f
Breakpoint 2 at 0x578
(msp430-elf-gdb)

At first, stop address is 0x578, not 0x580. And break-point of `f' is not
correspoind to `a.c:5'.

On the other hand, if we specifiy directly 0x580 like below:

(msp430-elf-gdb) b *0x580
Breakpoint 1 at 0x580: file a.c, line 5.   # correspoind to `a.c:5'!
(msp430-elf-gdb) run
Starting program: /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/a.elf 

Breakpoint 1, f (a=5, b=6) at a.c:5
(msp430-elf-gdb)

This implies that it's possible to fix if msp430-elf-gdb skip prologue
correctly.

(gdb) b msp430_skip_prologue
(gdb) run
...
static CORE_ADDR
msp430_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
...
  /* Try to find the extent of the function that contains PC.  */
  if (!find_pc_partial_function (pc, &name, &func_addr, &func_end))
    return pc;

  msp430_analyze_prologue (gdbarch, pc, func_end, &p);
  return p.prologue_end;       // return here 0x578 !
}

Here, I remembered I fixed for msp430-elf-gcc -g option code generation
like below:

      opcode_handle.sd = 0;
      opcode_handle.pc = pc;

and I thought it was the reason of this phenomenon. Onece, I reverted
the fix but if I set break-point of `f', the address became 0x578, not 0x580.

Then I noticed that:

int f(int a, int b)
{
  return a + b;
}

int g(int a, int b)
{
  return a - b;
}

int main()
{
  g(5, 6);
  return 0;
}

When stopping `main', msp430-elf-gdb could step into `g' and `where' and
`finish' commands worked well. But when stopping `g', could not step into
`f'.

I thought that msp430-elf-gdb could skip prologue of `g' but colud not skip
prologue of `f' suitably.

The results of msp430-elf-objdump becomes like below:

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	
0000057a <L0^A>:
 57a:	02 00       	mova	@r0,	r2	;  (*) NG
 57c:	81 4d 00 00 	mov	r13,	0(r1)	;

...
0000058a <g>:
 58a:	21 82       	sub	#4,	r1	;r2 As==10

0000058c <.LCFI1>:
 58c:	81 4c 02 00 	mov	r12,	2(r1)	;  (*) OK as I expect
 590:	81 4d 00 00 	mov	r13,	0(r1)	;

On the other hand, disassemble command of msp430-elf-gdb became like below:

Dump of assembler code for function f:
   0x00000576 <+0>:	sub	#4,	r1	;r2 As==10
   0x00000578 <+2>:	mov	r12,	2(r1)	;  (*) OK. but ???
   0x0000057c <+6>:	mov	r13,	0(r1)	;
   0x00000580 <+10>:	mov	2(r1),	r12	;
   0x00000584 <+14>:	add	@r1,	r12	;
   0x00000586 <+16>:	add	#4,	r1	;r2 As==10
   0x00000588 <+18>:	ret			
End of assembler dump.
Dump of assembler code for function g:
   0x0000058a <+0>:	sub	#4,	r1	;r2 As==10
   0x0000058c <+2>:	mov	r12,	2(r1)	;   (*) OK. of cause.
   0x00000590 <+6>:	mov	r13,	0(r1)	;
   0x00000594 <+10>:	mov	2(r1),	r12	;
   0x00000598 <+14>:	sub	@r1,	r12	;
   0x0000059a <+16>:	add	#4,	r1	;r2 As==10
   0x0000059c <+18>:	ret			
End of assembler dump.

When setting break-point of `g', I mistook that msp430_skip_prologue() return
value was 0x594, but actually it was 0x58c.

So this meant that there did not exist difference between the way of
skipping prologue `f' and that of `g'.

msp430-tdep.c:

      else if (opc.id == MSO_mov
	       && opc.op[0].type == MSP430_Operand_Immediate
	       && 12 <= opc.op[0].reg && opc.op[0].reg <= 15)
	after_last_frame_setup_insn = next_pc;

This correct version becomes like below:

      else if (opc.id == MSO_mov
	       && opc.op[0].type == MSP430_Operand_Indirect
	       && opc.op[0].reg == MSR_SP
	       && 12 <= opc.op[1].reg && opc.op[1].reg <= 15)
	after_last_frame_setup_insn = next_pc;


By this fix, when setting break-point `f', the prologue of `f' can be
skipped correctly and its address is corresponds to source file suitably.

But, msp430-elf-gdb still could not step into `f' from `main'.

(gdb) b step_command
(gdb) run
...
`step_command' break-point is hit
(gdb) b sim_resume
(gdb) c
...
Thread 1 "gdb" hit Breakpoint 3, sim_resume (sd=0x8b915f8, step=1, siggnal=0) at ./../common/sim-resume.c:41
(gdb)

I was sure that this debugged program came to the start of `f' 0x576.

(gdb) info b
Num     Type           Disp Enb Address    What
5       breakpoint     keep y   0x083a46de msp430-sim.c:1073
	breakpoint already hit 3 times
        if (opcode_pc!=0x576)
          c
        end
(gdb) c
...
Above break-point is hit
(gdb) up
(gdb) up

#2  0x083a678e in sim_resume (sd=0x8b915f8, step=0, siggnal=0) at ./../common/sim-resume.c:89
                                            ^^^^^^^
(gdb)

Unexpectedly, step = 0.

0000059e <main>:
 59e:	7d 40 06 00 	mov.b	#6,	r13	;
 5a2:	7c 40 05 00 	mov.b	#5,	r12	;
 5a6:	b0 12 76 05 	call	#1398		;#0x0576

The expected result is that sim_resume(step=1) call continues at least 4 times.

(gdb) info b
Num     Type           Disp Enb Address    What
2       breakpoint     keep y   0x081e7ea0 in step_command(char const*, int) at infcmd.c:793
	breakpoint already hit 1 time
6       breakpoint     keep y   0x0839f720 in sim_stop_reason at ./../common/sim-reason.c:31
	breakpoint already hit 3 times
8       breakpoint     keep y   0x083a46de in msp430_step_once at msp430-sim.c:1073
	breakpoint already hit 3 times
9       breakpoint     keep y   0x083a6620 in sim_resume at ./../common/sim-resume.c:41
	breakpoint already hit 4 times
(gdb) disable        # once disable all
(gdb) enable 2       # enable only step_command break-point
(gdb) run
...
`step_command' break-point is hit
(gdb) enablel        # enable all break-point again
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 9, sim_resume (sd=0x8b915f8, step=1, siggnal=0) at ./../common/sim-resume.c:41
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 8, msp430_step_once (sd=0x8b915f8) at msp430-sim.c:1073
(gdb) p/x opcode_pc
$21 = 0x59e
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 6, sim_stop_reason (sd=0x8b915f8, reason=0xbfffec54, sigrc=0xbfffec50) at ./../common/sim-reason.c:31
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 9, sim_resume (sd=0x8b915f8, step=1, siggnal=0) at ./../common/sim-resume.c:41
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 8, msp430_step_once (sd=0x8b915f8) at msp430-sim.c:1073
(gdb) p/x opcode_pc
$22 = 0x5a2
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 6, sim_stop_reason (sd=0x8b915f8, reason=0xbfffec54, sigrc=0xbfffec50) at ./../common/sim-reason.c:31
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 9, sim_resume (sd=0x8b915f8, step=1, siggnal=0) at ./../common/sim-resume.c:41
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 8, msp430_step_once (sd=0x8b915f8) at msp430-sim.c:1073
(gdb) p/x opcode_pc
$23 = 0x5a6
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 6, sim_stop_reason (sd=0x8b915f8, reason=0xbfffec54, sigrc=0xbfffec50) at ./../common/sim-reason.c:31
(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 9, sim_resume (sd=0x8b915f8, step=0, siggnal=0) at ./../common/sim-resume.c:41
# Here called with step=0
(gdb) c
(gdb) p/x opcode_pc
$24 = 0x576
(gdb) 

0000059e <main>:
 59e:	7d 40 06 00 	mov.b	#6,	r13	;
 5a2:	7c 40 05 00 	mov.b	#5,	r12	;
 5a6:	b0 12 76 05 	call	#1398		;#0x0576

i.e. These 3 instructions are executed by calling sim_resume(step=1), but

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

This instruction is executed by calling sim_resume(step=0).

sim_resume() argument `step' is set like below:

void
gdbsim_target::resume_one_inferior (inferior *inf, bool step,
				    gdb_signal siggnal)
{
  struct sim_inferior_data *sim_data
    = get_sim_inferior_data (inf, SIM_INSTANCE_NOT_NEEDED);

  if (sim_data)
    {
      sim_data->resume_siggnal = siggnal;
      sim_data->resume_step = step;              (*)

I tried to investigate the reason this function was called with step = false.

static void
resume_1 (enum gdb_signal sig)
{
...
  int step;
...
  step = currently_stepping (tp);   // (*1)
...
  else if (step)
    step = maybe_software_singlestep (gdbarch, pc);  // (*2)

  do_target_resume (resume_ptid, step, sig);  // called from here

I decided to confrim the way of calculating this `step'.

(gdb) delete
(gdb) b step_command
(gdb) run
...
`step_command' break-point is hit
(gdb) b resume_1
(gdb) c
...
`resume_1' break-point is hit

1st time : At above (*1), `step' became 1, at above (*2), `step' became 1.
2nd time : Same with the 1st time
3rd time : Same with the 1st time
4th time : At above (*1), `step' became 0, and (*2) was not executed.

I confirmed for below `g' not for below `f' because msp430-elf-gdb could
step into `g':

int f(int a, int b)
{
  return a + b;
}

int g(int a, int b)
{
  return a - b;
}

int main()
{
  g(5, 6);
  return 0;
}

Now I noticed that the way of calling `sim_resume' is the same between
`f' and `g'. i.e. At 4th time, sim_resume was called with `step=0'.

It was correct that:
  o At 1st, 2nd and 3rd time, sim_resum(step=1) is called
  o At 4th time, sim_resume(step=0) is called

But at 4th time, internal break-point was set before sim_resume(step=0) call.

For `f', it was set to

  return 0;

On the other hand, for `g', it was set to the address where `g' prologue was
skipped.

The difference appeared as the motion of msp430-elf-gdb.

(gdb) info b
Num     Type           Disp Enb Address    What
12      breakpoint     keep y   0x081e7ea0 in step_command(char const*, int) at infcmd.c:793
	breakpoint already hit 1 time
13      breakpoint     keep y   0x081f2289 in resume_1(gdb_signal) at infrun.c:2260
	breakpoint already hit 5 times
(gdb) dele 13     # Just `step_command' break-point available
(gdb) run
...
`step_command' break-point is hit
(gdb) b sim_write

(gdb) c
Continuing.

Thread 1 "gdb" hit Breakpoint 14, sim_write (sd=0x8b915f8, mem=1438, buf=0x86c7221 <msp430_break_insn> "CC", length=2) at ./../common/sim-hrw.c:37
(gdb) p/x mem
$45 = 0x59e
(gdb)

For `g', internal break-point is set to 0x59e, which is `main' address.

Thread 1 "gdb" hit Breakpoint 14, sim_write (sd=0x8b915f8, mem=1428, buf=0x86c7221 <msp430_break_insn> "CC", length=2) at ./../common/sim-hrw.c:37
(gdb) p/x mem
$46 = 0x594
(gdb)

For `g', 2nd internal break-point was set to 0x594, which is `g' prologue
skipped address.

So, I did the same thign for `f':

For `f', 1st internal break-point was 0x59e, which is `main' address. And
2nd internal break-point was set to 0x5aa, which is the adress of:

  return 0;

So I decided to investigate the reason why 2nd internal break-point was set to
0x5aa.

static void
insert_breakpoint_locations (void)
{
...
  ALL_BP_LOCATIONS (bl, blp_tmp)
    {
...



(gdb) p/x bl->target_info.reqstd_address
$59 = 0x5aa
(gdb) p &bl->target_info.reqstd_address
$60 = (CORE_ADDR *) 0x8b98280
(gdb) watch *(int*)0x8b98280
(gdb) run
...


static int
insert_bp_location (struct bp_location *bl,
		    struct ui_file *tmp_error_stream,
		    int *disabled_breaks,
		    int *hw_breakpoint_error,
		    int *hw_bp_error_explained_already)
{
...
  bl->target_info.reqstd_address = bl->address;


The internal break-point was set here. And more,

static struct bp_location *
add_location_to_breakpoint (struct breakpoint *b,
			    const struct symtab_and_line *sal)
{
...
  loc->requested_address = sal->pc;

That was set here, and more

static void
insert_step_resume_breakpoint_at_caller (struct frame_info *next_frame)
{
...
  symtab_and_line sr_sal;
  sr_sal.pc = gdbarch_addr_bits_remove (gdbarch,
					frame_unwind_caller_pc (next_frame));
  sr_sal.section = find_pc_overlay (sr_sal.pc);
  sr_sal.pspace = frame_unwind_program_space (next_frame);

  insert_step_resume_breakpoint_at_sal (gdbarch, sr_sal,
					frame_unwind_caller_id (next_frame));
}

That was calculated like above. I did the same thign for `g',
and I noticed that `insert_step_resume_breakpoint_at_caller' was not
called for `g'.


	    if (execution_direction == EXEC_REVERSE)
	      handle_step_into_function_backward (gdbarch, ecs);
	    else
	      handle_step_into_function (gdbarch, ecs);   (*)
	    return;

i.e. for `g', msp430-elf-gdb stepped into `g'. But for `f', msp430-elf-gdb
did not step into `f'. The reason was:


static void
process_event_stop_test (struct execution_control_state *ecs)
{
...
      {
	struct symtab_and_line tmp_sal;

	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
(*)	if (tmp_sal.line != 0
	    && !function_name_is_marked_for_skip (ecs->stop_func_name,
						  tmp_sal)
	    && !inline_frame_is_marked_for_skip (true, ecs->event_thread))
	  {
	    if (execution_direction == EXEC_REVERSE)
	      handle_step_into_function_backward (gdbarch, ecs);
	    else
	      handle_step_into_function (gdbarch, ecs);
	    return;
	  }
      }

Above if-statement condition satisfied in case of `g' and did not satisfy
in case of `f'. So I investigated the reason why the condition did not
satisfy in case of `f'.

In case of `f', tmp_sal.line = 0.

struct symtab_and_line
find_pc_line (CORE_ADDR pc, int notcurrent)  was called with pc = 0x576 
{

0x576 is start address of `f'

Here, c.objdump became like below:

  Entry	Dir	Time	Size	Name
  1	0	0	0	start.S
...
  [0x00000108]  Advance PC by fixed size amount 2 to 0x576
  [0x0000010b]  Extended opcode 1: End of Sequence

Is this accidental coincidence?

% msp430-elf-addr2line -a 0x576 -e c.elf
0x00000576
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/c.c:2
%

msp430-elf-addr2line told that 0x576 was correspond to c.c:2.
But msp430-elf-gdb judged that 0x576 was not correspond to any source file.

struct symtab_and_line
find_pc_sect_line (CORE_ADDR pc, struct obj_section *section, int notcurrent)
{
...
  for (symtab *iter_s : compunit_filetabs (cust))
    {
      /* Find the best line in this symtab.  */
      l = SYMTAB_LINETABLE (iter_s);
...

I remembered that I had seen above source and at that time, the same kind
phenomenon occurred.

For `g':

(gdb) p/x *first
$99 = {line = 0x2, is_stmt = 0x1, pc = 0x576}    # Thish is the start address of `f'
(gdb) p/x *(first+1)
$100 = {line = 0x3, is_stmt = 0x1, pc = 0x580}   # This is the prologue skip address of `f'
(gdb)

For `f':

(gdb) p/x *first
$101 = {line = 0x3, is_stmt = 0x1, pc = 0x500}
(gdb) p/x *(first+1)
$102 = {line = 0x4, is_stmt = 0x1, pc = 0x504}
(gdb)

for `f', msp430-elf-gdb searched line information from `start.S', as not
expected.

  for (symtab *iter_s : compunit_filetabs (cust))
    {
      /* Find the best line in this symtab.  */
      l = SYMTAB_LINETABLE (iter_s);

For `g':
(gdb) p *iter_s
$106 = {next = 0x0, compunit_symtab = 0x8b7e490, linetable = 0x8b7f07c, 
  filename = 0x8b8c680 "c.c", language = language_c, 
  fullname = 0x8bb0890 "/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.msp430-elf/host-i686-pc-linux-gnu/gcc/c.c"}
(gdb)

For `f':
(gdb) p *iter_s
$105 = {next = 0x0, compunit_symtab = 0x8b7f1ac, linetable = 0x8bb86f0, 
  filename = 0x8b8c68c "start.S", language = language_asm, fullname = 0x0}
(gdb)

i.e. there was the diffrence with the way of calculating `cust' for `f' and
that of `g'.

  cust = find_pc_sect_compunit_symtab (pc, section);

For `f'
(gdb) p cust
$108 = (compunit_symtab *) 0x8b7f1ac
(gdb)

For `g'
(gdb) p cust
$109 = (compunit_symtab *) 0x8b7e490
(gdb)

For `f', I set `cust' 0x8b7e490 from msp430-elf-gdb but the result became
like below:

(gdb) c
Continuing.
0x00000576 in f ()
A debugging session is active.

	Inferior 1 [process 42000] will be killed.

Quit anyway? (y or n) [answered Y; input not from terminal]
[Thread 0xb6f32b70 (LWP 32428) exited]
[Thre

So if the way of `cust' is fixed, this bug may not be fixed.
Anyway `cust' value is not correct.

	  if (BLOCK_START (b) <= pc
	      && BLOCK_END (b) > pc
	      && (distance == 0
		  || BLOCK_END (b) - BLOCK_START (b) < distance))
	    {

(gdb) p/x *b
$122 = {startaddr = 0x500, endaddr = 0x57a, function = 0x0, superblock = 0x0, 
  multidict = 0x8b7f264, namespace_info = 0x8b7f26c, ranges = 0x0}
(gdb) 

0x500 is `start' label address.
0x57a is `sub instruction + 2' address at `f'.

00000576 <f>:
 576:	21 82       	sub	#4,	r1	;r2 As==10

00000578 <.LCFI0>:
 578:	
0000057a <L0^A>:
 57a:	02 00       	mova	@r0,	r2	;
 57c:	81 4d 00 00 	mov	r13,	0(r1)	;

This is the phenomenon that msp430-elf-objdump result became unexpected.
Anyway, above condition is satisfied because

0x500 <= 0x576 < 0x57a

% msp430-elf-objdump -d -g -x c.o > c.o.objdump

The part of c.o.objdump:

00000000 <f>:
   0:	21 82       	sub	#4,	r1	;r2 As==10

00000002 <.LCFI0>:
   2:	81 4c 02 00 	mov	r12,	2(r1)	;
   6:	81 4d 00 00 	mov	r13,	0(r1)	;

This is expected. Now I think this bug is cased by msp430-elf-ld.

