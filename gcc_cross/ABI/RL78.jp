RL78 の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long, long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数


(*1) 函数呼び出し

	call	!!func

	疑似コード

	sp -= 4
	memory[sp|0xf0000] = (call 命令の次のアドレス);
	pc = func

	但し 0xf0000 - 0xf1000 の領域はアクセスできないので, sp が 0x1000 以下
	だと期待通り動作しない.

(*2) 函数復帰

	ret

	疑似コード

	pc = memory[sp|0xf0000]
	sp += 4

(*3) プロローグ

	subw	sp, #128

	上は 128 バイトの領域を使用する函数のプロローグ.


(*4) エピローグ

	addw	sp, #128
	ret

	上は 128 バイトの領域を使用する函数のエピローグ.
	sp を復元し, 呼び出し元に復帰する.

(*5) 通常の函数の引数と戻り値

        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 2
	...

	のようにスタックを使用する.
	函数の戻り値は x レジスタに値がセットされる.

(*6) long, long long を引数にとる函数, 返す函数

	sizeof(long) = 4
	sizeof(long long) = 8

	long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 4
	...

	のようにスタックを使用する.
	函数の戻り値は 2 バイトずつ r12, r14 を使用する. r12, r14 はメモリマップドレジス
	タでそれぞれのアドレスは以下:

	r12	=	0xffef4
	r14	=	0xffef6

	long long に対しては
        第 1 引数は sp 相対 0
	第 2 引数は sp 相対 8
	...

	のようにスタックを使用する.
	函数の戻り値は 4 バイトずつ r8, r12 レジスタにセットされる. やはりメモリマップドレジ
	スタでそれぞれのアドレスは以下:

	r8	=	0xffef0
	r12	=	0xffef4

	別の言い方をすれば r8, r10, r12, r14 を 2 バイトずつ使用するとも言える.

(*7) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = sizeof(double) = 4
	sizeof(long double) = 8

	RL78 には FPU がないので浮動少数点演算はソフトウェアで行なう.

	float, double に対しては (*5) の規則が適用される.
	long double に対しては (*6) の規則が適用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数に取る函数を呼び出すときスタックに構造体がコピーされて呼び出される.
	構造体を返す函数を呼び出すと結果がアドレス 0xffef0 にセットされる. このアドレス
	はメモリマップドレジスタ r8 のアドレスである.
