AVR の ABI

(*0) 命令用メモリとデータ用メモリ, メモリマップドレジスタ, スタックポインタ
(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long, long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数


(*0) 命令用メモリとデータ用メモリ, メモリマップドレジスタ, スタックポインタ

        「AVR プログラミング」を参照.

(*1) 函数呼び出し

	rcall func

	疑似コード

	memory[sp-1] = (rcall 命令の次のアドレス)
	sp -= 2;
	pc = func

	メモリに書き込んでからスタックポインタをずらすらしい. スタック
	ポンイタが微妙なところを指しているが上は誤記ではない. シミュレ
	ータでは復帰アドレスを 2 で割ったものをビッグエンディアン形
	式で書き込んでいた. このプロセッサ自体はリトルエンディアン.
	おそらく pc の保持のしかたがシミュレータで間違えているのだが,
	辻褄は合っているし

	(avr-elf-gdb) info register

	で本来の pc の値を表示しているので, 作成した人は知っていてやっ
	ているか, あるいはそういう仕様なのかもしれない.

(*2) 函数復帰

	ret

	疑似コード

	sp += 2;
	pc = memory[sp-1]

(*3) プロローグ

	push r28
	push r29
	in r28,__SP_L__
	in r29,__SP_H__
	subi r28,-128
	sbc r29,__zero_reg__
	in __tmp_reg__,__SREG__
	cli
	out __SP_H__,r29
	out __SREG__,__tmp_reg__
	out __SP_L__,r28

	上は 128 バイトのローカルエリアを使用する函数のプロローグ.

        +---------------------+ <- sp_{new}
        |                     |
        |                     |	
        |     local area      |
        |                     |
        |                     |
        +---------------------+
	|         r29         |
        +---------------------+ <- sp_{old}
	|         r28         |
        +---------------------+
	|    reurn            |
        +---------------------+
	|          address    |	
        +---------------------+

(*4) エピローグ

	subi r28,-128
	sbci r29,-1
	in __tmp_reg__,__SREG__
	cli
	out __SP_H__,r29
	out __SREG__,__tmp_reg__
	out __SP_L__,r28
	pop r29
	pop r28
	ret

	上は 128 バイトのローカルエリアを使用する函数のエピローグ.
	スタックポインタが復元され, r29, r28 が復元され呼び出し元に復
	帰する.

(*5) 通常の函数の引数と戻り値

	sizeof(int) = 2

	第 1 引数 : r24, r25
	第 2 引数 : r22, r23
	第 3 引数 : r20, r21
	第 4 引数 : r18, r19
	第 5 引数 : r16, r17
	第 6 引数以降 : スタックを使用する.

	int f(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7);

	f(0x1234, 0x5678, 0x9abc, 0xdef0, 0x1122, 0x3344, 0x5566, 0x7788);

	r25 = 0x12, r24 = 0x34
	r23 = 0x56, r22 = 0x78
	r21 = 0x9a, r20 = 0xbc
	r19 = 0xde, r18 = 0xf0
	r17 = 0x11, r16 = 0x22

        +---------------------+ <- sp
	|                     |
        +---------------------+
	|    reurn            |
        +---------------------+
	|          address    |	
        +---------------------+
	|    *************    |	
        +---------------------+
	|    *************    |
        +---------------------+	
	|    *************    |	
        +---------------------+
	|    *************    |	
        +---------------------+
	|         0x44        |	
        +---------------------+
	|         0x33        |	
        +---------------------+
	|         0x66        |	
        +---------------------+
	|         0x55        |	
        +---------------------+
	|         0x88        |	
        +---------------------+
	|         0x77        |	
        +---------------------+


(*6) long, long long を引数にとる函数, 返す函数

        sizeof(long) = 4
        sizeof(long long) = 8

	long にはレジスタが 4 つ使用され, long long にはレジスタが 8
	つ使用される.

	long f(long a0, long a1, long a2, long a3);

	f(0x12345678L, 0x9abcdef0L, 0x11223344L, 0x55667788L);

	に対して `f' の先頭アドレスでは (*5) と同じ状況になっている.
	同様に

	long long f(long long a0, long long a1);
	
	f(0x123456789abcdef0L, 0x1122334455667788L);

	に対して `f' の先頭アドレスではやはり (*5) と同じ状況になっている.

(*7) 浮動少数点数を引数にとる函数, 返す函数

	sizeof(float) = 4
	sizeof(double) = sizeoof(long double) = 8
	
        AVR には FPU がないので浮動少数点数演算はソフトウェアによって
        行なわれる.

	float に対しては (*5) と同じ. double, long double に対しては
	(*6) と同じ.

	libgcc.a のビルドの問題で int への変換や加算のコードを書くとラ
	ンタイムライブラリのエラーを引き起こす.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数にとる函数を呼び出すとき, レジスタは使用されずに, スタックにコピー 
	される.

	例えば

	struct S { int i[4]; };
	void f(struct S);
	
	struct S s = { 0x1234	0x5678	0x9abc	0xdef0 };
	f(s);

	に対して f の先頭アドレスでは

        +---------------------+ <- sp
	|                     |
        +---------------------+
	|    reurn            |
        +---------------------+
	|          address    |	
        +---------------------+
	|         0x34        |	
        +---------------------+
	|         0x12        |	
        +---------------------+
	|         0x78        |	
        +---------------------+
	|         0x56        |	
        +---------------------+
	|         0xbc        |	
        +---------------------+
	|         0x9a        |
        +---------------------+
	|         0xf0        |
        +---------------------+
	|         0xde        |
        +---------------------+

	のようになっている.

	構造体を返す函数は戻り値をセットする領域を Y レジスタ (r28, r29)にセッ
	トして函数を呼び出す.
