Motorola 68000 ABI

(*1) Function call
(*2) Return from function
(*3) Prologue
(*4) Epilogue
(*5) Normal argument and return value
(*6) `long' and `long long' argument and return value
(*7) Floating point number argument and return value
(*8) Structure argument and return value


(*1) Function call

	bsr	func

	Pseudo code

	memory[sp-1] = (`bsr' instruction next address)
	sp -= 2	
	pc = func

(*2) Return from function

	rts

	Pseudo code

	sp += 2
	pc = memory[sp-1]
	

(*3) Prologue

				Pseudo code
				
	ldx	*_.frame	x = _.frame
	pshx			memory[sp-1] = x
				sp -= 2
	tsx			x = sp + 1
	xgdx			x <-> d
	addd	#-128		d -= 128
	xgdx			x <-> d
	txs			sp = x - 1
	sts	*_.frame	_.frame = sp

	Above is prologue for function which uses 128 bytes local area.

	+------------------+ 
	|     sp_{new}     | _.frame
	+------------------+ 
        ~                  ~
        ~                  ~
	+------------------+ <- sp_{new}
	|                  |
	|                  |
	|    local area    |
	|                  |
	|                  |
	+------------------+ +129 
	|   _.frame_{old}  | <- sp_{old}
	+------------------+ +131
	|  return address  |
	+------------------+ +133


(*4) Epilogue
				Pseudo code
				
	tsy			y = sp + 1
	xgdy			y <-> d
	addd	#128		d += 128
	xgdy			y <-> d
	tys			sp = y - 1
	puly			sp += 2
				y = memory[sp-1]
	sty	*_.frame	_.frame = y
	rts

	Above is epilogue for function which uses 128 bytes local area.
	`_.frame' and `sp' are recovered and return to callee.
	
(*5) Normal argument and return value

        sizeof(int) = 4

	1st : `d' register
	2nd : use stack

	For example

	int f(int a0, int a1, int a2, int a3);

	f(10, 11, 12, 13);

	At the start address of `f', `d' register and stack layout become
	like below:

	d = 10

	+------------------+ -1
	|                  | <- sp
	+------------------+ +1
	|  return address  |
	+------------------+ +3
	|                  |
	|        11        |
	+------------------+ +7
	|                  |
	|        12        |
	+------------------+ +11
	|                  |
	|        13        |
	+------------------+ +15

        Function return value is set to `d' register.

(*6) `long' and `long long' argument and return value

        When calling function which takes `long long' type argument,
	stack is used.
	When calling function which returns `long long' type, the address
	for the return value is set to `d' register.
	For example,

	long long f(int a0, long long a1);

	f(10, 0x123456789abcdef0LL);

	At the start address of `f', `d' register and stack layout become
	like below

	d = (the address for the return value)

	+------------------+ -1
	|                  | <- sp
	+------------------+ +1
	|  return address  |
	+------------------+ +3
	|                  |
	|        10        |
	+------------------+ +7
	|                  |
	|    0x12345678    |
	+------------------+ +11
	|                  |
	|    0x9abcdef0    |
	+------------------+ +15

(*7) Floating point number argument and return value

        sizeof(float) = 4
	sizeof(double) = sizeof(long double) = 8

        Motorola 68000 doesn't have FPU so software calculates floating point
	number operation. For `float', 1st argument is set to `X' and `Y'
	register, and for the rest of the argument, stack is used.
	Function return value is set to `X' and `Y' register.

	For `double' or `long double' argument, stack is used.
	When calling  function which returns `double' or `long double' type,
	the address for the return value is set to `d' register.

(*8) Structure argument and return value

	When calling function which takes structure type, stack is used.
	When calling function which returns structure type, the address for
	the return value is set to `d' register.
