SH の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) 浮動少数点数を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*1) 函数呼び出し

        jsr @r1

	疑似コード

	pr = (jsr 命令の次の命令のアドレス)
	pc = r1

	pr レジスタがリンクレジスタの役割りをしている.

(*2) 函数復帰

	rts

	疑似コード

	pc = pr

(*3) プロローグ

	mov.l	r14,@-r15
	sts.l	pr,@-r15
	add	#-128,r15
	mov	r15,r14

	上は 128 バイトのローカルエリアを必要とする函数のプロローグのコード

        +-----------------+ <- r15_{new}, r14_{new}
	|                 |
	|                 |
	|  local area     |
	|                 |
	|                 |
	+-----------------+ <- r14 はここじゃない
	|     pr_{old}    |
	+-----------------+
	|     r14_{old}   |
	+-----------------+ <- r15_{old}

	上だと r14 と r15 が同じアドレスを指すことになり r14 を使う意味がないように
	も思えるがそこはコンパイラの勝手ということでスルーする.

(*4) エピローグ

	add	#64,r14
	add	#64,r14
	mov	r14,r15
	lds.l	@r15+,pr
	mov.l	@r15+,r14
	rts

	上は 128 バイトの領域を必要とする函数のエピローグで r14 を 128 加算してから
	r15 にその値をセットしていることで r15 の値を復元する準備をしている.
	だったらプロローグで r15 と同じアドレスにしなければ良かったように思えるがそこは
	コンパイラの勝手なのでスルーする.

	いずれにしてもこれで r14, r15, pr を復元できて rts により呼び出し元にプログラ
	ムの制御が移る.
	
(*5) 通常の函数の引数と戻り値

        第 1 引数 : r4
        第 2 引数 : r5
        第 3 引数 : r6
        第 4 引数 : r7
	第 5 引数以降 : スタックを使用する.

	例えば

	int f(int a0, int a1, int a2, int a3, int a4, int a5);

	f(10, 11, 12, 13, 14, 15);

	に対して f の先頭にきたとき

	r4 = 10, r5 = 11, r6 = 12, r7 = 13

	+-----------------+ <- r15
	|        14       |
	+-----------------+ +4
	|        15       |
	+-----------------+ +8

	のようになっている. 函数の戻り値は r0 にセットされる.

(*6) long long を引数にとる函数, 返す函数

        sizeof(long long) = 8

	引数として函数に渡すとき r4, ..., r7 をペアで使用する. レジスタで足りない
	場合はスタックが使用される.

	f(int a, long long b, long long c);

	f(10, 11L, 12L);

	に対して f の先頭にきたとき

	r4 = 10, r5 = 0, r6 = 11, r7 = 0 

	+-----------------+ <- r15
	|        12       |
	+-----------------+ +4

	のようになっている. 函数の戻り値は r0 と r1 にセットされる.


(*7) 浮動少数点数を引数にとる函数, 返す函数

        sizeof(float) = 4
        sizeof(double) = 8
	sizeof(long double) = 8

	SH は FPU がないのでソフトウェアで浮動少数点演算を行なっている.
	float に対しては (*5) と同様. double, long double に対しては
	(*6) と同様.

	SH2/SH3/SH4 は型番によって FPU があるらしい.

	float に対しては fr4, fr5, ..., fr11 が使用され残りはスタックが使用される.
	戻り値は fr0 が使用される.
	
	double に対しては dr4, dr6, dr8, dr10 が使用され残りはスタックが使用される.
	戻り値は dr0 が使用される.

(*8) 構造体を引数にとる函数, 構造体を返す函数

        構造体を引数とする函数を呼び出すとき, 先頭 16 バイトが r4, ..., r7
	で渡され残りはスタックを使用する.

	例えば

	struct S {
	  int i[6];
	};

	void f(struct S s);

	struct S s = { 10, 11, 12, 13, 14, 15 };
	f(s);

	に対して f の先頭では

	r4 = 10, r5 = 11, r6 = 12, r7 = 13

	+-----------------+ <- r15
	|        14       |
	+-----------------+ +4
	|        15       |
	+-----------------+ +8

	のようになっている.

	構造体を返す函数に対しては戻り値を格納するアドレスを r4 にセットして呼び出す.

備考:

	sh-elf-gcc -o a.s -S a.c -m2a
	sh-elf-as -o a.o a.s --isa=sh2a

のように使用するらしい.
