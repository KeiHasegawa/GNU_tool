H8 の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) float, double を返す函数
(*7) 構造体を引数にとる函数, 構造体を返す函数

(*1) 函数呼び出し

	jsr func

	疑似コード

	r7 -= 2;
	memory[r7] = (jsr 命令の次のアドレス);
	pc = func;

	r7 レジスタがスタックポインタの役割りをしている.	
	戻りアドレスをプッシュしてジャンプするということ.

(*2) 函数復帰

	rts

	疑似コード

	pc = memory[r7];
	r7 += 2;

	戻りアドレスをポップしてジャンプするということ.

(*3) プロローグ

	mov.w	r6,@-r7
	mov.w	r7,r6
	mov.w	#-128,r3
	add.w	r3,r7

	fp は r6 のこと. 上はローカル変数に 128 バイト必要なケース.


         +----------------+ <- r7_{new}
         |                |
         |                |
         | local variable |   
         |                |
         |                |
         +----------------+ <- r6_{new}
         |     r6_{old}   |
         +----------------+ <- r7_{old}
         | return address |
         +----------------+ 

(*4) エピローグ

	mov.w	#128,r3
	add.w	r3,r7
	mov.w	@r7+,r6
	rts

	上はローカル変数に 128 バイト必要だったケース.

(*5) 通常の函数の引数と戻り値

     第 1 引数 : r0
     第 2 引数 : r1
     第 3 引数 : r2
     第 4 引数以降 : スタックに積む

     戻り値 : r0

     以下は int f(int a, int b, int c, int d, int e); を

     f(5, 6, 7, 8, 9);

     のように呼び出したときのコード:

	mov.w	#9,r2
	mov.w	r2,@-r7
	mov.w	#8,r2
	mov.w	r2,@-r7
	mov.w	#7,r2
	mov.w	#6,r1
	mov.w	#5,r0
	jsr	@_f
	adds	#2,r7
	adds	#2,r7

     f の先頭アドレスでのスタック

         +----------------+ <- sp
         | return address |
         +----------------+ 
         |       8        |
         +----------------+ 
         |       9        |
         +----------------+ 

(*6) float, double を返す函数

     r0, r1, r2, r3 を使用する.

     ランタイムライブラリの中で  int -> float の変換で illegal instruction で
     エラーしている. しかしこれはまた別の問題.

(*7) 構造体を引数にとる函数, 構造体を返す函数
