H8 の ABI

(*1) 函数呼び出し
(*2) 函数復帰
(*3) プロローグ
(*4) エピローグ
(*5) 通常の函数の引数と戻り値
(*6) long long を引数にとる函数, 返す函数
(*7) float, double を引数にとる函数, 返す函数
(*8) 構造体を引数にとる函数, 構造体を返す函数

(*1) 函数呼び出し

	jsr func

	疑似コード

	r7 -= 2;
	memory[r7] = (jsr 命令の次のアドレス);
	pc = func;

	r7 レジスタがスタックポインタの役割りをしている.	
	戻りアドレスをプッシュしてジャンプするということ.

(*2) 函数復帰

	rts

	疑似コード

	pc = memory[r7];
	r7 += 2;

	戻りアドレスをポップしてジャンプするということ.

(*3) プロローグ

	mov.w	r6,@-r7
	mov.w	r7,r6
	mov.w	#-128,r3
	add.w	r3,r7

	fp は r6 のこと. 上はローカル変数に 128 バイト必要なケース.


         +----------------+ <- r7_{new}
         |                |
         |                |
         | local variable |   
         |                |
         |                |
         +----------------+ <- r6_{new}
         |     r6_{old}   |
         +----------------+ <- r7_{old}
         | return address |
         +----------------+ 

(*4) エピローグ

	mov.w	#128,r3
	add.w	r3,r7
	mov.w	@r7+,r6
	rts

	上はローカル変数に 128 バイト必要だったケース.

(*5) 通常の函数の引数と戻り値

     第 1 引数 : r0
     第 2 引数 : r1
     第 3 引数 : r2
     第 4 引数以降 : スタックに積む

     戻り値 : r0

     以下は int f(int a, int b, int c, int d, int e); を

     f(5, 6, 7, 8, 9);

     のように呼び出したときのコード:

	mov.w	#9,r2
	mov.w	r2,@-r7
	mov.w	#8,r2
	mov.w	r2,@-r7
	mov.w	#7,r2
	mov.w	#6,r1
	mov.w	#5,r0
	jsr	@_f
	adds	#2,r7
	adds	#2,r7

     f の先頭アドレスでのスタック

         +----------------+ <- sp
         | return address |
         +----------------+ 
         |       8        |
         +----------------+ 
         |       9        |
         +----------------+

(*6) long long を引数にとる函数, 返す函数

     sizeof(long long) = 8

     第 1 引数でも必ずスタック渡しをする. 以下は

     void f(long long a); を

     f(0x123456789abcdef0LL);

     のように呼び出したときの f の先頭でのスタックの様子.

         +----------------+ <- sp
         | return address |
         +----------------+ 
         |    0x1234      |
         +----------------+ 
         |    0x5678      |
         +----------------+
         |    0x9abc      |
         +----------------+
         |    0xdef0      |
         +----------------+

     long long を返す函数を呼び出すとき, 戻り値を格納するアドレスを r0 に
     セットする. 従って第 1 引数は r0 ではなくて r1 にセットされる.
      
(*7) float, double を引数にとる函数, 返す函数

     H8 には浮動少数点ユニットがないのでソフトウェアで計算している.
     
     sizeof(float) = sizeof(double) = 4

     としている. 第 1 引数が double ならば r0, r1 レジスタに浮動少数点をセット
     し, 第 2 引数が double ならばスタックに値を積む. 

     double f(double a, double b)
     {
       return a + b;
     }

     のような f を f(1.0, 0.5); のように呼び出したとき f の先頭では

     r0 = 0x3f80 r1 = 0x0000

     でありスタックは

         +----------------+ <- sp
         | return address |
         +----------------+ 
         |    0x3f00      |
         +----------------+ 
         |    0x0000      |
         +----------------+

     のようになっている.

     戻り値は r0, r1 にセットされる.

     ランタイムライブラリの中で  int -> float の変換で illegal instruction で
     エラーしている. しかしこれはまた別の問題.

(*8) 構造体を引数にとる函数, 構造体を返す函数

     引数に構造体をとる函数は long long と同じようにスタックを使用する.
     戻り値の型が構造体の函数は long long と同じように r0 に戻り値を格納する
     アドレスを r0 にセットする.
     