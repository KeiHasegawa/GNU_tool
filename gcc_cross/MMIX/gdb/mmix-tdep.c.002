#include "defs.h"
#include "value.h"
#include "arch-utils.h"
#include "regcache.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "dis-asm.h"
#include "dwarf2/frame.h"
#include "frame-base.h"
#include "frame-unwind.h"

#include <cassert>
#include <utility>

static int mmix_register_sim_regno(gdbarch* arch, int regnum)
{
  return regnum;
}

char gpr_names[256][5];
constexpr int n_gpr = sizeof gpr_names/sizeof gpr_names[0];

const char* spr_names[] = {
    "rB", "rD", "rE", "rH", "rJ",  "rM",  "rR",  "rBB",
    "rC", "rN", "rO", "rS", "rI",  "rT",  "rTT", "rK",
    "rQ", "rU", "rV", "rG", "rL",  "rA",  "rF",  "rP",
    "rW", "rX", "rY", "rZ", "rWW", "rXX", "rYY", "rZZ"
};

constexpr int n_spr = sizeof spr_names/sizeof spr_names[0];

constexpr int fp_regno = 253;
constexpr int sp_regno = 254;
constexpr int rj_regno = n_gpr + 4;

static int mmix_dbg_reg_to_regnum(gdbarch* arch, int regnum)
{
  switch (regnum) {
  case 29: return fp_regno;
  case 30: return sp_regno;
  case 35: return rj_regno;
  default: return regnum;
  }
}

struct name_reg {
  name_reg()
  {
    for (int i = 0 ; i != n_gpr ; ++i)
      sprintf(gpr_names[i], "r%d", i);
  }
} name_reg;

constexpr int pc_regno = n_gpr + n_spr;

static const char* mmix_register_name(gdbarch* arch, int regno)
{
  if (regno == pc_regno)
    return "pc";
  if (regno == sp_regno)
    return "sp";
  if (regno == fp_regno)
    return "fp";

  if (regno < n_gpr)
    return gpr_names[regno];

  int n = regno - n_gpr;
  if (n < n_spr)
    return spr_names[n];

  return nullptr;
}

static bool is_aggregate(type_code code)
{
  switch (code) {
  case TYPE_CODE_STRUCT: case TYPE_CODE_UNION: case TYPE_CODE_ARRAY:
    return true;
  default:
    return false;
  }
}

static void
mmix_extract_return_value(type* valtype, regcache* regs, gdb_byte *valbuf)
{
  ULONGEST tmp;
  regcache_cooked_read_unsigned(regs, 1, &tmp);
  int len = TYPE_LENGTH(valtype);
  assert(len <= 8);
  store_unsigned_integer(valbuf, len, BFD_ENDIAN_BIG, tmp);
}

static return_value_convention
mmix_return_value(gdbarch* arch, value* function, type* valtype, regcache* rc,
		  gdb_byte* readbuf, const gdb_byte* writebuf)
{
  auto code = valtype->code();
  if (is_aggregate(code)) {
    if (readbuf) {
      ULONGEST g0;
      regcache_raw_read_unsigned(rc, 16, &g0);
      read_memory(g0, readbuf, TYPE_LENGTH(valtype));
    }
    return RETURN_VALUE_ABI_RETURNS_ADDRESS;
  }

  assert(!writebuf);

  if (readbuf)
    mmix_extract_return_value(valtype, rc, readbuf);
  
  return RETURN_VALUE_REGISTER_CONVENTION;
}

static type* mmix_register_type(struct gdbarch* arch, int regno)
{
  switch (regno) {
  case pc_regno: case rj_regno:
    return builtin_type(arch)->builtin_func_ptr;
  case sp_regno: case fp_regno:
    return builtin_type(arch)->builtin_data_ptr;
  default:
    return builtin_type(arch)->builtin_int64;
  }
}

static void
mmix_print_registers_info(gdbarch* arch, ui_file* file,
			  frame_info* frame, int regno, int cpregs)
{
  asm("int3");
}

static CORE_ADDR
mmix_skip_prologue(gdbarch* arch, CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  if (!find_pc_partial_function(pc, nullptr, &func_addr, &func_end))
    return pc;
  
  symtab_and_line sal = find_pc_line(func_addr, 0);
  if (sal.end && sal.end < func_end)
    return sal.end;

  return pc;
}

static struct frame_base mmix_frame_base = {
};

struct mmix_frame {
  bool available;
  CORE_ADDR prologue_start;
  CORE_ADDR prev_sp;
  int size;
  mmix_frame(frame_info* frame)
  {
    available = false;
    prologue_start = -1;
    prev_sp = get_frame_sp(frame);
    size = 0;
  }
};

inline void update(uint32_t insn, mmix_frame* frame)
{
}

static mmix_frame* mmix_create_frame(frame_info* frame)
{
  using namespace std;
  mmix_frame* ret = new mmix_frame(frame);
  CORE_ADDR pc = get_frame_pc(frame);
  auto block_addr = get_frame_address_in_block(frame);
  CORE_ADDR func_end;
  bool found = find_pc_partial_function(block_addr, nullptr,
					&ret->prologue_start, &func_end);
  if (!found) {
    ret->available = false;
    ret->prologue_start = pc;
    return ret;
  }

  symtab_and_line sal = find_pc_line(ret->prologue_start, 0);
  auto end = sal.end ? min(pc, sal.end) : pc;
  ret->available = true;
  for (auto addr = ret->prologue_start; addr != end ; addr += 4) {
    ULONGEST insn;
    if (!safe_read_memory_unsigned_integer(addr, 4, BFD_ENDIAN_BIG, &insn))
      return ret;
    update(insn, ret);
  }
  return ret;
}

static void
mmix_frame_this_id(frame_info* frame, void** ptr, frame_id* id)
{
  auto pf  = reinterpret_cast<mmix_frame*>(*ptr);
  if (!pf)
    *ptr = pf = mmix_create_frame(frame);

  if (!pf->available)
    *id = frame_id_build_unavailable_stack(pf->prologue_start);
  else
    *id = frame_id_build(pf->prev_sp, pf->prologue_start);
}

static value*
mmix_frame_prev_register(frame_info* frame, void** ptr, int regno)
{
  if (regno == pc_regno) {
    auto pc = get_frame_pc(frame);
    return frame_unwind_got_constant(frame, regno, pc);
  }

  if (regno == sp_regno) {
    auto sp = get_frame_sp(frame);
    return frame_unwind_got_constant(frame, regno, sp);
  }

  asm("int3");  
  return 0;
}

static frame_unwind mmix_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mmix_frame_this_id,
  mmix_frame_prev_register,
  nullptr,
  default_frame_sniffer
};

static int mmix_kind_from_pc(gdbarch* arch, CORE_ADDR* addr)
{
  return 0;
}

static const unsigned char* mmix_from_kind(gdbarch* arch, int kind, int* size)
{
  static unsigned char bkpt[] = { 0xba, 0xdb, 0xee, 0xf0 };
  *size = sizeof bkpt;
  return &bkpt[0];
}

static CORE_ADDR
mmix_push_dummy_call(gdbarch* arch, value* function,
		     regcache *rc, CORE_ADDR bp_addr,
		     int nargs, value** args, CORE_ADDR sp,
		     function_call_return_method rm,
		     CORE_ADDR struct_addr)
{
  asm("int3");
  return 0;
}

static gdbarch*
mmix_gdbarch_init(gdbarch_info info, gdbarch_list *arches)
{
  gdbarch* arch = gdbarch_alloc (&info, 0);

  set_gdbarch_num_regs(arch, pc_regno+1);
  set_gdbarch_register_type(arch, mmix_register_type);
  set_gdbarch_register_sim_regno(arch, mmix_register_sim_regno);
  set_gdbarch_dwarf2_reg_to_regnum(arch, mmix_dbg_reg_to_regnum);
  set_gdbarch_stab_reg_to_regnum(arch, mmix_dbg_reg_to_regnum);
  set_gdbarch_register_name(arch, mmix_register_name);

  set_gdbarch_pc_regnum(arch, pc_regno);
  set_gdbarch_sp_regnum(arch, sp_regno);
  set_gdbarch_print_registers_info(arch, mmix_print_registers_info);

  set_gdbarch_ptr_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_addr_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_return_value(arch, mmix_return_value);

  set_gdbarch_skip_prologue (arch, mmix_skip_prologue);
  frame_base_set_default (arch, &mmix_frame_base);
  dwarf2_append_unwinders(arch);
  frame_unwind_append_unwinder(arch, &mmix_frame_unwind);

  set_gdbarch_inner_than (arch, core_addr_lessthan);
  set_gdbarch_breakpoint_kind_from_pc(arch, mmix_kind_from_pc);
  set_gdbarch_sw_breakpoint_from_kind(arch, mmix_from_kind);
  set_gdbarch_push_dummy_call(arch, mmix_push_dummy_call);

  set_gdbarch_char_signed(arch, 0);
  set_gdbarch_int_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit(arch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (arch, 8 * TARGET_CHAR_BIT);

  set_gdbarch_wchar_signed(arch, 0);
  set_gdbarch_wchar_bit(arch, 2 * TARGET_CHAR_BIT);

  set_gdbarch_double_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_double_format(arch, floatformats_ieee_double);
  set_gdbarch_long_double_bit(arch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_format(arch, floatformats_ieee_double);

  set_gdbarch_believe_pcc_promotion(arch, 1);
 
  return arch;
}

void _initialize_mmix_tdep();
void
_initialize_mmix_tdep()
{
  register_gdbarch_init(bfd_arch_mmix, mmix_gdbarch_init);
}

