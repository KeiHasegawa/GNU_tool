現状スタートアップルーチンで

	SETL	$254, #20
	SLU	$254,$254,12

のようにしてスタックポインタに 0x20000 をセットしているが
stack を参照してリンク時にこれを決定したいのだができていない.

int* f()
{
  extern int a;
  return &a;
}

に対してオリジナルの mmix-elf-gcc は

	LDA $0,a

を生成している. これは通常の命令とは違う特別な命令. リンク時に決まるらしい.
これをそのままアセンブルするとエラーになるが -x オプションを付加する必要があるらしい.

しかしリンク後の sample.elf の objdump の結果は

 100:	f71300fd 	put rG,253
 104:	23fefe00 	addu $254,$254,0
 108:	f2010252 	pushj $1,a50 <main>
 10c:	00fffffe 	trap 255,255,254

なのでできていない. sample.elf の実行時 $254 は 0 で main 函数が呼び出されることになる.

これはリンカができていないということだと思われる(後でそうとは言い切れないことが判明).

またこのバグとは別に .data セクション, .bss セクションがアドレス 0x20000 付近に
配置されている:

&test_f3 = 1ffb8
&test_g3 = 1ffb4
&test_h3 = 1ffb0

これらはもっと低いアドレスに配置されなくてはならない.
  => 最初はリンカのバグなのかと思ったがどうやらコンパイラのバグっぽい. リンカは
     ちゃんと低いアドレスに配置していた.

以下を参考に

/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-3.4.4.mmix-elf/gcc/config/mmix/crti.asm

以下のようにスタートアップルーチンを書けば

	PUT	rG, #fd
	GETA	$254, stack
	PUSHJ	$1, main
	trap	255, 255, 254

期待した動作になっている. なるほど GETA はリンク後以下のようになっている.

 100:	f71300fd 	put rG,253
 104:	e3fe0000 	setl $254,0x0
 108:	e6fe0002 	incml $254,0x2
 10c:	e5fe0000 	incmh $254,0x0
 110:	e4fe0000 	inch $254,0x0
 114:	f2010252 	pushj $1,a5c <main>
 118:	00fffffe 	trap 255,255,254

これはいつも発生する行番号がずれる問題を引き起こす可能性もある. と思ったが
少なくとも簡単な step, where, finish では期待通り動作している.

だからスタックでないメモリに配置された変数のアドレスを参照するのに LDA ではなくて GETA
を使用すればよいということ.

GETA は必ず 4 命令に生成するのに対して, LDA は解決されるシンボルの
アドレスによって少ない命令を生成するような仕様なのかもしれない.

単純にオリジナルの mmix-elf-gcc で LDA を出しているところを GETA に修正してみること
にしてみたらどうか?
