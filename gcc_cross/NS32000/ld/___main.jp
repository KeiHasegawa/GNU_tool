現状

int main()
{
  return 0;
}

のようなプログラムと tool/start.S のスタートアップルーチンのプログラムをビルドすると
___main の呼び出しが printf の呼び出しになっている. つまり ns32k-elf-ld で
bsr ___main を期待したオブジェクトコードに変換できていない. ___main のアドレス解決自体は
問題なし.

  => ~/lang/53_GNU_tool/gcc_cross/NS32000/test/test005

しかし一方

int f(int a, int b)
{
  return a + b;
}

int main()
{
  return f(5, 6);
}

のようなプログラムと tool/start.S のスタートアップルーチンのプログラムをビルドすれば
bsr ___main のオブジェクトコードは期待したものになっている

  => ~/lang/53_GNU_tool/gcc_cross/NS32000/test/test006

さらに以下のようなプログラム

extern int printf(const char*, ...);

void f(int a, int b)
{
  printf("%d + %d = %d\n", a, b, a + b);
}

int main()
{
  f(5, 6);
  return 0;
}

と tool/start.S のスタートアップルーチンとをビルドすれば __main のアドレスはやはり
正しくない. さらに

% ns32k-elf-gcc -S test.c
% ns32k-elf-as -o test.o test.s -g
% ns32k-elf-ld -o test.elf  /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o test.o -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/sample.x
% ns32k-elf-objdump -x -d -g test.elf > test.objdump
ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 4e0000c0
ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 4e0000c7
ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 4e0000c7
%

のように例のオフセットが間違った値になる.

  => ~/lang/53_GNU_tool/gcc_cross/NS32000/test/test007


まずは test005 から調査する. 現状以下のようなコードが生成されている.

0000011c <_main>:
 11c:	82 00 00    	enter	[], 0
 11f:	02 bf f1    	bsr	110 <_printf>   ★
 122:	ff          	0377
 123:	fd          	0375
 124:	5f 00       	movqd	0, r0
 126:	92 00       	exit	[]
 128:	12 00       	ret	0

セクション .text の内容:
 0100 27d89f00 0000ef04 02c00000 14061200  '...............
 0110 16120036 12004612 00000000 82000002  ...6..F.........  ★
 0120 bff1fffd 5f009200 1200               ...._.....        ★

0x02 0xbf 0xf1 0xff 0xfd の並びになっている理由を調べてみる.

(gdb) b bfd_set_section_contents
(gdb) run
...
Breakpoint 31, bfd_set_section_contents (abfd=0x817fcd8, section=0x8185a70, location=0x81815a0, offset=28, count=14) at section.c:1496
(gdb) x/14bx location
0x81815a0:	0x82	0x00	0x00	0x02	0xbf	0xf1	0xff	0xfd ★
0x81815a8:	0x5f	0x00	0x92	0x00	0x12	0x00
(gdb)


0000011c <_main>:
 11c:	82 00 00    	enter	[], 0
 11f:	02 ff ff ff 	bsr	10e <___main>
 123:	ef 

この部分の期待値は上のように 0xff 0xff 0xff 0xef らしい.
期待通りできている test006 の test.o は以下:

00000010 <_main>:
  10:	82 00 00    	enter	[], 0
  13:	02 ff ff ff 	bsr	0 <_f>
  17:	ed 
			14: PCREL_NS32K_DISP_32	___main        ★

一方 test005 の test.o は以下:

00000000 <_main>:
   0:	82 00 00    	enter	[], 0
   3:	02 ff ff ff 	bsr	0 <_main>
   7:	fd 
			4: PCREL_NS32K_DISP_16	___main        ★

test005 の test.o も PCREL_NS32K_DISP_32 になっていればできていそう.
ということはこれはリンカの問題ではなくてアセンブラの問題のように思える.

ns32k-elf-objdump の以下の部分で PCREL_NS32K_DISP_16 や PCREL_NS32K_DISP_32
が表示されている:

	      else if (q->howto->name)
		printf ("%s\t", q->howto->name);
	      else


test005 に対しては以下:
(gdb) p (**relppp)->howto
$11 = (reloc_howto_type *) 0x813d850 <ns32k_aout_howto_table+240>
(gdb) 

tets006 に対しては以下:

(gdb) p (**relppp)->howto
$9 = (reloc_howto_type *) 0x813d868 <ns32k_aout_howto_table+264>
(gdb)

上のように違いが出ている.

ns32k-elf-as 視点で調べてみる

static bfd_reloc_code_real_type
reloc (int size, int pcrel, int type)
{
...
    return relocs[rel_index];

(gdb) b (上の return 文)
(gdb) command
> p relocs[rel_index]
> c
> end
(gdb) run
...

test005 の場合も test006 の場合も返しているのは以下であった.
...
$93 = BFD_RELOC_NS32K_DISP_32_PCREL

$94 = BFD_RELOC_NS32K_DISP_32_PCREL
...

test005 で BFD_RELOC_NS32K_DISP_16_PCREL は返されていない. さてこれは一体どういうこと
なのか.

ns32k-elf-objdump や ns32k-elf-ld 視点では PCREL_NS32K_DISP_32 であるべきものが
PCREL_NS32K_DISP_16 になっているのは入力ファイルのどの部分から判断しているのか明確にするべき.


ns32k-elf-ld 視点:

bfd_byte *
bfd_generic_get_relocated_section_contents (bfd *abfd,
					    struct bfd_link_info *link_info,
					    struct bfd_link_order *link_order,
					    bfd_byte *data,
					    bfd_boolean relocatable,
					    asymbol **symbols)
{
...
  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);  ★

この函数の呼び出しで bsr ___main のオブジェクトコードが決定する準備をする.
この函数を呼び出す直前では

input_section は .text セクションで input_section->relocatable = nullptr であるが
この函数の呼び出しで

(gdb) p input_section->relocation->howto
$43 = (reloc_howto_type *) 0x812df90 <ns32k_aout_howto_table+240>
(gdb)

のようになる. 上の値の期待値は ns32k_aout_howto_table+264 で現状はできていない.
sizeof(reloc_howto_type) = 24 なので次のエントリということ.

問題の relocation メンバをセットしているのは以下:

bfd_boolean
elf_slurp_reloc_table (bfd *abfd,
		       asection *asect,
		       asymbol **symbols,
		       bfd_boolean dynamic)
{
...
  asect->relocation = relents;   ★


そしてそれを決定しているのは以下:

static bfd_boolean
elf_ns32k_info_to_howto(bfd* abfd, arelent* cache_ptr,
			Elf_Internal_Rela* dst)
{
  (void)abfd;
  unsigned int r_type = dst->r_info >> 8;  ★

(gdb) p/x *dst
$67 = {r_offset = 0x4, r_info = 0xaa7, r_addend = 0x0}
(gdb) 

だから howto メンバの値が ns32k_aout_howto_table+240
(240 = sizeof(reloc_howto_type) * (0xaa7 >> 8)) になるということ.

test005/test.o を emacs の hexl-mode で見たものが以下:

          005f 5f5f 6d61 696e 0000 0000 0400 0000  .___main........
000001f0: a70a 0000 0000 0000 2a00 0000 0201 0000  ........*.......
00000200: 

つまりファイルオフセット 0x1f0 に a70a とあるが, これの期待値が a70b ということ.

一方正しくできている test006/test.o を emacs の hexl-mode で見たものが以下:

          005f 6600 5f5f 5f6d 6169 6e00 1400 0000  ._f.___main.....
00000220: a70b 0000 0000 0000 2a00 0000 0201 0000  ........*.......
00000230:

ファイルオフセット 0x220 が a70b になっていてこれは正しい.
だからこれ以降はアセンブラ視点から調査する.
