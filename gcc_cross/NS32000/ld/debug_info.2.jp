自前の cc1 で -g を指定して生成したオブジェクトファイルをリンカに入力すると期待しない
.debug_info セクションが生成されてしまう件の調査

M-x gdb
gdb --annotate=3 ./ld-new
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.ns32k-elf.mine/host-i686-pc-linux-gnu/gcc
(gdb) run -o a.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o a.o /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/lib/gcc/ns32k-netbsd/3.4.4/libgcc.a -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/sample.x
[Inferior 1 (process 13230) exited normally]
(gdb) 

% ns32k-elf-objdump --dwarf=info a.elf

a.elf:     ファイル形式 ns32k-elf

.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x22 (32-bit)
   バージョン:    2
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x100
    <14>   DW_AT_high_pc     : 0x130
    <18>   DW_AT_name        : (indirect string, offset: 0x0): start.S
    <1c>   DW_AT_comp_dir    : (indirect string, offset: 0x8): /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool
    <20>   DW_AT_producer    : (indirect string, offset: 0x40): GNU AS 2.36.1
    <24>   DW_AT_language    : 32769	(MIPS assembler)
  コンパイル単位 @ オフセット 0x26:
   長さ:        0x6e (32-bit)
   バージョン:    4
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><31>: 省略番号: 1 (DW_TAG_compile_unit)
    <32>   DW_AT_stmt_list   : 0xbd
    <36>   DW_AT_low_pc      : 0x632e610c  ★
    <3a>   DW_AT_high_pc     : 0x4e00      ★
    <3e>   DW_AT_name        :ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 13000      ★
 (indirect string, offset: 0x13000): <オフセットが大きすぎます>
    <42>   DW_AT_comp_dir    :ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 3500       ★
 (indirect string, offset: 0x3500): <オフセットが大きすぎます>
    <46>   DW_AT_producer    :ns32k-elf-objdump: 警告: DW_FORM_strp オフセットが大きすぎます: 4200       ★
 (indirect string, offset: 0x4200): <オフセットが大きすぎます>
    <4a>   DW_AT_language    : 512	(Unknown: 200)
 <0><4c>: 省略番号: 79
ns32k-elf-objdump: 警告: DIE at offset 0x4c refers to abbreviation number 79 which does not exist
%
gdb から実行して再現している. DW_AT_low_pc をどのようにリンカが計算しているか確認する.

(gdb) b bfd_set_section_contents
(gdb) run
...
bfd_set_section_contents のブレークポイントに 6 回ヒット
Breakpoint 1, bfd_set_section_contents (abfd=0x8180cd8, section=0x8186cb0, location=0x819d090, offset=38, count=114) at section.c:1496
(gdb) p section->name
$5 = 0x818e5b3 ".debug_info"
(gdb) x/114bx location
0x819d090:	0x6e	0x00	0x00	0x00	0x04	0x00	0x00	0x00
0x819d098:	0x00	0x00	0x04	0x01	0xbd	0x00	0x00	0x00
0x819d0a0:	0x0c	0x61	0x2e	0x63	0x00	0x4e	0x00	0x00 ★
0x819d0a8:	0x00	0x30	0x01	0x00	0x00	0x35	0x00	0x00
0x819d0b0:	0x00	0x42	0x00	0x00	0x00	0x02	0xcf	0x00
0x819d0b8:	0x00	0x00	0x01	0x08	0x05	0x3b	0x00	0x00
0x819d0c0:	0x00	0x3d	0x01	0x00	0x00	0x28	0x00	0x00
0x819d0c8:	0x00	0x01	0x9c	0x03	0x04	0x05	0x69	0x6e
0x819d0d0:	0x74	0x00	0x04	0x66	0x00	0x01	0x03	0x05
0x819d0d8:	0x3b	0x00	0x00	0x00	0x30	0x01	0x00	0x00
0x819d0e0:	0x0d	0x00	0x00	0x00	0x01	0x9c	0x05	0x61
0x819d0e8:	0x00	0x01	0x03	0x0b	0x3b	0x00	0x00	0x00
0x819d0f0:	0x02	0x7b	0x08	0x05	0x62	0x00	0x01	0x03
0x819d0f8:	0x12	0x3b	0x00	0x00	0x00	0x02	0x7b	0x0c
0x819d100:	0x00	0x00
(gdb)


問題の値を書き変えているのは以下:

(gdb) where
#0  memcpy () at ../sysdeps/i386/i686/memcpy.S:75
#1  0x00000072 in ?? ()
#2  0xb7ec5b28 in _IO_file_xsgetn (fp=0xb7fdd104, data=0x819d090, n=114) at fileops.c:1406
#3  0xb7ec7fd8 in _IO_sgetn (fp=0x81822c0, data=0x819d090, n=114) at genops.c:500
#4  0xb7ebb6ee in _IO_fread (buf=0x819d090, size=1, count=114, fp=0x81822c0) at iofread.c:44
#5  0x0806f95f in cache_bread_1 (nbytes=114, buf=0x819d090, f=0x81822c0) at cache.c:319
#6  cache_bread (abfd=0x81821f8, buf=0x819d090, nbytes=114) at cache.c:358
#7  0x0806e9d3 in bfd_bread (ptr=0x819d090, size=114, abfd=<optimized out>) at bfdio.c:255
--Type <RET> for more, q to quit, c to continue without paging--
#8  0x08072801 in _bfd_generic_get_section_contents (abfd=0x81821f8, section=0x8196b2c, location=0x819d090, offset=0, count=114) at libbfd.c:911
#9  0x0808830b in bfd_get_full_section_contents (abfd=0x81821f8, sec=0x8196b2c, ptr=0xbffff32c) at compress.c:288
#10 0x08079553 in bfd_generic_get_relocated_section_contents (abfd=0x8180cd8, link_info=0x817cd20 <link_info>, link_order=0x818cb98, data=0x819d090 "n", relocatable=0, symbols=0x819be64) at reloc.c:8389
#11 0x08073ab9 in default_indirect_link_order (output_bfd=output_bfd@entry=0x8180cd8, info=info@entry=0x817cd20 <link_info>, output_section=output_section@entry=0x8186cb0, link_order=0x818cb98, generic_linker=1) at linker.c:2660
#12 0x080758ab in _bfd_generic_final_link (abfd=<optimized out>, info=0x817cd20 <link_info>) at linker.c:1938
#13 0x080626a3 in ldwrite () at ldwrite.c:546
#14 0x0805f8fd in main (argc=8, argv=0xbffff4f4) at ./ldmain.c:512


bfd_get_full_section_contents の呼び出しで値がセットされている. ということは
a.o の時点ですでに値がセットされていたということだろうか.

% ns32k-elf-objdump -s a.o
...
セクション .debug_info の内容:
 0000 6e000000 04000000 00000401 6f000000  n...........o...
 0010 0c612e63 00000000 00000000 00350000  .a.c.........5..   ★
 0020 00000000 00028100 00000108 053b0000  .............;..
 0030 000d0000 00280000 00019c03 0405696e  .....(........in
 0040 74000466 00010305 3b000000 00000000  t..f....;.......
 0050 0d000000 019c0561 0001030b 3b000000  .......a....;...
 0060 027b0805 62000103 123b0000 00027b0c  .{..b....;....{.
 0070 0000                                 ..              
...

つまりアセンブラの出力では DW_AT_low_pc でないものをリンカが DW_AT_low_pc として扱っている
ということ.

% ns32k-elf-objdump --dwarf=info a.o
...
    <10>   DW_AT_language    : 12	(ANSI C99)
    <11>   DW_AT_name        : a.c
    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x0): /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.ns32k-elf.mine/host-i686-pc-linux-gnu/gcc
    <19>   DW_AT_low_pc      : 0x0
    <1d>   DW_AT_high_pc     : 0x35
    <21>   DW_AT_stmt_list   : 0x0
...

おそらく DW_AT_language の 12 はオフセット 0x10 の値

DW_AT_low_pc はオフセット 0x18
DW_AT_high_pc はオフセット 0x1c

0x61 = 'a'
0x2e = '.'
0x63 = 'c'

ということ. つまり DW_AT_language : 12 や DW_AT_name : a.c をリンカが正しく認識できてい
ない.


% ns32k-elf-objdump -s /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o
...
セクション .debug_info の内容:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00000000 30000000 00000000 08000000  ....0...........
 0020 40000000 0180                        @.....          
...

% 

start.o の .debug_info のサイズが 4 の倍数になっていないことが原因のように思える.

% ns32k-elf-objdump --dwarf=info /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o 

/home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o:     ファイル形式 ns32k-elf

.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x22 (32-bit)
   バージョン:    2
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x0
    <14>   DW_AT_high_pc     : 0x30
    <18>   DW_AT_name        : (indirect string, offset: 0x0): start.S
    <1c>   DW_AT_comp_dir    : (indirect string, offset: 0x8): /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool
    <20>   DW_AT_producer    : (indirect string, offset: 0x40): GNU AS 2.36.1
    <24>   DW_AT_language    : 32769	(MIPS assembler)

%

32769 = 0x8001

試しにリンカへの入力を a.o を先に start.o を後にしてみたところ .debug_info セクションの
a.o の部分は正常だが start.o の部分は壊れている. 

おそらくこれは .debug_aranges セクションが正しくない.
「.debug_info offset of 0x6 in .debug_aranges section does not point to a CU header の警告の調査」で行なった以下の対応がおそらく正しくない:

bfd_reloc_status_type
_bfd_ns32k_reloc_imm (bfd *abfd,
		      arelent *reloc_entry,
		      struct bfd_symbol *symbol,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message)
{
...
   if (strcmp(n1, ".debug_aranges") == 0)
     return bfd_reloc_ok;  ★


もう一度この修正を見直してみたところ必要ないことに気付いた. おそらく
「bsr ___main のコードが正しくない件の調査(2)」で行なった修正の影響と思われる.
そしてそのときの修正をさらに以下のように修正した:

static unsigned int get_type(unsigned long r_info)
{
  unsigned int tmp = (0x100 | (r_info & 0xff));
  if (BFD_RELOC_NS32K_IMM_8 <= tmp && tmp <= BFD_RELOC_NS32K_DISP_32_PCREL)
    return tmp - BFD_RELOC_NS32K_IMM_8;
  tmp &= 0xff;
+ switch (tmp) {
+ case BFD_RELOC_8:        return 12;
+ case BFD_RELOC_16:       return 13;
+ case BFD_RELOC_32:       return 14;
+ case BFD_RELOC_8_PCREL:  return 15;
+ case BFD_RELOC_16_PCREL: return 16;
+ case BFD_RELOC_32_PCREL: return 17;
+ default: abort();
+ }
}

この修正を入れみたがまた期待する出力ファイルにはなっていない.

2022.06.06 15:45 現時点の問題点 .debug_info セクションが正しくない:

Contents of the .debug_info section (loaded from a.elf):

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x22 (32-bit)
   バージョン:    2
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x100
    <14>   DW_AT_high_pc     : 0x130
    <18>   DW_AT_name        : (indirect string, offset: 0x0): start.S
    <1c>   DW_AT_comp_dir    : (indirect string, offset: 0x8): /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool
    <20>   DW_AT_producer    : (indirect string, offset: 0x40): GNU AS 2.36.1
    <24>   DW_AT_language    : 32769	(MIPS assembler)
  コンパイル単位 @ オフセット 0x26:
   長さ:        0x6e (32-bit)
   バージョン:    4
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><31>: 省略番号: 1 (DW_TAG_compile_unit)
    <32>   DW_AT_stmt_list   : 0xbd
    <36>   DW_AT_low_pc      : 0x632e610c   ★
    <3a>   DW_AT_high_pc     : 0x4e00       ★
    <3e>   DW_AT_name        : (indirect string, offset: 0x13000): <オフセットが大きすぎます>  ★
    <42>   DW_AT_comp_dir    : (indirect string, offset: 0x3500): <オフセットが大きすぎます>   ★
    <46>   DW_AT_producer    : (indirect string, offset: 0x4200): <オフセットが大きすぎます>   ★
    <4a>   DW_AT_language    : 512	(Unknown: 200)   ★
 <0><4c>: 省略番号: 79

一周回って何も改善されていない.

一方 a.o.objdump の結果は以下:

Contents of the .debug_info section (loaded from a.o):

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x6e (32-bit)
   バージョン:    4
   Abbrev Offset: 0x0
   ポインタサイズ:4
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_producer    : (indirect string, offset: 0x6f): GNU C17 10.2.0 -g
    <10>   DW_AT_language    : 12	(ANSI C99)
    <11>   DW_AT_name        : a.c
    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x0): /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.ns32k-elf.mine/host-i686-pc-linux-gnu/gcc

となると以下が怪しい:

    <32>   DW_AT_stmt_list   : 0xbd

これがどのように計算されたか確認する. 0x6f + 78 = 0xbd ということらしい. .debug_str
セクションのオフセットでこれは正しいらしい. むしろ正しくないのは

    <32>   DW_AT_stmt_list   : 0xbd
           ^^^^^^^^^^^^^^^
           これ


           DW_AT_producer    : (indirect string, offset: 0xbd): GNU C17 10.2.0 -g

のようになるのが期待値. objdump 視点で何故これが  DW_AT_stmt_list になるか確認する.

a.o.objdump:
セクション .debug_info の内容:
 0000 6e000000 04000000 00000401 6f000000  n...........o...
 0010 0c612e63 00000000 00000000 00350000  .a.c.........5..
 0020 00000000 00028100 00000108 053b0000  .............;..
 0030 000d0000 00280000 00019c03 0405696e  .....(........in
 0040 74000466 00010305 3b000000 00000000  t..f....;.......
 0050 0d000000 019c0561 0001030b 3b000000  .......a....;...
 0060 027b0805 62000103 123b0000 00027b0c  .{..b....;....{.
 0070 0000                                 ..              

a.objdump:
セクション .debug_info の内容:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00010000 30010000 00000000 08000000  ....0...........
 0020 40000000 01806e00 00000400 00000000  @.....n.........
 0030 0401bd00 00000c61 2e63004e 00000030  .......a.c.N...0
 0040 01000035 00000042 00000002 cf000000  ...5...B........
 0050 0108053b 0000003d 01000028 00000001  ...;...=...(....
 0060 9c030405 696e7400 04660001 03053b00  ....int..f....;.
 0070 00003001 00000d00 0000019c 05610001  ..0..........a..
 0080 030b3b00 0000027b 08056200 0103123b  ..;....{..b....;
 0090 00000002 7b0c0000                    ....{...        

      6e000000 04000000 00000401 bd000000
      0c612e63

.debug_abbrev セクションが正しくないから省略番号が正しく解釈されていないのではと推測している
があくまでも推測.

objdump の視点から DW_AT_producer が期待値のところで DW_AT_stmt_list になってしまう
原因を調査するべき.

static unsigned char *
read_and_display_attr (unsigned long           attribute,
...
{
  if (!do_loc)
    printf ("   %-18s:", get_AT_name (attribute));    ★ ここで表示 
  data = read_and_display_attr_value (attribute, form, implicit_const,


(gdb) p get_AT_name (attribute)
$8 = 0x81603d3 "DW_AT_stmt_list"  ★
(gdb) p attribute
$9 = 16
(gdb) 

おそらく attribute の値が正しくないから期待しない結果になっていると推測. attribute を
どのように計算しているか確認する.


static bfd_boolean
process_debug_info (struct dwarf_section *           section,
...
{
...
      while (tags < start)
	{
...	
	  abbrev_attr *attr;  ★
...
	  for (attr = entry->first_attr;
	       attr && attr->attribute;
	       attr = attr->next)
	    {
...
	      tags = read_and_display_attr (attr->attribute,  ★

これを見る限りでは .debug_abbrev セクションがリストの構造をしていてそれをたどっているように
思える.

(gdb) b dwarf.c:3336 # printf ("   %-18s:", get_AT_name (attribute)); の行
(gdb) run
...
dwarf.c:3336 のブレークポイントにヒット
(gdb) p get_AT_name (attribute)
$21 = 0x81603d3 "DW_AT_stmt_list"
(gdb) up
(gdb) p *attr
$22 = {attribute = 16, form = 6, implicit_const = -1, next = 0x81b4e50}
(gdb) c
...
dwarf.c:3336 のブレークポイントにヒット
(gdb) p get_AT_name (attribute)
$23 = 0x81603e3 "DW_AT_low_pc"
(gdb) up
(gdb) p *attr
$24 = {attribute = 17, form = 1, implicit_const = -1, next = 0x81b4e68}
(gdb) c
(gdb) p get_AT_name (attribute)
$25 = 0x81603f0 "DW_AT_high_pc"
(gdb) up
(gdb) p *attr
$26 = {attribute = 18, form = 1, implicit_const = -1, next = 0x81b4e80}
(gdb) c
(gdb) p get_AT_name (attribute)
$27 = 0x8160364 "DW_AT_name"
(gdb) up
(gdb) p *attr
$28 = {attribute = 3, form = 14, implicit_const = -1, next = 0x81b4e98}
(gdb) c
(gdb) p get_AT_name (attribute)
$29 = 0x8160481 "DW_AT_comp_dir"
(gdb) up
(gdb) p *attr
$30 = {attribute = 27, form = 14, implicit_const = -1, next = 0x81b4eb0}
(gdb) c
(gdb) p get_AT_name (attribute)
$31 = 0x81604fd "DW_AT_producer"
(gdb) up
(gdb) p *attr
$32 = {attribute = 37, form = 14, implicit_const = -1, next = 0x81b4ec8}
(gdb) c
(gdb) p get_AT_name (attribute)
$35 = 0x81603d3 "DW_AT_stmt_list"
(gdb) up
(gdb) p *attr

以上の結果から

attribute  get_AT_name (attribute)
16         DW_AT_stmt_list
17         DW_AT_low_pc
18         DW_AT_high_pc
3          DW_AT_name
27         DW_AT_comp_dir
37         DW_AT_producer
16         DW_AT_stmt_list    ★ ここが間違い

という対応がある.

start.o.objdump:
...
  Number TAG (0x0)
   1      DW_TAG_compile_unit    [子なし]
    DW_AT_stmt_list    DW_FORM_data4
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_addr
    DW_AT_name         DW_FORM_strp
    DW_AT_comp_dir     DW_FORM_strp
    DW_AT_producer     DW_FORM_strp
    DW_AT_language     DW_FORM_data2
    DW_AT value: 0     DW_FORM value: 0
...
セクション .debug_abbrev の内容:
 0000 01110010 06110112 01030e1b 0e250e13  .............%..
 0010 05000000                             ....            

a.o.objdump:
...
Contents of the .debug_abbrev section (loaded from a.o):

  Number TAG (0x0)
   1      DW_TAG_compile_unit    [子あり]
    DW_AT_producer     DW_FORM_strp
    DW_AT_language     DW_FORM_data1
    DW_AT_name         DW_FORM_string
    DW_AT_comp_dir     DW_FORM_strp
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_data4
    DW_AT_stmt_list    DW_FORM_sec_offset
    DW_AT value: 0     DW_FORM value: 0
...
セクション .debug_abbrev の内容:
 0000 01110125 0e130b03 081b0e11 01120610  ...%............
 0010 17000002 2e003f19 030e3a0b 3b0b390b  ......?...:.;.9.
 0020 49131101 12064018 96421900 00032400  I.....@..B....$.
 0030 0b0b3e0b 03080000 042e013f 1903083a  ..>........?...:
 0040 0b3b0b39 0b271949 13110112 06401897  .;.9.'.I.....@..
 0050 42190000 05050003 083a0b3b 0b390b49  B........:.;.9.I
 0060 13021800 0000                        ......          

a.objdump
...
セクション .debug_abbrev の内容:
 0000 01110010 06110112 01030e1b 0e250e13  .............%..  ★
 0010 05000000 01110125 0e130b03 081b0e11  .......%........
 0020 01120610 17000002 2e003f19 030e3a0b  ..........?...:.
 0030 3b0b390b 49131101 12064018 96421900  ;.9.I.....@..B..
 0040 00032400 0b0b3e0b 03080000 042e013f  ..$...>........?
 0050 1903083a 0b3b0b39 0b271949 13110112  ...:.;.9.'.I....
 0060 06401897 42190000 05050003 083a0b3b  .@..B........:.;
 0070 0b390b49 13021800 0000               .9.I......      

オフセット  3 が 0x10
オフセット  5 が 0x11
オフセット  7 が 0x12
オフセット  9 が 0x03
オフセット 11 が 0x1b = 27
オフセット 13 が 0x25 = 37

ここで期待通り動作している m68k-elf-xxx と比較してみた:

start.o.objdump:
...
  Number TAG (0x0)
   1      DW_TAG_compile_unit    [子なし]
    DW_AT_stmt_list    DW_FORM_data4
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_addr
    DW_AT_name         DW_FORM_strp
    DW_AT_comp_dir     DW_FORM_strp
    DW_AT_producer     DW_FORM_strp
    DW_AT_language     DW_FORM_data2
    DW_AT value: 0     DW_FORM value: 0
...
セクション .debug_abbrev の内容:
 0000 01110010 06110112 01030e1b 0e250e13  .............%..
 0010 05000000                             ....            

a.o.objdump:
...
  Number TAG (0x0)
   1      DW_TAG_compile_unit    [子あり]
    DW_AT_producer     DW_FORM_strp
    DW_AT_language     DW_FORM_data1
    DW_AT_name         DW_FORM_string
    DW_AT_comp_dir     DW_FORM_strp
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_data4
    DW_AT_stmt_list    DW_FORM_sec_offset
    DW_AT value: 0     DW_FORM value: 0
...
セクション .debug_abbrev の内容:
 0000 01110125 0e130b03 081b0e11 01120610  ...%............
 0010 17000002 24000b0b 3e0b030e 00000324  ....$...>......$
 0020 000b0b3e 0b030800 00042e00 3f19030e  ...>........?...
 0030 3a0b3b0b 390b4913 11011206 40189642  :.;.9.I.....@..B
 0040 19000005 2e013f19 03083a0b 3b0b390b  ......?...:.;.9.
 0050 27194913 11011206 40189742 19000006  '.I.....@..B....
 0060 05000308 3a0b3b0b 390b4913 02180000  ....:.;.9.I.....
 0070 00                                   .               

a.objdump:
セクション .debug_abbrev の内容:
 0000 01110010 06110112 01030e1b 0e250e13  .............%..
 0010 05000000 01110125 0e130b03 081b0e11  .......%........
 0020 01120610 17000002 24000b0b 3e0b030e  ........$...>...
 0030 00000324 000b0b3e 0b030800 00042e00  ...$...>........
 0040 3f19030e 3a0b3b0b 390b4913 11011206  ?...:.;.9.I.....
 0050 40189642 19000005 2e013f19 03083a0b  @..B......?...:.
 0060 3b0b390b 27194913 11011206 40189742  ;.9.'.I.....@..B
 0070 19000006 05000308 3a0b3b0b 390b4913  ........:.;.9.I.
 0080 02180000 00                          .....           

比較する限り ns32k-elf-xxx が正しく動作しているように思える. しかし ns32k-elf-objdump は
違う結果を表示している.
attribute = 0x25 = 37 が期待される場面で何故 16 になってしまうのか調査する.


static void
add_abbrev_attr (unsigned long   attribute,
		 unsigned long   form,
		 bfd_signed_vma  implicit_const,
		 abbrev_list *   list)
{
...
  attr->attribute = attribute;  ★

16 をセットしているのは上の箇所. 期待通り動作している m68k-elf-objdump では 37 をセット
している. 何故この値が 37 ではなくて 16 になるのか調べてみる.

process_abbrev_set の呼び出しは 2 回あるのが期待値だが 1 回しかないのが ns32k-elf-xxx

      list = find_abbrev_list_by_abbrev_offset (abbrev_base,
						compunit.cu_abbrev_offset);
      if (list == NULL)  ★
	{
...
	  next = process_abbrev_set
	    (((unsigned char *) debug_displays [abbrev_sec].section.start

一方期待通り動作している m68k-elf-xxx では当然だが 2 回の呼び出しがある. 2 回目の
呼び出しがないのが上の条件が成立していないこと. だから何故
find_abbrev_list_by_abbrev_offset が 2 回目 NULL を返さないのか調べてみたところ
第 2 引数で指定している compunit.cu_abbrev_offset が 20 が期待値だが 0 が指定されている
から.

start.o の .debug_abbrev セクションと a.o の  .debug_abbrev セクションをリンク
するときにオフセット 20 という情報がないということ:

compunit.cu_abbrev_offset の計算の仕方を確認した:

  for (section_begin = start; start < end;)
    {
...
      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);  ★


m68k-elf-xxx:
...
セクション .debug_info の内容:
 0000 00000022 00020000 00000401 00000000  ..."............
 0010 00000100 00000130 00000000 00000008  .......0........
 0020 00000040 80010000 00bb0004 00000014  ...@............
                                     ★
ns32k-elf-xxx:
...
セクション .debug_info の内容:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00010000 30010000 00000000 08000000  ....0...........
 0020 40000000 01806e00 00000400 00000000  @.....n.........
                                     ★

つまり .debug_info セクションのオフセット 0x2c に 0x14 がセットされていないことが
問題.

cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ns32k-elf/ld
M-x gdb
gdb --annotate=3 ./ld-new
(gdb) cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/gcc-10.2.0.ns32k-elf.mine/host-i686-pc-linux-gnu/gcc
(gdb) run -o a.elf /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/start.o a.o /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/lib/gcc/ns32k-netbsd/3.4.4/libgcc.a -T /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/tool/sample.x

とここで期待通り動作していることが判明した. リビルドした ld-new を ns32k-elf-ld に上書き
コピーできていないかったのが原因. ヤレヤレ. お疲れのようである.

2022.06.07 12:41 現状 ns32k-elf-objdump の実行時に警告メッセージは出ていない.
そして ns32k-elf-gdb で実行した結果以下のようになっている.

% ns32k-elf-gdb a.elf -x gdbcom -q
Reading symbols from a.elf...
Connected to the simulator.
Loading section .text, size 0x65 lma 0x100
Loading section .rodata, size 0x10 lma 0x165
Start address 0x100
Transfer rate: 936 bits in <1 sec.
Breakpoint 1 at 0x140: file a.c, line 10.

Breakpoint 1, main () at a.c:10
10	  printf("hello world %d\n", f(5, 6));
f (a=<error reading variable: Cannot access memory at address 0x2000>, 
    b=<error reading variable: Cannot access memory at address 0x2004>)
    at a.c:4
4	{
#0  f (a=<error reading variable: Cannot access memory at address 0x2000>, 
    b=<error reading variable: Cannot access memory at address 0x2004>)
    at a.c:4
#1  0x00000146 in main () at a.c:10
#2  0x00000000 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
hello world 11
%

main で停止することはできているが

1. f にステップインしたとき適切にプロローグをスキップできていない
2. 引数の a と b が正しく表示できていない
3. where コマンドの結果が正しくない
4. finish コマンドも正しくない

等の問題はあるがリンカは正常に動作している. 結局 get_type の修正で十分だったが上書きコピー
ができていなかったことに気付かなかったのが問題だった.


