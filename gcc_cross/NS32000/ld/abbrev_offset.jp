現状 -g オプションなしでコンパイラの生成したプログラムをアセンブル, リンクして objdump に入力
させると以下のように警告メッセージを出力している:

% ns32k-elf-gcc -S test.c
% ns32k-elf-as -o test.o test.s -g
% ns32k-elf-as -o ../default.o -g ../default.S
% ns32k-elf-ld -o test.elf ../default.o test.o -T ../default.x
% ns32k-elf-objdump -x -d -g test.elf > test.objdump
ns32k-elf-objdump: Warning: Debug info is corrupted, abbrev offset (ffffffee) is larger than abbrev section size (28)
...

そして ns32k-elf-gdb で実行すると以下のようにエラーメッセージが出力される:
% ns32k-elf-gdb -q -x gdbcom test.elf > test.log
Dwarf Error: bad offset (0xffffffee) in compilation unit header (offset 0x26 + 6) [in module /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/test/test003/test.elf]
%

そこで以下も試してみた:

% ns32k-elf-objdump -x -d -g test.o > test.o.objdump
%

警告メッセージは表示されない. ということはおそらくリンカの出力に問題がある可能性が多いにある.
異常が最初に検出されている ns32k-elf-objdump の視点でこの問題を調査してみる.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ns32k-elf/binutils

M-x gdb
gdb --annotate=3 ./objdump
(gdb) cd ~/lang/53_GNU_tool/gcc_cross/NS32000/test/test003
(gdb) run --dwarf=info test.elf
test.elf:     ファイル形式 ns32k-elf

.debug_info セクションの内容:

  コンパイル単位 @ オフセット 0x0:
   長さ:        0x22 (32-bit)
   バージョン:    2
   省略オフセット: 0x0
   ポインタサイズ:4
 <0><b>: 省略番号: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_stmt_list   : 0x0
    <10>   DW_AT_low_pc      : 0x100
    <14>   DW_AT_high_pc     : 0x1100
    <18>   DW_AT_name        : (間接文字列、オフセット: 0x0): ../default.S
    <1c>   DW_AT_comp_dir    : (間接文字列、オフセット: 0xd): /home/khasegawa/lang/53_GNU_tool/gcc_cross/NS32000/test/test003
    <20>   DW_AT_producer    : (間接文字列、オフセット: 0x4d): GNU AS 2.36.1
    <24>   DW_AT_language    : 32769	(MIPS assembler)
  コンパイル単位 @ オフセット 0x26:
   長さ:        0x22 (32-bit)
   バージョン:    2
   省略オフセット: 0xffffffee  ★
   ポインタサイズ:4
/media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ns32k-elf/binutils/objdump: 警告: デバッグ情報が壊れています。省略オフセット (ffffffee) が省略セクションサイズ (28) より大きいです  ★
...

gdb から実行して再現できている.

% ns32k-elf-objdump -s test.elf
...
Contents of section .debug_info:
 0000 22000000 02000000 00000401 00000000  "...............
 0010 00010000 00110000 00000000 0d000000  ................
 0020 4d000000 01802200 00000200 eeffffff  M.....".........   ★
 0030 04013e00 00001001 00001025 0000805b  ..>........%...[
 0040 0000875b 0000875b 00000180           ...[...[....    
...
この値にしているのはリンカなのでリンカ視点から調べてみる.

% cd /media/ca850f52-0605-42a7-9fd4-899de9edf461/work/GNU_LANG/binutils-2.36.1.ns32k-elf/ld

M-x gdb
gdb --annotate=3 ./ld-new
(gdb) cd ~/lang/53_GNU_tool/gcc_cross/NS32000/test/test003
(gdb) b bfd_set_section_contents
(gdb) run -o test.elf ../default.o test.o -T ../default.x
...
bfd_set_section_contents のブレークポイントに数回ヒット
Breakpoint 1, bfd_set_section_contents (abfd=0x817ecd8, section=0x8184c10, location=0x8180530, offset=0, count=38) at section.c:1496
(gdb) p section->name
$7 = 0x818c4e3 ".debug_info"   ★
(gdb) x/38bx location
0x8180530:	0x22	0x00	0x00	0x00	0x02	0x00	0x00	0x00
0x8180538:	0x00	0x00	0x04	0x01	0x00	0x00	0x00	0x00
0x8180540:	0x00	0x01	0x00	0x00	0x00	0x11	0x00	0x00
0x8180548:	0x00	0x00	0x00	0x00	0x0d	0x00	0x00	0x00
0x8180550:	0x4d	0x00	0x00	0x00	0x01	0x80
(gdb) c
Continuing.

Breakpoint 1, bfd_set_section_contents (abfd=0x817ecd8, section=0x8184c10, location=0x8180530, offset=38, count=38) at section.c:1496
(gdb) x/38bx location
0x8180530:	0x22	0x00	0x00	0x00	0x02	0x00	0xee	0xff
0x8180538:	0xff	0xff	0x04	0x01	0x3e	0x00	0x00	0x00
0x8180540:	0x10	0x01	0x00	0x00	0x10	0x25	0x00	0x00
0x8180548:	0x80	0x5b	0x00	0x00	0x87	0x5b	0x00	0x00
0x8180550:	0x87	0x5b	0x00	0x00	0x01	0x80
(gdb)

何故 2 回目なのかはここではスルーしておく.

  => 後で気付いたことは ../default.o と test.o の 2 つの入力ファイルがあるからだと考えた.	

アドレス 0x8180536 から 4 バイトに問題の ffffffee がセットされている.

void
_bfd_ns32k_put_immediate (bfd_vma value, bfd_byte *buffer, int size)
{
  if (!work_around) {
    // ビッグエンディアン形式
    ...
  }
  else {
    // リトルエンディアン形式
    buffer[0] = value;          ★
    if (size == 1)
      return;
  
    buffer[1] = value >> 8;
    if (size == 2)
      return;

    assert(size == 4);
    buffer[2] = value >> 16;
    buffer[3] = value >> 24;
  }
}

これは正しい .debug_line セクションを生成するために入れた修正のところであるが, 仮に
ビッグエンディアン形式で格納したとしてもやはりエラーになりそうに思える.

最近作成した m68k-elf-xxx で試してみたところ以下のようにオフセット 0 になっている: 

  Compilation Unit @ offset 0x0:
   Length:        0x22 (32-bit)
   Version:       2
   Abbrev Offset: 0x0          ★
   Pointer Size:  4

test.o.objdump は test.o を ns32k-elf-objdump に入力した結果であるが

  Compilation Unit @ offset 0x0:
   Length:        0x22 (32-bit)
   Version:       2
   Abbrev Offset: 0x0          ★
   Pointer Size:  4

これもそれっぽい. ということはリンカで ffffffee をどのように計算していたか確認してみるべき.

      if (relocation)
	{
	  bfd_vma x = get_data (location, 4);
	  DOIT (x);                               ★
	  put_data ((bfd_vma) x, location, 4);
	}
      break;

ここで x = 0xffffffee に計算している. DOIT マクロは同一ファイル内にある:

#define DOIT(x) \
  x = ( (x & ~howto->dst_mask) | (((x & howto->src_mask) +  relocation) & howto->dst_mask))

そもそも relocation が非 0 になっているのが期待しない動作かもしれない.

(gdb) p/x relocation
$82 = 0xffffffee
(gdb) 

どうやらそれっぽい.

% cat z2
b do_ns32k_reloc
command
if ((int)strcmp(input_section->name, ".debug_info"))
c
end
if ((int)strcmp(symbol->name, ".debug_abbrev"))
c
end
end
(gdb) so z2

このブレークポイントに 2 回目ヒットしたとき relocation = 0xffffffee になっている.

試しに以下のように回避してみた:

bfd_reloc_status_type
_bfd_ns32k_reloc_imm (bfd *abfd,
		      arelent *reloc_entry,
		      struct bfd_symbol *symbol,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message)
{
+ const char* n1 = input_section->name;
+ const char* n2 = symbol->name;
+ if (strcmp(n1, ".debug_info") == 0 && strcmp(n2, ".debug_abbrev") == 0)
+   return bfd_reloc_ok;
  return do_ns32k_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message, _bfd_ns32k_get_immediate,
			 _bfd_ns32k_put_immediate);
}

一応これで回避はできているが正しい対処ではなさそう.
本来リロケーションでないべきものがリロケーションの扱いになっていること自体が問題.

  => 後で気付くがこの修正をキャンセルすることになる.
  

