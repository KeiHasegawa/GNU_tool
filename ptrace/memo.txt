ptrace に関する調査

(*1) やりたいこと
(*2) PTRACE_TRACEME
(*3) gdb から実行して ptrace をエラーにしない方法

(*1) やりたいこと

     メモリ破壊のバグをデバッガの力を借りずに, プログラム内に特別なコードを
     埋め込むことで調査したい. Windows にも ptrace はないのだが, 近いものは
     あるはず.

(*2) PTRACE_TRACEME

     ptrace の第一引数にこれを指定することでプロセスのトレースができる
     らしい. => test000.c

     % gcc -g test000.c
     % ./a.out
     ret = 0
     %

     これだけでは面白くも何ともないがまずはこれがスタートラインということ.
     ところでこのプログラムを gdb から動作させた場合何が起こるか.

     (gdb) run
     Starting program: /home/khasegawa/lang/53_GNU_tool/ptrace/a.out 
     ret = -1
     EPERM
     [Inferior 1 (process 29680) exited normally]
     (gdb) 

      つまり gdb がすでにこのプロセスをトレースしているのに, この場合はこの
      プロセス自身が, トレースする権利を横取りしようとしたためにこのエラー
      が起こっている.

      このことで確認したかったのは, 必ずしも ptrace は別のプロセス, 特にサ
      ブプロセスである必要はなく, 自身でも機能するということ. しかし gdb に
      よるテストプログラムの観測が難しい場合は必要に応じて fork, exec
      することにする.

(*2) gdb から実行して ptrace をエラーにしない方法

     test001.c は fork したプロセスに対して ptrace を発行し, 最後に
     SIGKILL を送るというもの.

     % gcc -g test001.c -o a.out
     % ./a.out
     %

     エラーは表示されない. さてこれを gdb から実行して ptrace でエラーし
     ないようにしてみたい. gdb から普通に実行するとやはり ptrace は
     失敗し errno = EPERM になってしまう.

     おそらくこれは gdb が 親のプロセスとサブプロセスの両方に対して既に
     ptrace を発行しているのが原因で, gdb から

     ptrace(PTRACE_DETACH, pid)

     が発行されればこの現象を回避できると思われる. gdb の detach コマンド
     を調べてみたのだが, どうもよくわかっていない.
