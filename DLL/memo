(*1) getopt の調査

(*1) getopt の調査

    man -s:3 getopt で使用例として sample.c が記載されているので
    そのままコピーしてコンパイルしてみた.

linux % gcc -g sample.c -o sample.exe
linxu % ./sample.exe -n -t 123 hoge
flags=1; tfnd=1; optind=4
name argument = hoge

    期待通り動作している. ところでこれを gdb から実行してみた:

linux % gdb -q sample.exe
(gdb) b sample.c:20
(gdb) run -n -t 123 hoge
(gdb) p optarg
# 0x0 になっている. 期待値は argv[3]
(gdb) b sample.c:32
(gdb) c
# 32 行目で停止した
(gdb) p optind
# 1 になっている. 期待値は 4

    これは明らかに gdb が何かしている. それとも gcc が生成しているデバッグ
    情報に問題があるのか. プログラムの動きは期待したものだが gdb の動きが
    おかしい.

    同じことを cygwin で試してみた.

cygwin % gcc -g sample.c -o sample.exe
cygwin % ./sample.exe -n -t 123 hoge
flags=1; tfnd=1; optind=4
name argument = hoge

    期待通り動作している.
cygwin % gdb -q sample.exe    
(gdb) b sample.c:20
(gdb) run -n -t 123 hoge
(gdb) p optarg
# OK "123" を指している
(gdb) b sample.c:32
(gdb) c
# 32 行目で停止した
(gdb) p optind
# OK 4 になっている.

    そもそもこの調査をしたのは cygwin で getopt が期待通り動作していなかった
    のだが, このように単純な環境では期待通り動作する.
    基本ブロックプロファイルの bbprof.exe で getopt を使用していたのだが, これが期
    待通り動作していなかった. そこで以下を試してみた:

cygwin % gcc -g sample.c -o sample.exe d:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/libiberty/libiberty.a
cygwin % ./sample.exe -n -t 123 hoge
Segmentation fault(core dumped)         # 不正メモリアクセス
cygwin % gdb -q sample.exe
(gdb) b sample.c:20
(gdb) run -n -t 123 hoge
(gdb) p optarg
$1 = 0xffffcc8b "123"
(gdb) x/5i $rip
=> 0x7ff734f510b8 <main+72>:	
    mov    0x70ed(%rip),%rax        # 0x7ff734f581ac <__imp_optarg>
   0x7ff734f510bf <main+79>:	mov    (%rax),%rax
   0x7ff734f510c2 <main+82>:	mov    %rax,%rcx
   0x7ff734f510c5 <main+85>:	call   0x7ff734f520d0 <atoi>
   0x7ff734f510ca <main+90>:	mov    %eax,-0x5c(%rbp)
(gdb) stepi 3
(gdb) p/x $rax
$2 = 0x0      期待値は argv[3] で "123" のアドレス
(gdb) nexti
nexti
      0 [main] sample 60 cygwin_exception::open_stackdumpfile: Dumping stack trace to sample.exe.stackdump

     当時 bbprof.exe を開発したとき, これはすごく奇妙な現象に思われたがここまで
     問題を切り分けられればだいぶバグが搾れるだろう.
     
      

