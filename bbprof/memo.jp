基本ブロックプロファイル

(*1) やりたいこと
(*2) 最初のサンプル
(*3) profile_basic_block.cpp
(*4) bbprof1.cpp
(*5) bbprof2.cpp
(*6) bbprof3.cpp

(*1) やりたいこと

     プログラムを実行した後, 実行した行をハイライトさせた形で表示する.
     例えば, テストを行ったときに通っているところ, いないところを明白
     にできる.

(*2) 最初のサンプル

     test000.c を最初のサンプルに選んだ. これの期待値が test000.ppt
     である. 現状はとりあえず ppt 形式にしているのだが, これはいずれ web
     ブラウザなどで見られるようになるとよい. あるいは emacs などの
     エディタでハイライト機能があるのでそれもよい.

     test000.c は通常次のようにビルドされる.
     
% gcc test000.c -o test000.exe

     これとあまり変わらない形でビルドされなくてはならないが, ユーザーは
     プロファイルのために特別なビルドをしなくてはならない. 例えば通常の
     gprof を使用するためには

% gcc -pg test000.c -o test000.exe
% ./test000.exe
% gprof test000.exe gmon.out

     のようなことをする必要がある. 基本ブロックのプロファイルでは以下の
     ようにする必要がある:

% gcc -g -c test000.c --profile-basic-block
% gcc -g -c profile_basic_block.cpp
% gcc profile_basic_block.o test000.o -o test000.exe
% ./test000.exe
% ./bbprof.exe test000.exe bb.out

     --profile-basic-block オプションを使用するためには
     「基本ブロックプロファイルのための gcc の修正」を行う必要があり,
     自分でビルドした gcc を使用しなくてはならない. これはものすごく
     ハードルが高いが, ツールが完成していないのでしょうがない.

     また 2 つ目の gcc の実行時に --profile-basic-block を使用してはいけない.

     profile_basic_block.cpp は「gprof の調査」で述べた mcount に相当
     するもので, これをソースとしてあなたのプログラムに組み込むことを
     要求している. これもユーザーのビルド環境を変更するというなんとも
     醜悪な形になってしまっている.

     そして最後の bbprof.exe は自前のコマンドで, binutils を使う必要が
     ある. ビルドするには単純な binutils のインストールでは不十分で
     ソースからビルドする必要がある(かもしれない).

     ここまで聞くと, やめとこうということになるだろうが, これが
     標準になれば面倒臭いことがだいぶやらなくてよくなるかもしれない.

(*3) profile_basic_block.cpp

     この函数では, 呼び出し元のアドレスをファイルに書き込むことをしている.
     改善点はあるが現時点ではこれで十分である.

     o profile_basic_block.cpp を最適化してコンパイルすれば動作しない可能性
       がある

     o 複数スレッドを使うプログラムには対応していない

(*4) bbprof1.cpp

     最初のバージョンは, プログラム内の函数のアドレスと (*3) の機能で記録し
     たアドレスから, どの函数から呼び出されているかを表示するだけのものにした.
     本当は「ソース行のどこから」という情報が必要だが, これも現時点では十分で
     ある. ビルドの方法は以下:

 linux % g++ -o bbprof.exe -DPACKAGE bbprof1.cpp -lbfd -liberty -L/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/libiberty -ldl -lz

cygwin % g++ -o bbprof.exe -DPACKAGE bbprof1.cpp -lbfd -liberty -ldl -lz -lintl

(*5) bbprof2.cpp

     2 つ目のバージョンは, ファイル名と行番号を表示できるようになっている.
     addr2line というプログラムが binutils にあるが参考にした. ビルドの方法は
     bbprof1.cpp と同じである.

(*6) bbprof3.cpp

     3 つ目のバージョンは, さらにカラム数を取り出せるようにしたものである.
     残念ながら libbfd.a でこの機能がないのでその部分だけ作成した. ビルドの
     方法は:

linux
g++ -g -DPACKAGE bbprof3.cpp -c -o bbprof3.o
gcc -g -I/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd -I/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/include -DPACKAGE bbprof3_0.c -c -o bbprof3_0.o
gcc -g -I/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd -I/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/include my_dwarf2.c -c -o my_dwarf2.o -DDEBUGDIR=\".\"
g++ -o bbprof.exe bbprof3.o bbprof3_0.o my_dwarf2.o -lbfd -liberty -L/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/libiberty -ldl -lz

cygwin
g++ -g -DPACKAGE bbprof3.cpp -c -o bbprof3.o
gcc -g -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/include -DPACKAGE bbprof3_0.c -c -o bbprof3_0.o
gcc -g -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/include my_dwarf2.c -c -o my_dwarf2.o -DDEBUGDIR=\".\"
gcc -g -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd -Id:/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/include my_coffgen.c -c -o my_coffgen.o
g++ -o bbprof.exe bbprof3.o bbprof3_0.o my_dwarf2.o my_coffgen.o -lbfd -liberty -ldl -lz -lintl

     ファイルによってオプションが少し異なっていることに注意したい.
     my_dwarf2.c は ~/binutils-2.36.1-2.src/binutils-2.36.1/bfd/dwarf2.c
     のほとんどコピーである. 同様に
     my_coffgen.c も ~/binutils-2.36.1-2.src/binutils-2.36.1/bfd/coffgen.c
     のほとんどコピーである.

(*7)

% gcc -g -S test000.c --profile-basic-block

     として test000.s の中を確認した. 以下抜粋:

f:
	.file 1 "test000.c"
	.loc 1 2 1
...
	.loc 1 3 16
...
	.loc 1 3 16 is_stmt 0 discriminator 1
...
	.loc 1 3 16 discriminator 2
...
	.loc 1 4 1 is_stmt 1 discriminator 5
main:
...
	.loc 1 7 1


cygwin 版で期待通り動作しない理由は f でレジスタを save する前に

       _profile_basic_block_

を呼び出しているから. このため rcx, rdx, r8, r9 が壊されている.
linux 版はたまたま動作しているといっていい. なので prolog が終わったところで
1 回目の呼び出しコードを生成するように修正する.

と思ったが, profile_basic_block.cpp を修正すれば cc1 は修正しなくてよいので
そっちで対応する.

