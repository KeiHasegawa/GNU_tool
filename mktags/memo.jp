タグ生成

(*1) vi での ctags の簡単な使い方
(*2) emacs での ctags の簡単な使い方
(*3) プログラムファイルからタグファイルを生成する
(*4) mktags.exe のビルド方法
(*5) tags のフォーマット
(*6) TAGS のフォーマット
(*7) C++ の STL に emacs でタグジャンプする.
(*8) コンテキスト
(*9) gcc の -g3 オプション
(*10) 使っていて気付いたこと

(*1) vi での ctags の簡単な使い方

起動時にタグジャンプ	vi -t <タグ名>
タグジャンプ		:ta <タグ名>
タグジャンプ		Ctrl-]
元に戻る			Ctrl-T

% cat a.c
#include <stdio.h>

void f();

#define X 2

int main()
{
  printf("hello\n");
  f();
  return 0;
}
% cat b.c
#include "d.h"

int a;

void g(int);

void f()
{
  g(a);
  g(X);
}

int f2(location loc)
{
  return loc;
}
% cat c.c
#include <stdio.h>
#include "d.h"

void g(int n)
{
  printf("n = %d\n", n);
}

extern int a;

void h(struct S* ps)
{
  printf("ps->m = %d\n", ps->m);
  printf("a = %d\n", a);
}
% cat d.h
#ifndef D_H
#define D_H

#define X 1

struct S {
  int m;
};

typedef unsigned int location;

#endif /* D_H */
% ctags a.c b.c c.c d.h
# tags というファイルが生成される
% vi -t location
# vi が起動して d.h の location の定義位置が表示される
vi のコマンドで
:ta main
のようにするとタグ main ジャンプできる.
探したい名前のところにカーソルをもっていって

Ctrl-] 

とすればタグジャンプできる. タグジャンプした後

Ctrl-T

とすればもとに戻ることができる.

(*2) emacs での ctags の簡単な使い方

タグファイルを読み込む	M-x visit-tags-table
タグジャンプ		M-.
元に戻る			M-*
次の候補			C-u M-.

% ctags -e b.c c.c hoge.c d.h
# TAGS というファイルが作成される

emacs を起動して

M-x visit-tags-table

で生成した TAGS を指定する. 通常はカレントディレクトリの TAGS ファイルを
開こうとしているから, その場合はリターンキーを押せばよい.

ファイルを開いた状態で探したい名前のところにカーソルをもっていって

M-.

とすればタグジャンプできる. タグジャンプした後

M-*

とすればもとに戻ることができる.

C-u M-.

とすれば複数候補の次にジャンプする. a.c と d.h にマウロ X の
定義がそれぞれあるので X にタグジャンプすると
a.c の X の定義にジャンプする. その後

C-u M-.

とすると d.h の X の定義にジャンプする.

(*3) プログラムファイルからタグファイルを生成する

% ./mktags.exe a.out
# tags が生成される. vi 用
% ./mktags -e a.out
# TAGS が生成される. emacs 用.

オプション:

-a : 絶対パスで生成する. デフォルトでは相対パスで生成.
-e : TAGS を生成する. emacs 用. デフォルトでは tags を生成する. vi 用.
-v : objdump -g が出力する結果を標準出力に書き出す.
-E <ディレクトリ> : -E /usr のように使用する. /usr から始まるファイルを
                    無視する.

(*4) mktags.exe のビルド方法

1. binutils をソースファイルからビルドする.

    トップ -> 「GNU のツール」->
    「linux での binutils 2.36.1 インストールメモ」

    が参考になる. cygwin でもトラブルが発生せずビルドとインストールが
    できている.

2. このページにある mktags.cpp my_dwarf.c my_objdump.c Makefile
   をダウンロードして以下のように実行する:

% make -n
# g++, gcc の起動方法を確認する. Makefile の BINUTILS_DIR を自分の環境に
# 合わせて修正する.
% make
# 正しく動けば同じディレクトリに mktags.exe をビルドできる.

(*5) tags のフォーマット

(タグ名)	(ファイル名)	(vi コマンド)"	[fvdsm]	[file:]

例えば
HOGE	./a.c	1;"	d	file:
main	./a.c	/^int main()$/;"	f

は

    o タグ HOGE に対して ./a.c を開いて 1 行目にジャンプするということを
      意味しているようである.
    o タグ main に対して ./a.c を開いて正規表現 ^int main()$
      を検索することを意味しているようである.

(*6) TAGS のフォーマット

    (*5) を TAGS で表現すると以下のようになる:

^L
./a.c,45
#define HOGE 1^?HOGE^A1,0
int main()^?main^A3,16

     ^L : エスケープ文字 '\f'
     45 : #define ... 16 までのバイト数
     ^? : 0177 を putc したもの
     ^A : 1 を putc したもの

^L
ファイル名,バイト数
テキスト1^Lタグ名1^A行番号1,ファイル内オフセット1
...

     のようになる.

(*7) C++ の STL に emacs でタグジャンプする.
% cat a.cpp
#include <vector>

int main()
{
  using namespace std;
  vector<int> vi;
  return 0;
}
% g++ -g3 a.cpp -o a.out
% ./mktags.exe -e a.out

     として TAGS を生成する. emacs で vector へタグジャンプしてみる.
     ジャンプした先は

/usr/local/include/c++/10.2.0/vector

     の 1 行目であった. これはどういうことかというと, emacs の対応する
     Lisp の函数の仕様で, ファイル名に vector というものがあればそこに
     ジャンプするということらしい.

     ファイル名ではなくて vector の宣言にジャンプするには
     Find tag の引数に以下を指定する:

vector<int, std::allocator<int> >

     これは面倒だが機能してはいる. std::vector ではなくて単に vector
     になっているのは a.cpp の書き方に依存しているようである.

     タグ名がなければファイル名にジャンプするという emacs Lisp の対応
     する函数の仕様は期せずして有用なものではある. 例えば mktags.exe 自
     身の TAGS を生成して dwarf2.h にタグジャンプすれば全く身に覚えのない,
     しかしビルド時に参照しているヘッダーファイルを簡単に開くことができる.

(*8) コンテキスト

     当然ながら emacs のタグジャンプでは対象が何かを判断していない.
     そういう仕様だからであるし, これは妥当に思える. 高望みすればタグ
     ジャンプする先は最小限であってほしい. コンテキストを理解すれば

#include <vector> ここでタグジャンプしたらファイル vector を開く

int main()
{
  using namespace std;
  vector<int> vi; ここでタグジャンプしたら vector のクラス宣言にジャンプ
  return 0;       次の候補は vector のデフォルトコンストラクタ
}

     コンパイラはその情報を生成している. しかし実現は難しい.
     mktags.exe では vector にタグジャンプすると

     第一候補 : ファイル vector
     第二候補 : メンバ名の const bfd_target *vector
     第三候補 : vector のデフォルトコンストラクタ

     になっていた. 第二候補が出るのは仕様とはいえ, 非常に残念である.

(*9) gcc の -g3 オプション

     -g オプションとの違いはマクロの情報が生成されることである.
     gdb や mktags.exe はこれらの情報を使用してプログラマに有用な
     情報を提供する. しかし -g オプションだけでも通常のデバッグ
     情報が生成されるので, マクロへのタグジャンプが必要でなければ
     これで十分である.

(*10) 使っていて気付いたこと

     デバッグビルドした cc1 に mktags.exe を実行した結果:

linux % date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e  ; date

     これは mktag.exe を -O0 ビルドしたもの. 3 分で終了している. -O3
     ビルドで試してみたところ 2 分 20 秒くらいだった.

     enumerator の行番号を生成する修正を加えると cc1 に対するタグ生成で
     不正メモリアクセスがきっかけなのか bad_alloc が投げられる.

     生成した TAGS を使用して気付いたこと:

last_text はいらないように思える.

     mktags.exe 自身の TAGS ファイルに対して気付いたこと:

       o TAGS を見ると contents に対して同じものが並んでいる.
         なので 2 つ目の候補にたどりつくのが難しい.

しかし, 以下の同じ行が TAGS に出現する.
  unsigned char *contents;contents1152,40241

../../../binutils-2.36.1-2.src/binutils-2.36.1/bfd/bfd.h,6775219
/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd/./bfd.h,507667
/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/bfd/bfd.h,389684
/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/binutils/../bfd/bfd.h,822165
/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/libctf/./../bfd/bfd.h,2569655
/home/khasegawa/binutils-2.36.1-2.src/binutils-2.36.1/opcodes/../bfd/bfd.h,659513

上の 6 つが異なるとしてだぶっている.

     test014 で再現環境を作って, これを修正したつもりだがエンバグしている.

     test014 での修正をキャンセルした状態で cc1 に対して TAGS を生成すると
     予期しない例外がスローされている.

     test013 での修正はカレントディレクトリに対する対処だった.

     git の最新版で試してもやはり cc1 に対してエラーしている.

% git cat-file -p cb4e82052d2d1aa8ba5dfbfd43d69fb48f96493c:mktags/mktags.cpp > mktags.cpp  # test013 の対応前の状態

% ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e
cannot open /home/khasegawa/gcc-10.2.0/host-i686-pc-linux-gnu/gcc//usr/include/_G_config.h
...
cannot open /home/khasegawa/gcc-10.2.0/i686-pc-linux-gnu/libstdc++-v3/src/c++98//usr/include/wchar.h
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
アボート
% 


% git cat-file -p 1c02e1511d3cfdd7042794c203e4ec44e2498043:mktags/mktags.cpp > mktags.cpp # test012 の対応前の状態
% ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
アボート
% 

% git cat-file -p 90951767e4a12cbc17311a233d3f9f834dc2f1bd:mktags/mktags.cpp > mktags.cpp
% git cat-file -p 90951767e4a12cbc17311a233d3f9f834dc2f1bd:mktags/my_dwarf.c > my_dwarf.c
% make
% pushd
% date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e  ; date
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
アボート
% 

% git cat-file -p 05eaf8110dceaf0d762d4ad4e195098ccd9b1d97:mktags/mktags.cpp > mktags.cpp
% make
% !pu
% !da
date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e ; date
2021年  5月 20日 木曜日 06:42:35 JST
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
アボート
2021年  5月 20日 木曜日 06:46:16 JST

% git cat-file -p 8315dd873855986aaa8616f09b9e76e614dd8051:mktags/mktags.cpp > mktags.cpp
% !ma
% !pu
% !da
date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e ; date
2021年  5月 20日 木曜日 06:48:01 JST
2021年  5月 20日 木曜日 06:51:09 JST

ということは...

% git cat-file -p 05eaf8110dceaf0d762d4ad4e195098ccd9b1d97:mktags/mktags.cpp > mktags.cpp.bug
% diff -rc mktags.cpp mktags.cpp.bug

enumerator の対処の修正でバグっていたらしい.

% mv mktags.cpp mktags.cpp.ok
% cp mktags.cpp.bug mktags.cpp
% !ma
% !pu
% !da
勿論だが, 再現している

% diff -rc mktags.cpp mktags.cpp.bug 
*** mktags.cpp	2021-05-20 07:06:49.799922520 +0900
--- mktags.cpp.bug	2021-05-20 06:56:56.925334469 +0900
***************
*** 869,875 ****
    do_line(bp);
  
    do_info(bp);
!   // debug_info_impl::modify_enumerator();
  
    do_macro(bp);
  
--- 869,875 ----
    do_line(bp);
  
    do_info(bp);
!   debug_info_impl::modify_enumerator();
  
    do_macro(bp);
  
% !ma
% pushd
% !date
正常終了


impl_conv
ix86_entity

そもそも enum_type の後に enumerator が来ないというのはどういうケース
なんだろう.

set_decl_file で contents が空のケースはどういう場合?
すでに file がセットされているのはどういう場合?

-e オプションなしだと正常終了する... => 勘違い


       o endl に対してタグが生成されていない. 実際 objdump -g の結果
         にも出現していない. endl の定義は以下:

~/gcc-10.2.0/libstdc++-v3/include/std/ostream
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
       
       o string に対してのジャンプ先に

  typedef basic_string<char>    string;

         がない. TAGS にはその部分はある. Lisp の函数の問題なのか TAGS
	 の問題かは不明.
        
       o get_rpath に対してタグジャンプできていない.

       o create に対してタグジャンプすると 4 つ目の候補にパラメータの
         create とする函数にジャンプしてしまう.

       o table に対してタグジャンプすると名前空間の table にジャンプ
         できていない. 例えば他の debug_macro_impl などの名前空間
	 ならば期待通りタグジャンプできている.

       o mode_t::emacs は emacs でタグジャンプして期待する動作に
         なっている.

       o TAGS を見ると分かるが mktags.cpp や my_dwarf.c my_objdump.c
         が後になっている. これが先にくるべき.

       o cywin 版で cannot open のメッセージが多数出ているが, おそらく
         パスの作り方に誤りがある. => linux 版でも再現している.


        

              
