タグ生成

(*1) vi での ctags の簡単な使い方
(*2) emacs での ctags の簡単な使い方
(*3) プログラムファイルからタグファイルを生成する
(*4) mktags.exe のビルド方法
(*5) tags のフォーマット
(*6) TAGS のフォーマット
o(*7) C++ の STL に emacs でタグジャンプする.
(*8) コンテキスト
(*9) gcc の -g3 オプション
(*10) 使っていて気付いたこと

(*1) vi での ctags の簡単な使い方

起動時にタグジャンプ	vi -t <タグ名>
タグジャンプ		:ta <タグ名>
タグジャンプ		Ctrl-]
元に戻る			Ctrl-T
次の候補			???

% cat a.c
#include <stdio.h>

void f();

#define X 2

int main()
{
  printf("hello\n");
  f();
  return 0;
}
% cat b.c
#include "d.h"

int a;

void g(int);

void f()
{
  g(a);
  g(X);
}

int f2(location loc)
{
  return loc;
}
% cat c.c
#include <stdio.h>
#include "d.h"

void g(int n)
{
  printf("n = %d\n", n);
}

extern int a;

void h(struct S* ps)
{
  printf("ps->m = %d\n", ps->m);
  printf("a = %d\n", a);
}
% cat d.h
#ifndef D_H
#define D_H

#define X 1

struct S {
  int m;
};

typedef unsigned int location;

#endif /* D_H */
% ctags a.c b.c c.c d.h
# tags というファイルが生成される
% vi -t location
# vi が起動して d.h の location の定義位置が表示される
vi のコマンドで
:ta main
のようにするとタグ main ジャンプできる.
探したい名前のところにカーソルをもっていって

Ctrl-] 

とすればタグジャンプできる. タグジャンプした後

Ctrl-T

とすればもとに戻ることができる.

(*2) emacs での ctags の簡単な使い方

タグファイルを読み込む	M-x visit-tags-table
タグジャンプ		M-.
元に戻る			M-*
次の候補			C-u M-.

% ctags -e b.c c.c hoge.c d.h
# TAGS というファイルが作成される

emacs を起動して

M-x visit-tags-table

で生成した TAGS を指定する. 通常はカレントディレクトリの TAGS ファイルを
開こうとしているから, その場合はリターンキーを押せばよい.
これは明示的にやらなくてもタグジャンプしようとするとどの TAGS を
使うか聞いてくるのでそれに答えればよい.

ファイルを開いた状態で探したい名前のところにカーソルをもっていって

M-.

とすればタグジャンプできる. タグジャンプした後

M-*

とすればもとに戻ることができる.

C-u M-.

とすれば複数候補の次にジャンプする. a.c と d.h にマウロ X の
定義がそれぞれあるので X にタグジャンプすると
a.c の X の定義にジャンプする. その後

C-u M-.

とすると d.h の X の定義にジャンプする.

(*3) プログラムファイルからタグファイルを生成する

% ./mktags.exe a.out
# tags が生成される. vi 用
% ./mktags -e a.out
# TAGS が生成される. emacs 用.

オプション:

-a : 絶対パスで生成する. デフォルトでは相対パスで生成.
-e : TAGS を生成する. emacs 用. デフォルトでは tags を生成する. vi 用.
-v : objdump -g が出力する結果を標準出力に書き出す.
-E <ディレクトリ> : -E /usr のように使用する. /usr から始まるファイルを
                    無視する.

(*4) mktags.exe のビルド方法

1. binutils をソースファイルからビルドする.

    トップ -> 「GNU のツール」->
    「linux での binutils 2.36.1 インストールメモ」

    が参考になる. cygwin でもトラブルが発生せずビルドとインストールが
    できている.

2. このページにある mktags.cpp my_dwarf.c my_objdump.c Makefile
   をダウンロードして以下のように実行する:

% make -n
# g++, gcc の起動方法を確認する. Makefile の BINUTILS_DIR を自分の環境に
# 合わせて修正する.
% make
# 正しく動けば同じディレクトリに mktags.exe をビルドできる.

(*5) tags のフォーマット

(タグ名)	(ファイル名)	(vi コマンド)"	[fvdsm]	[file:]

例えば
HOGE	./a.c	1;"	d	file:
main	./a.c	/^int main()$/;"	f

は

    o タグ HOGE に対して ./a.c を開いて 1 行目にジャンプするということを
      意味しているようである.
    o タグ main に対して ./a.c を開いて正規表現 ^int main()$
      を検索することを意味しているようである.

(*6) TAGS のフォーマット

    (*5) を TAGS で表現すると以下のようになる:

^L
./a.c,45
#define HOGE 1^?HOGE^A1,0
int main()^?main^A3,16

     ^L : エスケープ文字 '\f'
     45 : #define ... 16 までのバイト数
     ^? : 0177 を putc したもの
     ^A : 1 を putc したもの

^L
ファイル名,バイト数
テキスト1^Lタグ名1^A行番号1,ファイル内オフセット1
...

     のようになる.

(*7) C++ の STL に emacs でタグジャンプする.
% cat a.cpp
#include <vector>

int main()
{
  using namespace std;
  vector<int> vi;
  return 0;
}
% g++ -g3 a.cpp -o a.out
% ./mktags.exe -e a.out

     として TAGS を生成する. emacs で vector へタグジャンプしてみる.
     ジャンプした先は

/usr/local/include/c++/10.2.0/vector

     の 1 行目であった. これはどういうことかというと, emacs の対応する
     Lisp の函数の仕様で, ファイル名に vector というものがあればそこに
     ジャンプするということらしい.

     ファイル名ではなくて vector の宣言にジャンプするには
     Find tag の引数に以下を指定する:

vector<int, std::allocator<int> >

     これは面倒だが機能してはいる. std::vector ではなくて単に vector
     になっているのは a.cpp の書き方に依存しているようである.

     ファイル名にもジャンプするという emacs Lisp の対応する函数の仕様は
     期せずして有用なものではある. 例えば mktags.exe 自身の TAGS を生成
     して dwarf2.h にタグジャンプすれば全く身に覚えのない,
     しかしビルド時に参照しているヘッダーファイルを簡単に開くことができる.
     ジャンプ先は dwarf2 ではなく dwarf2.h である. そうしないと意図した
     ところにジャンプできない.

(*8) コンテキスト

     当然ながら emacs のタグジャンプでは対象が何かを判断していない.
     そういう仕様だからであるし, これは妥当に思える. 高望みすればタグ
     ジャンプする先は最小限であってほしい. コンテキストを理解すれば

#include <vector> ここでタグジャンプしたらファイル vector を開く

int main()
{
  using namespace std;
  vector<int> vi; ここでタグジャンプしたら vector のクラス宣言にジャンプ
  return 0;       次の候補は vector のデフォルトコンストラクタ
}

     コンパイラはその情報を生成してはいる. しかしタグジャンプで
     上のような動作を実現することは難しい. mktags.exe の生成した
     タグファイルで vector にタグジャンプすると

     第一候補 : ファイル vector
     第二候補 : メンバ名の const bfd_target *vector
     第三候補 : vector のデフォルトコンストラクタ

     になっていた. 第二候補が出るのは仕様とはいえ, 非常に残念である.

(*9) gcc の -g3 オプション

     -g オプションとの違いはマクロの情報が生成されることである.
     gdb や mktags.exe はこれらの情報を使用してプログラマに有用な
     情報を提供する. しかし -g オプションだけでも通常のデバッグ
     情報が生成されるので, マクロへのタグジャンプが必要でなければ
     必要ない.

(*10) 使っていて気付いたこと

     デバッグビルドした cc1 に mktags.exe を実行した結果:

linux % date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e  ; date

     mktag.exe を -O0 ビルドしたものでは 3 分で終了している. -O3
     ビルドで試してみたところ 2 分 20 秒くらいだった.

     mktags.exe 自身の TAGS ファイルに対して気付いたこと:

    o endl に対してタグが生成されていない. 実際 objdump -g の結果
      にも出現していないのでタグが生成されないのは正しい.
      しかし objdump -g に出現しないのはなぜだろうか. endl の定義は以下:

~/gcc-10.2.0/libstdc++-v3/include/std/ostream
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }

       そもそも operator<< に対してもタグが生成されていない.
       test019 で operator<< をテストしてみたが期待通りの動作.
       それならば

       ostream&  std::operator<<(std::ostream&, const char*);
       
       に対してはなぜタグが生成されないのか. test020 を試してみたが
       これも期待通り動作している.
        
     o create に対してタグジャンプすると 6 つ目の候補にパラメータを
       create とする函数:

static struct data_struct *
find_chunk (bfd *abfd, bfd_vma vma, bfd_boolean create)

        にジャンプしてしまう. 確認してみたが create に対する
        タグは意図した通り生成されていた. おそらく Lisp の函数がそういう
        仕様なのだろう.

      o bfd_openr 等に対しては函数の宣言と定義の両方に対してタグが生成
        されている. しかし通常は宣言に対してはタグが生成されない.
	objdump -g がそうなっているからで mktags.exe 自体の問題ではないが
	気になるところ.
	free も宣言に対してタグジャンプできている.

      o ostringstream に対してタグジャンプすると

  typedef basic_ostringstream<char> 	ostringstream;

        期待するところへジャンプできている. しかし
	basic_ostringstream の宣言は TAGS にない. これは...
	必要な情報が生成されていないということなのだろうか.
