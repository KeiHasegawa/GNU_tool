タグ生成

(*1) vi での ctags の簡単な使い方
(*2) emacs での ctags の簡単な使い方
(*3) プログラムファイルからタグファイルを生成する
(*4) mktags.exe のビルド方法
(*5) tags のフォーマット
(*6) TAGS のフォーマット
(*7) C++ の STL に emacs でタグジャンプする.
(*8) コンテキスト
(*9) gcc の -g3 オプション
(*10) 巨大なプログラムに対する動作
(*11) emacs のタグジャンプのゆるさ
(*12) 不完全型構造体の扱い
(*13) C++ テンプレートのインスタンシエーション
(*14) C++ テンプレートのインスタンシエーション(その2)
(*15) enum のメンバ
(*16) Windows 版の emacs
(*17) 函数の宣言

(*1) vi での ctags の簡単な使い方

起動時にタグジャンプ	vi -t <タグ名>
タグジャンプ		:ta <タグ名>
タグジャンプ		Ctrl-]
元に戻る			Ctrl-T

% cat a.c
#include <stdio.h>

void f();

#define X 2

int main()
{
  printf("hello\n");
  f();
  return 0;
}
% cat b.c
#include "d.h"

int a;

void g(int);

void f()
{
  g(a);
  g(X);
}

int f2(location loc)
{
  return loc;
}
% cat c.c
#include <stdio.h>
#include "d.h"

void g(int n)
{
  printf("n = %d\n", n);
}

extern int a;

void h(struct S* ps)
{
  printf("ps->m = %d\n", ps->m);
  printf("a = %d\n", a);
}
% cat d.h
#ifndef D_H
#define D_H

#define X 1

struct S {
  int m;
};

typedef unsigned int location;

#endif /* D_H */
% ctags a.c b.c c.c d.h
# tags というファイルが生成される
% vi -t location
# vi が起動して d.h の location の定義位置が表示される
vi のコマンドで
:ta main
のようにするとタグ main ジャンプできる.
探したい名前のところにカーソルをもっていって

Ctrl-] 

とすればタグジャンプできる. タグジャンプした後

Ctrl-T

とすればもとに戻ることができる.

(*2) emacs での ctags の簡単な使い方

タグファイルを読み込む	M-x visit-tags-table
タグジャンプ		M-.
元に戻る			M-*
次の候補			C-u M-.

% ctags -e b.c c.c hoge.c d.h
# TAGS というファイルが作成される

emacs を起動して

M-x visit-tags-table

で生成した TAGS を指定する. 通常はカレントディレクトリの TAGS ファイルを
開こうとしているから, その場合はリターンキーを押せばよい.
これは明示的にやらなくてもタグジャンプしようとするとどの TAGS を
使うか聞いてくるのでそれに答えればよい.

ファイルを開いた状態で探したい名前のところにカーソルをもっていって

M-.

とすればタグジャンプできる. タグジャンプした後

M-*

とすればもとに戻ることができる.

C-u M-.

とすれば複数候補の次にジャンプする. a.c と d.h にマウロ X の
定義がそれぞれあるので X にタグジャンプすると
a.c の X の定義にジャンプする. その後

C-u M-.

とすると d.h の X の定義にジャンプする.

(*3) プログラムファイルからタグファイルを生成する

% ./mktags.exe a.out
# tags が生成される. vi 用
% ./mktags -e a.out
# TAGS が生成される. emacs 用.

オプション:

-a : 絶対パスで生成する. デフォルトでは相対パスで生成.
-e : TAGS を生成する. emacs 用. デフォルトでは tags を生成する. vi 用.
-v : objdump -g が出力する結果を標準出力に書き出す.
-E <ディレクトリ> : -E /usr のように使用する. /usr から始まるファイルを
                    無視する.

(*4) mktags.exe のビルド方法

1. binutils をソースファイルからビルドする.

    トップ -> 「GNU のツール」->
    「linux での binutils 2.36.1 インストールメモ」

    が参考になる. cygwin でもトラブルが発生せずビルドとインストールが
    できている.

2. このページにある mktags.cpp my_dwarf.c my_objdump.c Makefile
   をダウンロードして以下のように実行する:

% make -n
# g++, gcc の起動方法を確認する. Makefile の BINUTILS_DIR を自分の環境に
# 合わせて修正する.
% make
# 正しく動けば同じディレクトリに mktags.exe をビルドできる.

(*5) tags のフォーマット

(タグ名)	(ファイル名)	(vi コマンド)"	[fvdsm]	[file:]

例えば
HOGE	./a.c	1;"	d	file:
main	./a.c	/^int main()$/;"	f

は

    o タグ HOGE に対して ./a.c を開いて 1 行目にジャンプするということを
      意味しているようである.
    o タグ main に対して ./a.c を開いて正規表現 ^int main()$
      を検索することを意味しているようである.

(*6) TAGS のフォーマット

    (*5) を TAGS で表現すると以下のようになる:

^L
./a.c,45
#define HOGE 1^?HOGE^A1,0
int main()^?main^A3,16

     ^L : エスケープ文字 '\f'
     45 : #define ... 16 までのバイト数
     ^? : 0177 を putc したもの
     ^A : 1 を putc したもの

^L
ファイル名,バイト数
テキスト1^Lタグ名1^A行番号1,ファイル内オフセット1
...

     のようになる.

(*7) C++ の STL に emacs でタグジャンプする.

% cat a.cpp
#include <vector>

int main()
{
  using namespace std;
  vector<int> vi;
  return 0;
}
% g++ -g3 a.cpp -o a.out
% ./mktags.exe -e a.out

     として TAGS を生成する. emacs で vector へタグジャンプしてみる.
     ジャンプした先は

/usr/local/include/c++/10.2.0/vector

     の 1 行目であった. これはどういうことかというと, find-tag の仕様で,
     ファイル名に vector というものがあればそこにジャンプするということ
     らしい. ここで　find-tag は M-. に割り当てられた lisp の函数のこと
     である.

     ファイル名ではなくて vector の宣言にジャンプするには
     find-tag の引数に以下を指定する:

vector<int, std::allocator<int> >

     これは面倒だが機能してはいる. std::vector ではなくて単に vector
     になっているのは a.cpp の書き方に依存しているようである.

     ファイル名にもジャンプするという find-tag の仕様は期せずして有用な
     ものではある. 例えば mktags.exe 自身の TAGS を生成して dwarf2.h に
     タグジャンプすれば

#include "dwarf2.h"  ここでタグジャンプ

     全く身に覚えのない, しかしビルド時に参照しているヘッダーファイルを簡単
     に開くことができる. ジャンプ先は dwarf2 ではなく dwarf2.h である. そう
     しないと意図したところにジャンプできない.

(*8) コンテキスト

     当然ながら emacs のタグジャンプでは対象が何かを判断していない.
     そういう仕様だからであるし, これは妥当に思える. 高望みすればタグ
     ジャンプする先は最小限であってほしい. find-tag がコンテキストを
     理解すれば

#include <vector> ここでタグジャンプしたらファイル vector を開く

int main()
{
  using namespace std;
  vector<int> vi; ここでタグジャンプしたら vector のクラス宣言にジャンプ
  return 0;       次の候補は vector のデフォルトコンストラクタ
}

     コンパイラはその情報を生成してはいる. しかしタグジャンプで
     上のような動作を実現することは難しい. mktags.exe の生成した
     タグファイルで vector にタグジャンプすると

     第一候補 : ファイル vector
     第二候補 : メンバ名の const bfd_target *vector
     第三候補 : vector のデフォルトコンストラクタ

     になっていた. 第二候補が出るのは仕様とはいえ, 非常に残念である.

(*9) gcc の -g3 オプション

     -g オプションとの違いはマクロの情報が生成されることである.
     gdb や mktags.exe はこれらの情報を使用してプログラマに有用な
     情報を提供する. しかし -g オプションだけでも通常のデバッグ
     情報が生成されるので, マクロへのタグジャンプをしないのであれば
     -g で十分である.

(*10) 巨大なプログラムに対する動作

     デバッグビルドした cc1 に mktags.exe を実行した結果:

linux % ls -l cc1
-rwxrwxr-x 1 khasegawa khasegawa 140158720  Mon 11 08:44 cc1
linux % date ; ~/lang/53_GNU_tool/mktags/mktags.exe cc1 -e  ; date

     mktag.exe を -O0 ビルドしたものでは 3 分で終了している. -O3
     ビルドで試してみたところ 2 分 20 秒くらいだった.

     mktags.exe の動作は objdump -g よりも少し複雑な動作をしている
     からそれよりも時間がかかることになる(と予想した). インストールされて
     いる  objdump は -O2 ビルドされているが, cc1 に対する実行結果は
     3 分 30 秒くらいだった. 予想とは違い objdump -g のほうが実行時間
     が長かったが, これは I/O アクセスのコストが高いということ
     だと考えられる.

(*11) emacs のタグジャンプのゆるさ

     mktags.exe 自身の TAGS を生成すると create に対するタグが 4 つ
     生成されている. しかし 5 個目の候補もある. それが以下.

static struct data_struct *
find_chunk (bfd *abfd, bfd_vma vma, bfd_boolean create)

     これにジャンプしてしまう. おそらく find-tag がそういう仕様なの
     だろう. 上は勿論 find_chunk というタグに対応した箇所である. 

(*12) 不完全型構造体の扱い

% cat a.c
struct S;

int main()
{
  struct S* ps = 0;
  return 0;
}
% gcc -g3 a.c -o a.out
% ./mktags.exe a.out
# tags には構造体 S のタグが生成されていない

      これは残念ながら gcc がそういう扱いをしているのでタグが生成されない
      ということになる.

(*13) C++ テンプレートのインスタンシエーション

% cat a.cpp
template<class C1> struct S1 {};

template<class C2> struct S2 {};

int main()
{
  S1<int>* p = nullptr;
  S2<int> si;
  return 0;
}
% g++ -g a.cpp -o a.out
% ./mktags.exe a.out
# tags には S1<int> のタグは生成されていない. S2<int> に対してはタグが生成
# されている.

     これも g++ が S1<int> に対して行番号情報を生成していないのでこういう
     結果になっている.

(*14) C++ テンプレートのインスタンシエーション(その2)

% cat a.cpp
template<class C> struct S {};

extern template class S<int>;

int main()
{
  return 0;
}
% g++ -g a.cpp -o a.out
% ./mktags.exe a.out
# S<int> のタグは生成されない

     これも g++ が S<int> に対して, 行番号はおろか, 名前すらも生成してい
     ないからこのような結果になってしまっている. これが仕様だとするならば,
     それ自体に問題がある.

     C++ 版の hello world だが

% cat a.cpp
#include <iostream>

int main()
{
  using namespace std;
  cout << "hello" << endl;
  return 0;
}

     これに対して operator<< や endl に対してタグが生成されないのも
     同じ理由である. cout は変数なので期待するタグは生成されている.

(*15) enum のメンバ

     現状 enum のメンバに対してタグを生成しているが, これは enum の
     タグ名に対する行番号を mktags.exe で付加している:

enum E {  // タグ名が E
  a,      // enum のメンバ
  b,      // enum のメンバ
  c       // enum のメンバ
};

     上の例なら, gcc が a, b, c に対して行番号情報を生成しないので E の
     行番号情報を付加しているということである. だから a に対してタグ
     ジャンプすると E の行にカーソルが移動する.

(*16) Windows 版の emacs

     バージョン 26.3 での結果. (linux 版の emacs は 23.3.1 と少し古め)

     M-. は find-tag ではなくて find-tag-noselect に対応している.
     そもそも find-tag はないらしい.

     複数候補あるタグに対して M-. をすると一覧がでてきて分かりやすい
     かと思いきや, そこから選択して目的のファイルにジャンプする方法が
     分からない.

     C-u M-. は次の候補ではなくて定義位置にジャンプするらしいが, 少なくとも
     mktags.exe が生成している TAGS は定義位置と定義ではない宣言位置を
     区別してはいない.
     
     M-* は pop-tag-mark にキーバインドされていない. 自分で設定する必要
     がある.

(*17) 函数の宣言

     通常は宣言に対してはタグが生成されない. これは gcc がタグを生成する
     情報をだしていないためである.

     しかし mktags.exe 自身の TAGS ファイルで試したところ bfd_openr 等に対
     しては函数の宣言と定義の両方に対してタグが生成されている.

     objdump -g がそうなっているからで mktags.exe 自体の問題ではないが
     気になるところではある.

     free に対しても宣言に対してタグが生成されている. 原因は調査中で,
     単純なテストでは再現しない.
